{"version":3,"file":"ModelImpl-DjdwMiMr.js","sources":["../../models/trace/extras/FilmStrip.js","../../models/trace/helpers/Extensions.js","../../models/trace/helpers/Network.js","../../models/trace/extras/URLForEntry.js","../../models/trace/handlers/AnimationHandler.js","../../models/trace/handlers/UserTimingsHandler.js","../../models/trace/handlers/ExtensionTraceDataHandler.js","../../models/trace/handlers/LayerTreeHandler.js","../../models/trace/handlers/Threads.js","../../models/trace/handlers/FramesHandler.js","../../models/trace/handlers/GPUHandler.js","../../models/trace/handlers/ImagePaintingHandler.js","../../models/trace/handlers/InitiatorsHandler.js","../../models/trace/handlers/InvalidationsHandler.js","../../models/trace/handlers/LargestImagePaintHandler.js","../../models/trace/handlers/LargestTextPaintHandler.js","../../models/trace/handlers/ScreenshotsHandler.js","../../models/trace/handlers/LayoutShiftsHandler.js","../../models/trace/handlers/MemoryHandler.js","../../models/trace/handlers/NetworkRequestsHandler.js","../../models/trace/handlers/PageFramesHandler.js","../../models/trace/handlers/PageLoadMetricsHandler.js","../../models/trace/handlers/SelectorStatsHandler.js","../../models/trace/handlers/ServerTimingsHandler.js","../../models/trace/handlers/UserInteractionsHandler.js","../../models/trace/handlers/WarningsHandler.js","../../models/trace/handlers/WorkersHandler.js","../../models/trace/insights/Common.js","../../models/trace/insights/CumulativeLayoutShift.js","../../models/trace/insights/DocumentLatency.js","../../models/trace/insights/FontDisplay.js","../../models/trace/insights/InteractionToNextPaint.js","../../models/trace/insights/LargestContentfulPaint.js","../../models/trace/insights/RenderBlocking.js","../../models/trace/insights/SlowCSSSelector.js","../../models/trace/insights/ThirdPartyWeb.js","../../models/trace/insights/Viewport.js","../../models/trace/lantern/core/LanternError.js","../../models/trace/lantern/core/NetworkAnalyzer.js","../../models/trace/lantern/graph/BaseNode.js","../../models/trace/lantern/graph/CPUNode.js","../../models/trace/lantern/graph/NetworkNode.js","../../models/trace/lantern/graph/PageDependencyGraph.js","../../models/trace/lantern/metrics/Metric.js","../../models/trace/lantern/metrics/FirstContentfulPaint.js","../../models/trace/lantern/metrics/Interactive.js","../../models/trace/lantern/metrics/LargestContentfulPaint.js","../../models/trace/lantern/metrics/TBTUtils.js","../../models/trace/lantern/metrics/TotalBlockingTime.js","../../models/trace/lantern/simulation/TCPConnection.js","../../models/trace/lantern/simulation/ConnectionPool.js","../../models/trace/lantern/simulation/Constants.js","../../models/trace/lantern/simulation/DNSCache.js","../../models/trace/lantern/simulation/SimulationTimingMap.js","../../models/trace/lantern/simulation/Simulator.js","../../models/trace/lantern/types/Lantern.js","../../models/trace/LanternComputationData.js","../../models/trace/Processor.js","../../models/trace/ModelImpl.js"],"sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n//\nimport * as Platform from '../../../core/platform/platform.js';\n// Cache film strips based on:\n// 1. The trace parsed data object\n// 2. The start time.\nconst filmStripCache = new WeakMap();\nexport function fromParsedTrace(parsedTrace, customZeroTime) {\n    const frames = [];\n    const zeroTime = typeof customZeroTime !== 'undefined' ? customZeroTime : parsedTrace.Meta.traceBounds.min;\n    const spanTime = parsedTrace.Meta.traceBounds.range;\n    const fromCache = filmStripCache.get(parsedTrace)?.get(zeroTime);\n    if (fromCache) {\n        return fromCache;\n    }\n    for (const screenshotEvent of parsedTrace.Screenshots.all) {\n        if (screenshotEvent.ts < zeroTime) {\n            continue;\n        }\n        const frame = {\n            index: frames.length,\n            screenshotEvent,\n        };\n        frames.push(frame);\n    }\n    const result = {\n        zeroTime,\n        spanTime,\n        frames: Array.from(frames),\n    };\n    const cachedForData = Platform.MapUtilities.getWithDefault(filmStripCache, parsedTrace, () => new Map());\n    cachedForData.set(zeroTime, result);\n    return result;\n}\nexport function frameClosestToTimestamp(filmStrip, searchTimestamp) {\n    const closestFrameIndexBeforeTimestamp = Platform.ArrayUtilities.nearestIndexFromEnd(filmStrip.frames, frame => frame.screenshotEvent.ts < searchTimestamp);\n    if (closestFrameIndexBeforeTimestamp === null) {\n        return null;\n    }\n    return filmStrip.frames[closestFrameIndexBeforeTimestamp];\n}\n//# sourceMappingURL=FilmStrip.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport { sortTraceEventsInPlace } from './Trace.js';\nimport { canBuildTreesFromEvents, treify } from './TreeHelpers.js';\nexport function buildTrackDataFromExtensionEntries(extensionEntries, extensionTrackData, entryToNode) {\n    const dataByTrack = new Map();\n    for (const entry of extensionEntries) {\n        // Batch data by track group. For each batch, add the data of every\n        // track in the group. In cases where no track group is provided,\n        // we use the standalone track data, but use a fixed prefix in the\n        // batch key to prevent collisions where a track group has the\n        // same name as a standalone track.\n        const key = entry.args.trackGroup || `track-name-${entry.args.track}`;\n        const batchedData = Platform.MapUtilities.getWithDefault(dataByTrack, key, () => ({\n            name: entry.args.trackGroup || entry.args.track,\n            isTrackGroup: Boolean(entry.args.trackGroup),\n            entriesByTrack: { [entry.args.track]: [] },\n        }));\n        if (!batchedData.entriesByTrack[entry.args.track]) {\n            batchedData.entriesByTrack[entry.args.track] = [];\n        }\n        const entriesInTrack = batchedData.entriesByTrack[entry.args.track];\n        entriesInTrack.push(entry);\n    }\n    // Calculate self time if possible for track entries, on a track\n    // by track basis.\n    for (const trackData of dataByTrack.values()) {\n        for (const entries of Object.values(trackData.entriesByTrack)) {\n            sortTraceEventsInPlace(entries);\n            if (canBuildTreesFromEvents(entries)) {\n                for (const [entry, node] of treify(entries).entryToNode) {\n                    entryToNode.set(entry, node);\n                }\n            }\n        }\n        extensionTrackData.push(trackData);\n    }\n    return { extensionTrackData, entryToNode };\n}\n//# sourceMappingURL=Extensions.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// Important: we purposefully treat `potentially_blocking` as\n// non-render-blocking here because:\n// 1. An async script can run on the main thread at any point, including before\n//    the page is loaded\n// 2. An async script will never block the parsing and rendering process of the\n//    browser.\n// 3. Therefore, from a developer's point of view, there is nothing more they\n//    can do if they've put `async` on, and within the context of Insights, we\n//    shouldn't report an async script as render blocking.\n// In the future we may want to consider suggesting the use of `defer` over\n// `async`, as it doesn't have this concern, but for now we'll allow `async`\n// and not report it as an issue.\nconst NON_RENDER_BLOCKING_VALUES = new Set([\n    'non_blocking',\n    'dynamically_injected_non_blocking',\n    'potentially_blocking',\n]);\nexport function isSyntheticNetworkRequestEventRenderBlocking(event) {\n    return !NON_RENDER_BLOCKING_VALUES.has(event.args.data.renderBlocking);\n}\n//# sourceMappingURL=Network.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n/**\n * Use this helper whenever resolving an URL's source mapping is not an\n * option. For example when processing non-ui data. Otherwise use the\n * helper SourceMapsResolver::resolvedURLForEntry\n *\n * If an URL will be displayed in the UI, it's likely you should not use\n * this helper and prefer the other option instead.\n */\nexport function getNonResolved(parsedTrace, entry) {\n    if (Types.Events.isProfileCall(entry)) {\n        return entry.callFrame.url;\n    }\n    if (entry.args?.data?.stackTrace && entry.args.data.stackTrace.length > 0) {\n        return entry.args.data.stackTrace[0].url;\n    }\n    if (Types.Events.isSyntheticNetworkRequest(entry)) {\n        return entry.args.data.url;\n    }\n    // DecodeImage events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDecodeImage(entry)) {\n        const paintEvent = parsedTrace.ImagePainting.paintImageForEvent.get(entry);\n        return paintEvent ? getNonResolved(parsedTrace, paintEvent) : null;\n    }\n    // DrawLazyPixelRef events use the URL from the relevant PaintImage event.\n    if (Types.Events.isDrawLazyPixelRef(entry) && entry.args?.LazyPixelRef) {\n        const paintEvent = parsedTrace.ImagePainting.paintImageByDrawLazyPixelRef.get(entry.args.LazyPixelRef);\n        return paintEvent ? getNonResolved(parsedTrace, paintEvent) : null;\n    }\n    // ParseHTML events store the URL under beginData, not data.\n    if (Types.Events.isParseHTML(entry)) {\n        return entry.args.beginData.url;\n    }\n    // For all other events, try to see if the URL is provided, else return null.\n    if (entry.args?.data?.url) {\n        return entry.args.data.url;\n    }\n    return null;\n}\n//# sourceMappingURL=URLForEntry.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nconst animations = [];\nconst animationsSyntheticEvents = [];\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function reset() {\n    animations.length = 0;\n    animationsSyntheticEvents.length = 0;\n}\nexport function handleEvent(event) {\n    if (Types.Events.isAnimation(event)) {\n        animations.push(event);\n        return;\n    }\n}\nexport async function finalize() {\n    const syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(animations);\n    animationsSyntheticEvents.push(...syntheticEvents);\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('Animation handler is not finalized');\n    }\n    return {\n        animations: animationsSyntheticEvents,\n    };\n}\n//# sourceMappingURL=AnimationHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n/**\n * IMPORTANT!\n * See UserTimings.md in this directory for some handy documentation on\n * UserTimings and the trace events we parse currently.\n **/\nlet syntheticEvents = [];\nconst performanceMeasureEvents = [];\nconst performanceMarkEvents = [];\nconst consoleTimings = [];\nconst timestampEvents = [];\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function reset() {\n    syntheticEvents.length = 0;\n    performanceMeasureEvents.length = 0;\n    performanceMarkEvents.length = 0;\n    consoleTimings.length = 0;\n    timestampEvents.length = 0;\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nconst resourceTimingNames = [\n    'workerStart',\n    'redirectStart',\n    'redirectEnd',\n    'fetchStart',\n    'domainLookupStart',\n    'domainLookupEnd',\n    'connectStart',\n    'connectEnd',\n    'secureConnectionStart',\n    'requestStart',\n    'responseStart',\n    'responseEnd',\n];\nconst navTimingNames = [\n    'navigationStart',\n    'unloadEventStart',\n    'unloadEventEnd',\n    'redirectStart',\n    'redirectEnd',\n    'fetchStart',\n    'commitNavigationEnd',\n    'domainLookupStart',\n    'domainLookupEnd',\n    'connectStart',\n    'connectEnd',\n    'secureConnectionStart',\n    'requestStart',\n    'responseStart',\n    'responseEnd',\n    'domLoading',\n    'domInteractive',\n    'domContentLoadedEventStart',\n    'domContentLoadedEventEnd',\n    'domComplete',\n    'loadEventStart',\n    'loadEventEnd',\n];\n// These are events dispatched under the blink.user_timing category\n// but that the user didn't add. Filter them out so that they do not\n// Appear in the timings track (they still appear in the main thread\n// flame chart).\nconst ignoredNames = [...resourceTimingNames, ...navTimingNames];\n/**\n * Similar to the default {@see Helpers.Trace.eventTimeComparator}\n * but with a twist:\n * In case of equal start and end times, always put the second event\n * first.\n *\n * Explanation:\n * User timing entries come as trace events dispatched when\n * performance.measure/mark is called. The trace events buffered in\n * devtools frontend are sorted by the start time. If their start time\n * is the same, then the event for the first call will appear first.\n *\n * When entries are meant to be stacked, the corresponding\n * performance.measure calls usually are done in bottom-up direction:\n * calls for children first and for parent later (because the call\n * is usually done when the measured task is over). This means that\n * when two user timing events have the start and end time, usually the\n * second event is the parent of the first. Hence the switch.\n *\n */\nfunction userTimingComparator(a, b, originalArray) {\n    const aBeginTime = a.ts;\n    const bBeginTime = b.ts;\n    if (aBeginTime < bBeginTime) {\n        return -1;\n    }\n    if (aBeginTime > bBeginTime) {\n        return 1;\n    }\n    const aDuration = a.dur ?? 0;\n    const bDuration = b.dur ?? 0;\n    const aEndTime = aBeginTime + aDuration;\n    const bEndTime = bBeginTime + bDuration;\n    if (aEndTime > bEndTime) {\n        return -1;\n    }\n    if (aEndTime < bEndTime) {\n        return 1;\n    }\n    // Prefer the event located in a further position in the original array.\n    return originalArray.indexOf(b) - originalArray.indexOf(a);\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('UserTimings handler is not initialized');\n    }\n    if (ignoredNames.includes(event.name)) {\n        return;\n    }\n    if (Types.Events.isPerformanceMeasure(event)) {\n        performanceMeasureEvents.push(event);\n        return;\n    }\n    if (Types.Events.isPerformanceMark(event)) {\n        performanceMarkEvents.push(event);\n    }\n    if (Types.Events.isConsoleTime(event)) {\n        consoleTimings.push(event);\n    }\n    if (Types.Events.isTimeStamp(event)) {\n        timestampEvents.push(event);\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('UserTimings handler is not initialized');\n    }\n    const asyncEvents = [...performanceMeasureEvents, ...consoleTimings];\n    syntheticEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(asyncEvents);\n    syntheticEvents = syntheticEvents.sort((a, b) => userTimingComparator(a, b, [...syntheticEvents]));\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('UserTimings handler is not finalized');\n    }\n    return {\n        performanceMeasures: syntheticEvents.filter(e => e.cat === 'blink.user_timing'),\n        consoleTimings: syntheticEvents.filter(e => e.cat === 'blink.console'),\n        // TODO(crbug/41484172): UserTimingsHandler.test.ts fails if this is not copied.\n        performanceMarks: [...performanceMarkEvents],\n        timestampEvents: [...timestampEvents],\n    };\n}\n//# sourceMappingURL=UserTimingsHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as userTimingsData } from './UserTimingsHandler.js';\nconst extensionFlameChartEntries = [];\nconst extensionTrackData = [];\nconst extensionMarkers = [];\nconst entryToNode = new Map();\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function handleEvent(_event) {\n    // Implementation not needed because data is sourced from UserTimingsHandler\n}\nexport function reset() {\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n    extensionFlameChartEntries.length = 0;\n    extensionTrackData.length = 0;\n    extensionMarkers.length = 0;\n    entryToNode.clear();\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('ExtensionTraceData handler is not initialized');\n    }\n    createExtensionFlameChartEntries();\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nfunction createExtensionFlameChartEntries() {\n    const pairedMeasures = userTimingsData().performanceMeasures;\n    const marks = userTimingsData().performanceMarks;\n    const mergedRawExtensionEvents = Helpers.Trace.mergeEventsInOrder(pairedMeasures, marks);\n    extractExtensionEntries(mergedRawExtensionEvents);\n    Helpers.Extensions.buildTrackDataFromExtensionEntries(extensionFlameChartEntries, extensionTrackData, entryToNode);\n}\nexport function extractExtensionEntries(timings) {\n    for (const timing of timings) {\n        const extensionPayload = extensionDataInTiming(timing);\n        if (!extensionPayload) {\n            // Not an extension user timing.\n            continue;\n        }\n        const extensionSyntheticEntry = {\n            name: timing.name,\n            ph: \"X\" /* Types.Events.Phase.COMPLETE */,\n            pid: Types.Events.ProcessID(0),\n            tid: Types.Events.ThreadID(0),\n            ts: timing.ts,\n            dur: timing.dur,\n            cat: 'devtools.extension',\n            args: extensionPayload,\n            rawSourceEvent: Types.Events.isSyntheticUserTiming(timing) ? timing.rawSourceEvent : timing,\n        };\n        if (Types.Extensions.isExtensionPayloadMarker(extensionPayload)) {\n            const extensionMarker = Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n                .registerSyntheticEvent(extensionSyntheticEntry);\n            extensionMarkers.push(extensionMarker);\n            continue;\n        }\n        if (Types.Extensions.isExtensionPayloadTrackEntry(extensionSyntheticEntry.args)) {\n            const extensionTrackEntry = Helpers.SyntheticEvents.SyntheticEventsManager.getActiveManager()\n                .registerSyntheticEvent(extensionSyntheticEntry);\n            extensionFlameChartEntries.push(extensionTrackEntry);\n            continue;\n        }\n    }\n}\nexport function extensionDataInTiming(timing) {\n    const timingDetail = Types.Events.isPerformanceMark(timing) ? timing.args.data?.detail : timing.args.data.beginEvent.args.detail;\n    if (!timingDetail) {\n        return null;\n    }\n    try {\n        // Attempt to parse the detail as an object that might be coming from a\n        // DevTools Perf extension.\n        // Wrapped in a try-catch because timingDetail might either:\n        // 1. Not be `json.parse`-able (it should, but just in case...)\n        // 2.Not be an object - in which case the `in` check will error.\n        // If we hit either of these cases, we just ignore this mark and move on.\n        const detailObj = JSON.parse(timingDetail);\n        if (!('devtools' in detailObj)) {\n            return null;\n        }\n        if (!Types.Extensions.isValidExtensionPayload(detailObj.devtools)) {\n            return null;\n        }\n        return detailObj.devtools;\n    }\n    catch (e) {\n        // No need to worry about this error, just discard this event and don't\n        // treat it as having any useful information for the purposes of extensions\n        return null;\n    }\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('ExtensionTraceData handler is not finalized');\n    }\n    return {\n        entryToNode,\n        extensionTrackData: [...extensionTrackData],\n        extensionMarkers: [...extensionMarkers],\n    };\n}\nexport function deps() {\n    return ['UserTimings'];\n}\n//# sourceMappingURL=ExtensionTraceDataHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nconst paintEvents = [];\nconst snapshotEvents = [];\nconst paintToSnapshotMap = new Map();\nlet lastPaintForLayerId = {};\nlet currentMainFrameLayerTreeId = null;\nconst updateLayerEvents = [];\nconst relevantEvents = [];\nexport function reset() {\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n    paintEvents.length = 0;\n    snapshotEvents.length = 0;\n    paintToSnapshotMap.clear();\n    lastPaintForLayerId = {};\n    currentMainFrameLayerTreeId = null;\n    updateLayerEvents.length = 0;\n    relevantEvents.length = 0;\n}\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('LayerTree Handler was not reset before being initialized');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(event) {\n    // We gather up the events here but do all the processing in finalize(). This\n    // is because we need to have all the events before we process them, and we\n    // need the Meta handler to be finalized() so we can use its data as we need\n    // the mainFrameId to know which Layer(s) to care about.\n    if (Types.Events.isPaint(event) || Types.Events.isDisplayListItemListSnapshot(event) ||\n        Types.Events.isUpdateLayer(event) || Types.Events.isSetLayerId(event)) {\n        relevantEvents.push(event);\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('LayerTree Handler is not initialized');\n    }\n    const metaData = metaHandlerData();\n    Helpers.Trace.sortTraceEventsInPlace(relevantEvents);\n    for (const event of relevantEvents) {\n        if (Types.Events.isSetLayerId(event)) {\n            if (metaData.mainFrameId !== event.args.data.frame) {\n                // We only care about LayerId changes that affect the main frame.\n                continue;\n            }\n            currentMainFrameLayerTreeId = event.args.data.layerTreeId;\n        }\n        else if (Types.Events.isUpdateLayer(event)) {\n            // We don't do anything with this event, but we need to store it because\n            // the information in it determines if we need to care about future\n            // snapshot events - we need to know what the active layer is when we see a\n            // snapshot.\n            updateLayerEvents.push(event);\n        }\n        else if (Types.Events.isPaint(event)) {\n            if (!event.args.data.layerId) {\n                // Note that this check purposefully includes excluding an event with a layerId of 0.\n                // 0 indicates that this paint was for a subframe - we do not want these\n                // as we only care about paints for top level frames.\n                continue;\n            }\n            paintEvents.push(event);\n            lastPaintForLayerId[event.args.data.layerId] = event;\n            continue;\n        }\n        else if (Types.Events.isDisplayListItemListSnapshot(event)) {\n            // First we figure out which layer is active for this event's thread. To\n            // do this we work backwards through the list of UpdateLayerEvents,\n            // finding the first one (i.e. the most recent one) with the same pid and\n            // tid.\n            let lastUpdateLayerEventForThread = null;\n            for (let i = updateLayerEvents.length - 1; i > -1; i--) {\n                const updateEvent = updateLayerEvents[i];\n                if (updateEvent.pid === event.pid && updateEvent.tid === event.tid) {\n                    lastUpdateLayerEventForThread = updateEvent;\n                    break;\n                }\n            }\n            if (!lastUpdateLayerEventForThread) {\n                // No active layer, so this snapshot is not relevant.\n                continue;\n            }\n            if (lastUpdateLayerEventForThread.args.layerTreeId !== currentMainFrameLayerTreeId) {\n                // Snapshot applies to a layer that is not the main frame, so discard.\n                continue;\n            }\n            const paintEvent = lastPaintForLayerId[lastUpdateLayerEventForThread.args.layerId];\n            if (!paintEvent) {\n                // No paint event for this layer, so discard.\n                continue;\n            }\n            snapshotEvents.push(event);\n            // Store the relationship between the paint and the snapshot.\n            paintToSnapshotMap.set(paintEvent, event);\n        }\n    }\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    return {\n        paints: paintEvents,\n        snapshots: snapshotEvents,\n        paintsToSnapshots: paintToSnapshotMap,\n    };\n}\nexport function deps() {\n    return ['Meta'];\n}\n//# sourceMappingURL=LayerTreeHandler.js.map","function getThreadTypeForRendererThread(pid, thread, auctionWorkletsData) {\n    let threadType = \"OTHER\" /* ThreadType.OTHER */;\n    if (thread.name === 'CrRendererMain') {\n        threadType = \"MAIN_THREAD\" /* ThreadType.MAIN_THREAD */;\n    }\n    else if (thread.name === 'DedicatedWorker thread') {\n        threadType = \"WORKER\" /* ThreadType.WORKER */;\n    }\n    else if (thread.name?.startsWith('CompositorTileWorker')) {\n        threadType = \"RASTERIZER\" /* ThreadType.RASTERIZER */;\n    }\n    else if (auctionWorkletsData.worklets.has(pid)) {\n        threadType = \"AUCTION_WORKLET\" /* ThreadType.AUCTION_WORKLET */;\n    }\n    else if (thread.name?.startsWith('ThreadPool')) {\n        // TODO(paulirish): perhaps exclude ThreadPoolServiceThread entirely\n        threadType = \"THREAD_POOL\" /* ThreadType.THREAD_POOL */;\n    }\n    return threadType;\n}\nexport function threadsInRenderer(rendererData, auctionWorkletsData) {\n    const foundThreads = [];\n    // If we have Renderer threads, we prefer to use those. In the event that a\n    // trace is a CPU Profile trace, we will never have Renderer threads, so we\n    // know if there are no Renderer threads that we can fallback to using the\n    // data from the SamplesHandler.\n    if (rendererData.processes.size) {\n        for (const [pid, process] of rendererData.processes) {\n            for (const [tid, thread] of process.threads) {\n                if (!thread.tree) {\n                    // Drop threads where we could not create the tree; this indicates\n                    // unexpected data and we won't be able to support all the UI\n                    // filtering we need.\n                    continue;\n                }\n                const threadType = getThreadTypeForRendererThread(pid, thread, auctionWorkletsData);\n                foundThreads.push({\n                    name: thread.name,\n                    pid,\n                    tid,\n                    processIsOnMainFrame: process.isOnMainFrame,\n                    entries: thread.entries,\n                    tree: thread.tree,\n                    type: threadType,\n                    entryToNode: rendererData.entryToNode,\n                });\n            }\n        }\n    }\n    return foundThreads;\n}\n/**\n * Given trace parsed data, this helper will return a high level array of\n * ThreadData. This is useful because it allows you to get a list of threads\n * regardless of if the trace is a CPU Profile or a Tracing profile. Thus you\n * can use this helper to iterate over threads in confidence that it will work\n * for both trace types.\n */\nexport function threadsInTrace(parsedTrace) {\n    // If we have Renderer threads, we prefer to use those. In the event that a\n    // trace is a CPU Profile trace, we will never have Renderer threads, so we\n    // know if there are no Renderer threads that we can fallback to using the\n    // data from the SamplesHandler.\n    const threadsFromRenderer = threadsInRenderer(parsedTrace.Renderer, parsedTrace.AuctionWorklets);\n    if (threadsFromRenderer.length) {\n        return threadsFromRenderer;\n    }\n    const foundThreads = [];\n    if (parsedTrace.Samples.profilesInProcess.size) {\n        for (const [pid, process] of parsedTrace.Samples.profilesInProcess) {\n            for (const [tid, thread] of process) {\n                if (!thread.profileTree) {\n                    // Drop threads where we could not create the tree; this indicates\n                    // unexpected data and we won't be able to support all the UI\n                    // filtering we need.\n                    continue;\n                }\n                foundThreads.push({\n                    pid,\n                    tid,\n                    // CPU Profile threads do not have a name.\n                    name: null,\n                    entries: thread.profileCalls,\n                    // There is no concept of a \"Main Frame\" in a CPU profile.\n                    processIsOnMainFrame: false,\n                    tree: thread.profileTree,\n                    type: \"CPU_PROFILE\" /* ThreadType.CPU_PROFILE */,\n                    entryToNode: parsedTrace.Samples.entryToNode,\n                });\n            }\n        }\n    }\n    return foundThreads;\n}\n//# sourceMappingURL=Threads.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as auctionWorkletsData } from './AuctionWorkletsHandler.js';\nimport { data as layerTreeHandlerData } from './LayerTreeHandler.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\nimport { data as rendererHandlerData } from './RendererHandler.js';\nimport * as Threads from './Threads.js';\n/**\n * IMPORTANT: this handler is slightly different to the rest. This is because\n * it is an adaptation of the TimelineFrameModel that has been used in DevTools\n * for many years. Rather than re-implement all the logic from scratch, instead\n * this handler gathers up the events and instantitates the class in the\n * finalize() method. Once the class has parsed all events, it is used to then\n * return the array of frames.\n *\n * In time we expect to migrate this code to a more \"typical\" handler.\n */\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nconst allEvents = [];\nlet model = null;\nexport function reset() {\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n    allEvents.length = 0;\n}\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('FramesHandler was not reset before being initialized');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(event) {\n    allEvents.push(event);\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('FramesHandler is not initialized');\n    }\n    // Snapshot events can be emitted out of order, so we need to sort before\n    // building the frames model.\n    Helpers.Trace.sortTraceEventsInPlace(allEvents);\n    const modelForTrace = new TimelineFrameModel(allEvents, rendererHandlerData(), auctionWorkletsData(), metaHandlerData(), layerTreeHandlerData());\n    model = modelForTrace;\n}\nexport function data() {\n    return {\n        frames: model ? Array.from(model.frames()) : [],\n        framesById: model ? { ...model.framesById() } : {},\n    };\n}\nexport function deps() {\n    return ['Meta', 'Renderer', 'AuctionWorklets', 'LayerTree'];\n}\nfunction isFrameEvent(event) {\n    return (Types.Events.isSetLayerId(event) || Types.Events.isBeginFrame(event) || Types.Events.isDroppedFrame(event) ||\n        Types.Events.isRequestMainThreadFrame(event) || Types.Events.isBeginMainThreadFrame(event) ||\n        Types.Events.isNeedsBeginFrameChanged(event) ||\n        // Note that \"Commit\" is the replacement for \"CompositeLayers\" so in a trace\n        // we wouldn't expect to see a combination of these. All \"new\" trace\n        // recordings use \"Commit\", but we can easily support \"CompositeLayers\" too\n        // to not break older traces being imported.\n        Types.Events.isCommit(event) || Types.Events.isCompositeLayers(event) ||\n        Types.Events.isActivateLayerTree(event) || Types.Events.isDrawFrame(event));\n}\nfunction entryIsTopLevel(entry) {\n    const devtoolsTimelineCategory = 'disabled-by-default-devtools.timeline';\n    return entry.name === \"RunTask\" /* Types.Events.Name.RUN_TASK */ && entry.cat.includes(devtoolsTimelineCategory);\n}\nexport class TimelineFrameModel {\n    #frames = [];\n    #frameById = {};\n    #beginFrameQueue = new TimelineFrameBeginFrameQueue();\n    #lastFrame = null;\n    #mainFrameCommitted = false;\n    #mainFrameRequested = false;\n    #lastLayerTree = null;\n    #framePendingActivation = null;\n    #framePendingCommit = null;\n    #lastBeginFrame = null;\n    #lastNeedsBeginFrame = null;\n    #lastTaskBeginTime = null;\n    #layerTreeId = null;\n    #activeProcessId = null;\n    #activeThreadId = null;\n    #layerTreeData;\n    constructor(allEvents, rendererData, auctionWorkletsData, metaData, layerTreeData) {\n        // We only care about getting threads from the Renderer, not Samples,\n        // because Frames don't exist in a CPU Profile (which won't have Renderer\n        // threads.)\n        const mainThreads = Threads.threadsInRenderer(rendererData, auctionWorkletsData).filter(thread => {\n            return thread.type === \"MAIN_THREAD\" /* Threads.ThreadType.MAIN_THREAD */ && thread.processIsOnMainFrame;\n        });\n        const threadData = mainThreads.map(thread => {\n            return {\n                tid: thread.tid,\n                pid: thread.pid,\n                startTime: thread.entries[0].ts,\n            };\n        });\n        this.#layerTreeData = layerTreeData;\n        this.#addTraceEvents(allEvents, threadData, metaData.mainFrameId);\n    }\n    framesById() {\n        return this.#frameById;\n    }\n    frames() {\n        return this.#frames;\n    }\n    #handleBeginFrame(startTime, seqId) {\n        if (!this.#lastFrame) {\n            this.#startFrame(startTime, seqId);\n        }\n        this.#lastBeginFrame = startTime;\n        this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);\n    }\n    #handleDroppedFrame(startTime, seqId, isPartial) {\n        if (!this.#lastFrame) {\n            this.#startFrame(startTime, seqId);\n        }\n        // This line handles the case where no BeginFrame event is issued for\n        // the dropped frame. In this situation, add a BeginFrame to the queue\n        // as if it actually occurred.\n        this.#beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);\n        this.#beginFrameQueue.setDropped(seqId, true);\n        this.#beginFrameQueue.setPartial(seqId, isPartial);\n    }\n    #handleDrawFrame(startTime, seqId) {\n        if (!this.#lastFrame) {\n            this.#startFrame(startTime, seqId);\n            return;\n        }\n        // - if it wasn't drawn, it didn't happen!\n        // - only show frames that either did not wait for the main thread frame or had one committed.\n        if (this.#mainFrameCommitted || !this.#mainFrameRequested) {\n            if (this.#lastNeedsBeginFrame) {\n                const idleTimeEnd = this.#framePendingActivation ? this.#framePendingActivation.triggerTime :\n                    (this.#lastBeginFrame || this.#lastNeedsBeginFrame);\n                if (idleTimeEnd > this.#lastFrame.startTime) {\n                    this.#lastFrame.idle = true;\n                    this.#lastBeginFrame = null;\n                }\n                this.#lastNeedsBeginFrame = null;\n            }\n            const framesToVisualize = this.#beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);\n            // Visualize the current frame and all pending frames before it.\n            for (const frame of framesToVisualize) {\n                const isLastFrameIdle = this.#lastFrame.idle;\n                // If |frame| is the first frame after an idle period, the CPU time\n                // will be logged (\"committed\") under |frame| if applicable.\n                this.#startFrame(frame.startTime, seqId);\n                if (isLastFrameIdle && this.#framePendingActivation) {\n                    this.#commitPendingFrame();\n                }\n                if (frame.isDropped) {\n                    this.#lastFrame.dropped = true;\n                }\n                if (frame.isPartial) {\n                    this.#lastFrame.isPartial = true;\n                }\n            }\n        }\n        this.#mainFrameCommitted = false;\n    }\n    #handleActivateLayerTree() {\n        if (!this.#lastFrame) {\n            return;\n        }\n        if (this.#framePendingActivation && !this.#lastNeedsBeginFrame) {\n            this.#commitPendingFrame();\n        }\n    }\n    #handleRequestMainThreadFrame() {\n        if (!this.#lastFrame) {\n            return;\n        }\n        this.#mainFrameRequested = true;\n    }\n    #handleCommit() {\n        if (!this.#framePendingCommit) {\n            return;\n        }\n        this.#framePendingActivation = this.#framePendingCommit;\n        this.#framePendingCommit = null;\n        this.#mainFrameRequested = false;\n        this.#mainFrameCommitted = true;\n    }\n    #handleLayerTreeSnapshot(layerTree) {\n        this.#lastLayerTree = layerTree;\n    }\n    #handleNeedFrameChanged(startTime, needsBeginFrame) {\n        if (needsBeginFrame) {\n            this.#lastNeedsBeginFrame = startTime;\n        }\n    }\n    #startFrame(startTime, seqId) {\n        if (this.#lastFrame) {\n            this.#flushFrame(this.#lastFrame, startTime);\n        }\n        this.#lastFrame =\n            new TimelineFrame(seqId, startTime, Types.Timing.MicroSeconds(startTime - metaHandlerData().traceBounds.min));\n    }\n    #flushFrame(frame, endTime) {\n        frame.setLayerTree(this.#lastLayerTree);\n        frame.setEndTime(endTime);\n        if (this.#lastLayerTree) {\n            this.#lastLayerTree.paints = frame.paints;\n        }\n        const lastFrame = this.#frames[this.#frames.length - 1];\n        if (this.#frames.length && lastFrame &&\n            (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {\n            console.assert(false, `Inconsistent frame time for frame ${this.#frames.length} (${frame.startTime} - ${frame.endTime})`);\n        }\n        const newFramesLength = this.#frames.push(frame);\n        frame.setIndex(newFramesLength - 1);\n        if (typeof frame.mainFrameId === 'number') {\n            this.#frameById[frame.mainFrameId] = frame;\n        }\n    }\n    #commitPendingFrame() {\n        if (!this.#framePendingActivation || !this.#lastFrame) {\n            return;\n        }\n        this.#lastFrame.paints = this.#framePendingActivation.paints;\n        this.#lastFrame.mainFrameId = this.#framePendingActivation.mainFrameId;\n        this.#framePendingActivation = null;\n    }\n    #addTraceEvents(events, threadData, mainFrameId) {\n        let j = 0;\n        this.#activeThreadId = threadData.length && threadData[0].tid || null;\n        this.#activeProcessId = threadData.length && threadData[0].pid || null;\n        for (let i = 0; i < events.length; ++i) {\n            while (j + 1 < threadData.length && threadData[j + 1].startTime <= events[i].ts) {\n                this.#activeThreadId = threadData[++j].tid;\n                this.#activeProcessId = threadData[j].pid;\n            }\n            this.#addTraceEvent(events[i], mainFrameId);\n        }\n        this.#activeThreadId = null;\n        this.#activeProcessId = null;\n    }\n    #addTraceEvent(event, mainFrameId) {\n        if (Types.Events.isSetLayerId(event) && event.args.data.frame === mainFrameId) {\n            this.#layerTreeId = event.args.data.layerTreeId;\n        }\n        else if (Types.Events.isLayerTreeHostImplSnapshot(event) && Number(event.id) === this.#layerTreeId) {\n            this.#handleLayerTreeSnapshot({\n                entry: event,\n                paints: [],\n            });\n        }\n        else {\n            if (isFrameEvent(event)) {\n                this.#processCompositorEvents(event);\n            }\n            // Make sure we only use events from the main thread: we check the PID as\n            // well in case two processes have a thread with the same TID.\n            if (event.tid === this.#activeThreadId && event.pid === this.#activeProcessId) {\n                this.#addMainThreadTraceEvent(event);\n            }\n        }\n    }\n    #processCompositorEvents(entry) {\n        if (entry.args['layerTreeId'] !== this.#layerTreeId) {\n            return;\n        }\n        if (Types.Events.isBeginFrame(entry)) {\n            this.#handleBeginFrame(entry.ts, entry.args['frameSeqId']);\n        }\n        else if (Types.Events.isDrawFrame(entry)) {\n            this.#handleDrawFrame(entry.ts, entry.args['frameSeqId']);\n        }\n        else if (Types.Events.isActivateLayerTree(entry)) {\n            this.#handleActivateLayerTree();\n        }\n        else if (Types.Events.isRequestMainThreadFrame(entry)) {\n            this.#handleRequestMainThreadFrame();\n        }\n        else if (Types.Events.isNeedsBeginFrameChanged(entry)) {\n            // needsBeginFrame property will either be 0 or 1, which represents\n            // true/false in this case, hence the Boolean() wrapper.\n            this.#handleNeedFrameChanged(entry.ts, entry.args['data'] && Boolean(entry.args['data']['needsBeginFrame']));\n        }\n        else if (Types.Events.isDroppedFrame(entry)) {\n            this.#handleDroppedFrame(entry.ts, entry.args['frameSeqId'], Boolean(entry.args['hasPartialUpdate']));\n        }\n    }\n    #addMainThreadTraceEvent(entry) {\n        if (entryIsTopLevel(entry)) {\n            this.#lastTaskBeginTime = entry.ts;\n        }\n        if (!this.#framePendingCommit && MAIN_FRAME_MARKERS.has(entry.name)) {\n            this.#framePendingCommit = new PendingFrame(this.#lastTaskBeginTime || entry.ts);\n        }\n        if (!this.#framePendingCommit) {\n            return;\n        }\n        if (Types.Events.isBeginMainThreadFrame(entry) && entry.args.data.frameId) {\n            this.#framePendingCommit.mainFrameId = entry.args.data.frameId;\n        }\n        if (Types.Events.isPaint(entry)) {\n            const snapshot = this.#layerTreeData.paintsToSnapshots.get(entry);\n            if (snapshot) {\n                this.#framePendingCommit.paints.push(new LayerPaintEvent(entry, snapshot));\n            }\n        }\n        // Commit will be replacing CompositeLayers but CompositeLayers is kept\n        // around for backwards compatibility.\n        if ((Types.Events.isCompositeLayers(entry) || Types.Events.isCommit(entry)) &&\n            entry.args['layerTreeId'] === this.#layerTreeId) {\n            this.#handleCommit();\n        }\n    }\n}\nconst MAIN_FRAME_MARKERS = new Set([\n    \"ScheduleStyleRecalculation\" /* Types.Events.Name.SCHEDULE_STYLE_RECALCULATION */,\n    \"InvalidateLayout\" /* Types.Events.Name.INVALIDATE_LAYOUT */,\n    \"BeginMainThreadFrame\" /* Types.Events.Name.BEGIN_MAIN_THREAD_FRAME */,\n    \"ScrollLayer\" /* Types.Events.Name.SCROLL_LAYER */,\n]);\nexport class TimelineFrame {\n    // These fields exist to satisfy the base Event type which all\n    // \"trace events\" must implement. They aren't used, but doing this means we\n    // can pass `TimelineFrame` instances into places that expect\n    // Types.Events.Event.\n    cat = 'devtools.legacy_frame';\n    name = 'frame';\n    ph = \"X\" /* Types.Events.Phase.COMPLETE */;\n    ts;\n    pid = Types.Events.ProcessID(-1);\n    tid = Types.Events.ThreadID(-1);\n    index = -1;\n    startTime;\n    startTimeOffset;\n    endTime;\n    duration;\n    idle;\n    dropped;\n    isPartial;\n    layerTree;\n    paints;\n    mainFrameId;\n    seqId;\n    constructor(seqId, startTime, startTimeOffset) {\n        this.seqId = seqId;\n        this.startTime = startTime;\n        this.ts = startTime;\n        this.startTimeOffset = startTimeOffset;\n        this.endTime = this.startTime;\n        this.duration = Types.Timing.MicroSeconds(0);\n        this.idle = false;\n        this.dropped = false;\n        this.isPartial = false;\n        this.layerTree = null;\n        this.paints = [];\n        this.mainFrameId = undefined;\n    }\n    setIndex(i) {\n        this.index = i;\n    }\n    setEndTime(endTime) {\n        this.endTime = endTime;\n        this.duration = Types.Timing.MicroSeconds(this.endTime - this.startTime);\n    }\n    setLayerTree(layerTree) {\n        this.layerTree = layerTree;\n    }\n    /**\n     * Fake the `dur` field to meet the expected value given that we pretend\n     * these TimelineFrame classes are trace events across the codebase.\n     */\n    get dur() {\n        return this.duration;\n    }\n}\nexport class LayerPaintEvent {\n    #event;\n    #snapshot;\n    constructor(event, snapshot) {\n        this.#event = event;\n        this.#snapshot = snapshot;\n    }\n    layerId() {\n        return this.#event.args.data.layerId;\n    }\n    event() {\n        return this.#event;\n    }\n    picture() {\n        const rect = this.#snapshot.args.snapshot.params?.layer_rect;\n        const pictureData = this.#snapshot.args.snapshot.skp64;\n        return rect && pictureData ? { rect, serializedPicture: pictureData } : null;\n    }\n}\nexport class PendingFrame {\n    paints;\n    mainFrameId;\n    triggerTime;\n    constructor(triggerTime) {\n        this.paints = [];\n        this.mainFrameId = undefined;\n        this.triggerTime = triggerTime;\n    }\n}\n// The parameters of an impl-side BeginFrame.\nclass BeginFrameInfo {\n    seqId;\n    startTime;\n    isDropped;\n    isPartial;\n    constructor(seqId, startTime, isDropped, isPartial) {\n        this.seqId = seqId;\n        this.startTime = startTime;\n        this.isDropped = isDropped;\n        this.isPartial = isPartial;\n    }\n}\n// A queue of BeginFrames pending visualization.\n// BeginFrames are added into this queue as they occur; later when their\n// corresponding DrawFrames occur (or lack thereof), the BeginFrames are removed\n// from the queue and their timestamps are used for visualization.\nexport class TimelineFrameBeginFrameQueue {\n    queueFrames = [];\n    // Maps frameSeqId to BeginFrameInfo.\n    mapFrames = {};\n    // Add a BeginFrame to the queue, if it does not already exit.\n    addFrameIfNotExists(seqId, startTime, isDropped, isPartial) {\n        if (!(seqId in this.mapFrames)) {\n            this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);\n            this.queueFrames.push(seqId);\n        }\n    }\n    // Set a BeginFrame in queue as dropped.\n    setDropped(seqId, isDropped) {\n        if (seqId in this.mapFrames) {\n            this.mapFrames[seqId].isDropped = isDropped;\n        }\n    }\n    setPartial(seqId, isPartial) {\n        if (seqId in this.mapFrames) {\n            this.mapFrames[seqId].isPartial = isPartial;\n        }\n    }\n    processPendingBeginFramesOnDrawFrame(seqId) {\n        const framesToVisualize = [];\n        // Do not visualize this frame in the rare case where the current DrawFrame\n        // does not have a corresponding BeginFrame.\n        if (seqId in this.mapFrames) {\n            // Pop all BeginFrames before the current frame, and add only the dropped\n            // ones in |frames_to_visualize|.\n            // Non-dropped frames popped here are BeginFrames that are never\n            // drawn (but not considered dropped either for some reason).\n            // Those frames do not require an proactive visualization effort and will\n            // be naturally presented as continuationss of other frames.\n            while (this.queueFrames[0] !== seqId) {\n                const currentSeqId = this.queueFrames[0];\n                if (this.mapFrames[currentSeqId].isDropped) {\n                    framesToVisualize.push(this.mapFrames[currentSeqId]);\n                }\n                delete this.mapFrames[currentSeqId];\n                this.queueFrames.shift();\n            }\n            // Pop the BeginFrame associated with the current DrawFrame.\n            framesToVisualize.push(this.mapFrames[seqId]);\n            delete this.mapFrames[seqId];\n            this.queueFrames.shift();\n        }\n        return framesToVisualize;\n    }\n}\nexport function framesWithinWindow(frames, startTime, endTime) {\n    const firstFrame = Platform.ArrayUtilities.lowerBound(frames, startTime || 0, (time, frame) => time - frame.endTime);\n    const lastFrame = Platform.ArrayUtilities.lowerBound(frames, endTime || Infinity, (time, frame) => time - frame.startTime);\n    return frames.slice(firstFrame, lastFrame);\n}\n//# sourceMappingURL=FramesHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nconst eventsInProcessThread = new Map();\nlet mainGPUThreadTasks = [];\nexport function reset() {\n    eventsInProcessThread.clear();\n    mainGPUThreadTasks = [];\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n}\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('GPU Handler was not reset before being initialized');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('GPU Handler is not initialized');\n    }\n    if (!Types.Events.isGPUTask(event)) {\n        return;\n    }\n    Helpers.Trace.addEventToProcessThread(event, eventsInProcessThread);\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('GPU Handler is not initialized');\n    }\n    const { gpuProcessId, gpuThreadId } = metaHandlerData();\n    const gpuThreadsForProcess = eventsInProcessThread.get(gpuProcessId);\n    if (gpuThreadsForProcess && gpuThreadId) {\n        mainGPUThreadTasks = gpuThreadsForProcess.get(gpuThreadId) || [];\n    }\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('GPU Handler is not finalized');\n    }\n    return {\n        mainGPUThreadTasks,\n    };\n}\nexport function deps() {\n    return ['Meta'];\n}\n//# sourceMappingURL=GPUHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n/**\n * This handler is responsible for the relationships between:\n * DecodeImage/ResizeImage, PaintImage and DrawLazyPixelRef events.\n *\n * When we get a DecodeImage event, we want to associate it to a PaintImage\n * event, primarily so we can determine the NodeID of the image that was\n * decoded.\n * We can do this in two ways:\n *\n * 1. If there is a PaintImage event on the same thread, use that\n *    (if there are multiple, use the latest one).\n *\n * 2. If not, we can find the DecodeLazyPixelRef event on the same thread, and\n *    use the PaintImage event associated with it via the `LazyPixelRef` key.\n */\n// Track paintImageEvents across threads.\nconst paintImageEvents = new Map();\nconst decodeLazyPixelRefEvents = new Map();\n// A DrawLazyPixelRef event will contain a numerical reference in\n// args.LazyPixelRef. As we parse each DrawLazyPixelRef, we can assign it to a\n// paint event. Later we want to look up paint events by this reference, so we\n// store them in this map.\nconst paintImageByLazyPixelRef = new Map();\n// When we find events that we want to tie to a particular PaintImage event, we add them to this map.\n// These are currently only DecodeImage and ResizeImage events, but the type is\n// deliberately generic as in the future we might want to add more events that\n// have a relationship to a individual PaintImage event.\nconst eventToPaintImage = new Map();\nexport function reset() {\n    paintImageEvents.clear();\n    decodeLazyPixelRefEvents.clear();\n    paintImageByLazyPixelRef.clear();\n    eventToPaintImage.clear();\n}\nexport function handleEvent(event) {\n    if (Types.Events.isPaintImage(event)) {\n        const forProcess = paintImageEvents.get(event.pid) || new Map();\n        const forThread = forProcess.get(event.tid) || [];\n        forThread.push(event);\n        forProcess.set(event.tid, forThread);\n        paintImageEvents.set(event.pid, forProcess);\n        return;\n    }\n    if (Types.Events.isDecodeLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n        // Store these because we use them to tie DecodeImage to a PaintEvent.\n        const forProcess = decodeLazyPixelRefEvents.get(event.pid) || new Map();\n        const forThread = forProcess.get(event.tid) || [];\n        forThread.push(event);\n        forProcess.set(event.tid, forThread);\n        decodeLazyPixelRefEvents.set(event.pid, forProcess);\n    }\n    // If we see a DrawLazyPixelRef event, we need to find the last PaintImage\n    // event on the thread and associate it to the LazyPixelRef that is supplied\n    // in the DrawLazyPixelRef event.\n    // This means that later on if we see a DecodeLazyPixelRef event with the\n    // same LazyPixelRef key, we can find its associated PaintImage event by\n    // looking it up.\n    if (Types.Events.isDrawLazyPixelRef(event) && typeof event.args?.LazyPixelRef !== 'undefined') {\n        const lastPaintEvent = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n        if (!lastPaintEvent) {\n            return;\n        }\n        paintImageByLazyPixelRef.set(event.args.LazyPixelRef, lastPaintEvent);\n        return;\n    }\n    if (Types.Events.isDecodeImage(event)) {\n        // When we see a DecodeImage, we want to associate it to a PaintImage\n        // event. We try two approaches:\n        //\n        // 1. If the thread of the DecodeImage event has a previous PaintImage\n        // event, that is the associated event.\n        //\n        // 2. If that is false, we then look on the thread for a DecodeLazyPixelRef\n        // event. If we find that, we then look for its associated PaintImage\n        // event, which we associate via DrawLazyPixelRef events (the code block\n        // above this one)\n        //\n        // 1. Find a PaintImage event on the same thread. If we find it, that's our association done.\n        const lastPaintImageEventOnThread = paintImageEvents.get(event.pid)?.get(event.tid)?.at(-1);\n        if (lastPaintImageEventOnThread) {\n            eventToPaintImage.set(event, lastPaintImageEventOnThread);\n            return;\n        }\n        // 2. Find the last DecodeLazyPixelRef event and, if we find it, find its associated PaintImage event.\n        const lastDecodeLazyPixelRef = decodeLazyPixelRefEvents.get(event.pid)?.get(event.tid)?.at(-1);\n        if (!lastDecodeLazyPixelRef || typeof lastDecodeLazyPixelRef.args?.LazyPixelRef === 'undefined') {\n            return;\n        }\n        const paintEvent = paintImageByLazyPixelRef.get(lastDecodeLazyPixelRef.args.LazyPixelRef);\n        if (!paintEvent) {\n            return;\n        }\n        eventToPaintImage.set(event, paintEvent);\n    }\n}\nexport function data() {\n    return {\n        paintImageByDrawLazyPixelRef: paintImageByLazyPixelRef,\n        paintImageForEvent: eventToPaintImage,\n    };\n}\n//# sourceMappingURL=ImagePaintingHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nconst lastScheduleStyleRecalcByFrame = new Map();\n// This tracks the last event that is considered to have invalidated the layout\n// for a given frame.\n// Note that although there is an InvalidateLayout event, there are also other\n// events (ScheduleStyleRecalculation) that could be the reason a layout was\n// invalidated.\nconst lastInvalidationEventForFrame = new Map();\n// Important: although the event is called UpdateLayoutTree, in the UI we\n// present these to the user as \"Recalculate Style\". So don't get confused!\n// These are the same - just UpdateLayoutTree is what the event from Chromium\n// is called.\nconst lastUpdateLayoutTreeByFrame = new Map();\n// This tracks postmessage dispatch and handler events for creating initiator association\nconst postMessageHandlerEvents = [];\nconst schedulePostMessageEventByTraceId = new Map();\n// These two maps store the same data but in different directions.\n// For a given event, tell me what its initiator was. An event can only have one initiator.\nconst eventToInitiatorMap = new Map();\n// For a given event, tell me what events it initiated. An event can initiate\n// multiple events, hence why the value for this map is an array.\nconst initiatorToEventsMap = new Map();\nconst requestAnimationFrameEventsById = new Map();\nconst timerInstallEventsById = new Map();\nconst requestIdleCallbackEventsById = new Map();\nconst webSocketCreateEventsById = new Map();\nexport function reset() {\n    lastScheduleStyleRecalcByFrame.clear();\n    lastInvalidationEventForFrame.clear();\n    lastUpdateLayoutTreeByFrame.clear();\n    timerInstallEventsById.clear();\n    eventToInitiatorMap.clear();\n    initiatorToEventsMap.clear();\n    requestAnimationFrameEventsById.clear();\n    requestIdleCallbackEventsById.clear();\n    webSocketCreateEventsById.clear();\n    schedulePostMessageEventByTraceId.clear();\n    postMessageHandlerEvents.length = 0;\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n}\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('InitiatorsHandler was not reset before being initialized');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nfunction storeInitiator(data) {\n    eventToInitiatorMap.set(data.event, data.initiator);\n    const eventsForInitiator = initiatorToEventsMap.get(data.initiator) || [];\n    eventsForInitiator.push(data.event);\n    initiatorToEventsMap.set(data.initiator, eventsForInitiator);\n}\nexport function handleEvent(event) {\n    if (Types.Events.isScheduleStyleRecalculation(event)) {\n        lastScheduleStyleRecalcByFrame.set(event.args.data.frame, event);\n    }\n    else if (Types.Events.isUpdateLayoutTree(event)) {\n        // IMPORTANT: although the trace event is called UpdateLayoutTree, this\n        // represents a Styles Recalculation. This event in the timeline is shown to\n        // the user as \"Recalculate Styles.\"\n        if (event.args.beginData) {\n            // Store the last UpdateLayout event: we use this when we see an\n            // InvalidateLayout and try to figure out its initiator.\n            lastUpdateLayoutTreeByFrame.set(event.args.beginData.frame, event);\n            // If this frame has seen a ScheduleStyleRecalc event, then that event is\n            // considered to be the initiator of this StylesRecalc.\n            const scheduledStyleForFrame = lastScheduleStyleRecalcByFrame.get(event.args.beginData.frame);\n            if (scheduledStyleForFrame) {\n                storeInitiator({\n                    event,\n                    initiator: scheduledStyleForFrame,\n                });\n            }\n        }\n    }\n    else if (Types.Events.isInvalidateLayout(event)) {\n        // By default, the InvalidateLayout event is what triggered the layout invalidation for this frame.\n        let invalidationInitiator = event;\n        // However, if we have not had any prior invalidations for this frame, we\n        // want to consider StyleRecalculation events as they might be the actual\n        // cause of this layout invalidation.\n        if (!lastInvalidationEventForFrame.has(event.args.data.frame)) {\n            // 1. If we have not had an invalidation event for this frame\n            // 2. AND we have had an UpdateLayoutTree for this frame\n            // 3. AND the UpdateLayoutTree event ended AFTER the InvalidateLayout startTime\n            // 4. AND we have an initiator for the UpdateLayoutTree event\n            // 5. Then we set the last invalidation event for this frame to be the UpdateLayoutTree's initiator.\n            const lastUpdateLayoutTreeForFrame = lastUpdateLayoutTreeByFrame.get(event.args.data.frame);\n            if (lastUpdateLayoutTreeForFrame) {\n                const { endTime } = Helpers.Timing.eventTimingsMicroSeconds(lastUpdateLayoutTreeForFrame);\n                const initiatorOfUpdateLayout = eventToInitiatorMap.get(lastUpdateLayoutTreeForFrame);\n                if (initiatorOfUpdateLayout && endTime && endTime > event.ts) {\n                    invalidationInitiator = initiatorOfUpdateLayout;\n                }\n            }\n        }\n        lastInvalidationEventForFrame.set(event.args.data.frame, invalidationInitiator);\n    }\n    else if (Types.Events.isLayout(event)) {\n        // The initiator of a Layout event is the last Invalidation event.\n        const lastInvalidation = lastInvalidationEventForFrame.get(event.args.beginData.frame);\n        if (lastInvalidation) {\n            storeInitiator({\n                event,\n                initiator: lastInvalidation,\n            });\n        }\n        // Now clear the last invalidation for the frame: the last invalidation has been linked to a Layout event, so it cannot be the initiator for any future layouts.\n        lastInvalidationEventForFrame.delete(event.args.beginData.frame);\n    }\n    else if (Types.Events.isRequestAnimationFrame(event)) {\n        requestAnimationFrameEventsById.set(event.args.data.id, event);\n    }\n    else if (Types.Events.isFireAnimationFrame(event)) {\n        // If we get a fire event, that means we should have had the\n        // RequestAnimationFrame event by now. If so, we can set that as the\n        // initiator for the fire event.\n        const matchingRequestEvent = requestAnimationFrameEventsById.get(event.args.data.id);\n        if (matchingRequestEvent) {\n            storeInitiator({\n                event,\n                initiator: matchingRequestEvent,\n            });\n        }\n    }\n    else if (Types.Events.isTimerInstall(event)) {\n        timerInstallEventsById.set(event.args.data.timerId, event);\n    }\n    else if (Types.Events.isTimerFire(event)) {\n        const matchingInstall = timerInstallEventsById.get(event.args.data.timerId);\n        if (matchingInstall) {\n            storeInitiator({ event, initiator: matchingInstall });\n        }\n    }\n    else if (Types.Events.isRequestIdleCallback(event)) {\n        requestIdleCallbackEventsById.set(event.args.data.id, event);\n    }\n    else if (Types.Events.isFireIdleCallback(event)) {\n        const matchingRequestEvent = requestIdleCallbackEventsById.get(event.args.data.id);\n        if (matchingRequestEvent) {\n            storeInitiator({\n                event,\n                initiator: matchingRequestEvent,\n            });\n        }\n    }\n    else if (Types.Events.isWebSocketCreate(event)) {\n        webSocketCreateEventsById.set(event.args.data.identifier, event);\n    }\n    else if (Types.Events.isWebSocketInfo(event) || Types.Events.isWebSocketTransfer(event)) {\n        const matchingCreateEvent = webSocketCreateEventsById.get(event.args.data.identifier);\n        if (matchingCreateEvent) {\n            storeInitiator({\n                event,\n                initiator: matchingCreateEvent,\n            });\n        }\n    }\n    // Store schedulePostMessage Events by their traceIds.\n    // so they can be reconciled later with matching handlePostMessage events with same traceIds.\n    else if (Types.Events.isHandlePostMessage(event)) {\n        postMessageHandlerEvents.push(event);\n    }\n    else if (Types.Events.isSchedulePostMessage(event)) {\n        const traceId = event.args.data?.traceId;\n        if (traceId) {\n            schedulePostMessageEventByTraceId.set(traceId, event);\n        }\n    }\n}\nfunction finalizeInitiatorRelationship() {\n    for (const handlerEvent of postMessageHandlerEvents) {\n        const traceId = handlerEvent.args.data?.traceId;\n        const matchingSchedulePostMesssageEvent = schedulePostMessageEventByTraceId.get(traceId);\n        if (matchingSchedulePostMesssageEvent) {\n            // Set schedulePostMesssage events as initiators for handler events.\n            storeInitiator({ event: handlerEvent, initiator: matchingSchedulePostMesssageEvent });\n        }\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('InitiatorsHandler is not initialized');\n    }\n    // During event processing, we may encounter initiators before the handler events themselves\n    // (e.g dispatch events on worker and handler events on the main thread)\n    // we don't want to miss out on events whose initiators haven't been processed yet\n    finalizeInitiatorRelationship();\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    return {\n        eventToInitiator: eventToInitiatorMap,\n        initiatorToEvents: initiatorToEventsMap,\n    };\n}\n//# sourceMappingURL=InitiatorsHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nconst invalidationsForEvent = new Map();\nconst invalidationCountForEvent = new Map();\nlet lastRecalcStyleEvent = null;\n// Used to track paints so we track invalidations correctly per paint.\nlet hasPainted = false;\nconst allInvalidationTrackingEvents = [];\nexport function reset() {\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n    invalidationsForEvent.clear();\n    lastRecalcStyleEvent = null;\n    allInvalidationTrackingEvents.length = 0;\n    hasPainted = false;\n    maxInvalidationsPerEvent = null;\n}\nlet maxInvalidationsPerEvent = null;\nexport function handleUserConfig(userConfig) {\n    maxInvalidationsPerEvent = userConfig.maxInvalidationEventsPerEvent;\n}\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('InvalidationsHandler was not reset before being initialized');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nfunction addInvalidationToEvent(event, invalidation) {\n    const existingInvalidations = invalidationsForEvent.get(event) || [];\n    existingInvalidations.push(invalidation);\n    if (maxInvalidationsPerEvent !== null && existingInvalidations.length > maxInvalidationsPerEvent) {\n        existingInvalidations.shift();\n    }\n    invalidationsForEvent.set(event, existingInvalidations);\n    const count = invalidationCountForEvent.get(event) ?? 0;\n    invalidationCountForEvent.set(event, count + 1);\n}\nexport function handleEvent(event) {\n    // Special case: if we have been configured to not store any invalidations,\n    // we take that as a sign that we don't even want to gather any invalidations\n    // data at all and early exit.\n    if (maxInvalidationsPerEvent === 0) {\n        return;\n    }\n    if (Types.Events.isUpdateLayoutTree(event)) {\n        lastRecalcStyleEvent = event;\n        // Associate any prior invalidations with this recalc event.\n        for (const invalidation of allInvalidationTrackingEvents) {\n            if (Types.Events.isLayoutInvalidationTracking(invalidation)) {\n                // LayoutInvalidation events cannot be associated with a LayoutTree\n                // event.\n                continue;\n            }\n            const recalcFrameId = lastRecalcStyleEvent.args.beginData?.frame;\n            if (recalcFrameId && invalidation.args.data.frame === recalcFrameId) {\n                addInvalidationToEvent(event, invalidation);\n            }\n        }\n        return;\n    }\n    if (Types.Events.isInvalidationTracking(event)) {\n        if (hasPainted) {\n            // If we have painted, then we can clear out the list of all existing\n            // invalidations, as we cannot associate them across frames.\n            allInvalidationTrackingEvents.length = 0;\n            lastRecalcStyleEvent = null;\n            hasPainted = false;\n        }\n        // Style invalidation events can occur before and during recalc styles. When we get a recalc style event (aka UpdateLayoutTree), we check and associate any prior invalidations with it.\n        // But any invalidations that occur during a UpdateLayoutTree\n        // event would be reported in trace events after. So each time we get an\n        // invalidation that might be due to a style recalc, we check if the\n        // timings overlap and if so associate them.\n        if (lastRecalcStyleEvent &&\n            (Types.Events.isScheduleStyleInvalidationTracking(event) ||\n                Types.Events.isStyleRecalcInvalidationTracking(event) ||\n                Types.Events.isStyleInvalidatorInvalidationTracking(event))) {\n            const recalcEndTime = lastRecalcStyleEvent.ts + (lastRecalcStyleEvent.dur || 0);\n            if (event.ts >= lastRecalcStyleEvent.ts && event.ts <= recalcEndTime &&\n                lastRecalcStyleEvent.args.beginData?.frame === event.args.data.frame) {\n                addInvalidationToEvent(lastRecalcStyleEvent, event);\n            }\n        }\n        allInvalidationTrackingEvents.push(event);\n        return;\n    }\n    if (Types.Events.isPaint(event)) {\n        // Used to ensure that we do not create relationships across frames.\n        hasPainted = true;\n        return;\n    }\n    if (Types.Events.isLayout(event)) {\n        const layoutFrame = event.args.beginData.frame;\n        for (const invalidation of allInvalidationTrackingEvents) {\n            // The only invalidations that cause a Layout are LayoutInvalidations :)\n            if (!Types.Events.isLayoutInvalidationTracking(invalidation)) {\n                continue;\n            }\n            if (invalidation.args.data.frame === layoutFrame) {\n                addInvalidationToEvent(event, invalidation);\n            }\n        }\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('InvalidationsHandler is not initialized');\n    }\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    return {\n        invalidationsForEvent,\n        invalidationCountForEvent,\n    };\n}\n//# sourceMappingURL=InvalidationsHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n/**\n * If the LCP resource was an image, and that image was fetched over the\n * network, we want to be able to find the network request in order to construct\n * the critical path for an LCP image.\n * Within the trace file there are `LargestImagePaint::Candidate` events.\n * Within their data object, they contain a `DOMNodeId` property, which maps to\n * the DOM Node ID for that image.\n *\n * This id maps exactly to the `data.nodeId` property that a\n * `LargestContentfulPaint::Candidate` will have. So, when we find an image\n * paint candidate, we can store it, keying it on the node ID.\n * Then, when it comes to finding the network request for an LCP image, we can\n *\n * use the nodeId from the LCP candidate to find the image candidate. That image\n * candidate also contains a `imageUrl` property, which will have the full URL\n * to the image.\n **/\nconst imageByDOMNodeId = new Map();\nexport function reset() {\n    imageByDOMNodeId.clear();\n}\nexport function handleEvent(event) {\n    if (!Types.Events.isLargestImagePaintCandidate(event)) {\n        return;\n    }\n    if (!event.args.data) {\n        return;\n    }\n    imageByDOMNodeId.set(event.args.data.DOMNodeId, event);\n}\nexport function data() {\n    return imageByDOMNodeId;\n}\n//# sourceMappingURL=LargestImagePaintHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\n/**\n * A trace file will contain all the text paints that were candidates for the\n * LargestTextPaint. If an LCP event is text, it will point to one of these\n * candidates, so we store them by their DOM Node ID.\n **/\nconst textPaintByDOMNodeId = new Map();\nexport function reset() {\n    textPaintByDOMNodeId.clear();\n}\nexport function handleEvent(event) {\n    if (!Types.Events.isLargestTextPaintCandidate(event)) {\n        return;\n    }\n    if (!event.args.data) {\n        return;\n    }\n    textPaintByDOMNodeId.set(event.args.data.DOMNodeId, event);\n}\nexport function data() {\n    return textPaintByDOMNodeId;\n}\n//# sourceMappingURL=LargestTextPaintHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n// Each thread contains events. Events indicate the thread and process IDs, which are\n// used to store the event in the correct process thread entry below.\nconst unpairedAsyncEvents = [];\nconst snapshotEvents = [];\nconst syntheticScreenshots = [];\nlet frameSequenceToTs = {};\nexport function reset() {\n    unpairedAsyncEvents.length = 0;\n    snapshotEvents.length = 0;\n    syntheticScreenshots.length = 0;\n    frameSequenceToTs = {};\n}\nexport function handleEvent(event) {\n    if (Types.Events.isScreenshot(event)) {\n        snapshotEvents.push(event);\n    }\n    else if (Types.Events.isPipelineReporter(event)) {\n        unpairedAsyncEvents.push(event);\n    }\n}\nexport async function finalize() {\n    const pipelineReporterEvents = Helpers.Trace.createMatchedSortedSyntheticEvents(unpairedAsyncEvents);\n    frameSequenceToTs = Object.fromEntries(pipelineReporterEvents.map(evt => {\n        const frameSequenceId = evt.args.data.beginEvent.args.chrome_frame_reporter.frame_sequence;\n        const presentationTs = Types.Timing.MicroSeconds(evt.ts + evt.dur);\n        return [frameSequenceId, presentationTs];\n    }));\n    for (const snapshotEvent of snapshotEvents) {\n        const { cat, name, ph, pid, tid } = snapshotEvent;\n        const syntheticEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent({\n            rawSourceEvent: snapshotEvent,\n            cat,\n            name,\n            ph,\n            pid,\n            tid,\n            // TODO(paulirish, crbug.com/41363012): investigate why getPresentationTimestamp(snapshotEvent) seems less accurate. Resolve screenshot timing innaccuracy.\n            // `getPresentationTimestamp(snapshotEvent) - snapshotEvent.ts` is how many microsec the screenshot should be adjusted to the right/later\n            ts: snapshotEvent.ts,\n            args: {\n                dataUri: `data:image/jpg;base64,${snapshotEvent.args.snapshot}`,\n            },\n        });\n        syntheticScreenshots.push(syntheticEvent);\n    }\n}\n/**\n * Correct the screenshot timestamps\n * The screenshot 'snapshot object' trace event has the \"frame sequence number\" attached as an ID.\n * We match that up with the \"PipelineReporter\" trace events as they terminate at presentation.\n * Presentation == when the pixels hit the screen. AKA Swap on the GPU\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getPresentationTimestamp(screenshotEvent) {\n    const frameSequence = parseInt(screenshotEvent.id, 16);\n    // If it's 1, then it's an old trace (before https://crrev.com/c/4957973) and cannot be corrected.\n    if (frameSequence === 1) {\n        return screenshotEvent.ts;\n    }\n    // The screenshot trace event's `ts` reflects the \"expected display time\" which is ESTIMATE.\n    // It is set by the compositor frame sink from the `expected_display_time`, which is based on a previously known\n    // frame start PLUS the vsync interval (eg 16.6ms)\n    const updatedTs = frameSequenceToTs[frameSequence];\n    // Do we always find a match? No...\n    // We generally don't match the very first screenshot and, sometimes, the last\n    // The very first screenshot is requested immediately (even if nothing is painting). As a result there's no compositor\n    // instrumentation running alongside.\n    // The last one is sometimes missing as because the trace terminates right before the associated PipelineReporter is emitted.\n    return updatedTs ?? screenshotEvent.ts;\n}\n// TODO(crbug/41484172): should be readonly\nexport function data() {\n    return { all: syntheticScreenshots };\n}\nexport function deps() {\n    return ['Meta'];\n}\n//# sourceMappingURL=ScreenshotsHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\nimport { data as screenshotsHandlerData } from './ScreenshotsHandler.js';\n// This represents the maximum #time we will allow a cluster to go before we\n// reset it.\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(5000));\n// This represents the maximum #time we will allow between layout shift events\n// before considering it to be the start of a new cluster.\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(1000));\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nconst layoutShiftEvents = [];\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nconst layoutInvalidationEvents = [];\nconst scheduleStyleInvalidationEvents = [];\nconst styleRecalcInvalidationEvents = [];\nconst renderFrameImplCreateChildFrameEvents = [];\nconst domLoadingEvents = [];\nconst beginRemoteFontLoadEvents = [];\nconst backendNodeIds = new Set();\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nconst prePaintEvents = [];\nlet sessionMaxScore = 0;\nlet clsWindowID = -1;\nconst clusters = [];\nconst clustersByNavigationId = new Map();\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nconst scoreRecords = [];\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('LayoutShifts Handler was not reset');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function reset() {\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n    layoutShiftEvents.length = 0;\n    layoutInvalidationEvents.length = 0;\n    scheduleStyleInvalidationEvents.length = 0;\n    styleRecalcInvalidationEvents.length = 0;\n    prePaintEvents.length = 0;\n    renderFrameImplCreateChildFrameEvents.length = 0;\n    domLoadingEvents.length = 0;\n    beginRemoteFontLoadEvents.length = 0;\n    backendNodeIds.clear();\n    clusters.length = 0;\n    sessionMaxScore = 0;\n    scoreRecords.length = 0;\n    clsWindowID = -1;\n    clustersByNavigationId.clear();\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Handler is not initialized');\n    }\n    if (Types.Events.isLayoutShift(event) && !event.args.data?.had_recent_input) {\n        layoutShiftEvents.push(event);\n        return;\n    }\n    if (Types.Events.isLayoutInvalidationTracking(event)) {\n        layoutInvalidationEvents.push(event);\n        return;\n    }\n    if (Types.Events.isScheduleStyleInvalidationTracking(event)) {\n        scheduleStyleInvalidationEvents.push(event);\n    }\n    if (Types.Events.isStyleRecalcInvalidationTracking(event)) {\n        styleRecalcInvalidationEvents.push(event);\n    }\n    if (Types.Events.isPrePaint(event)) {\n        prePaintEvents.push(event);\n        return;\n    }\n    if (Types.Events.isRenderFrameImplCreateChildFrame(event)) {\n        renderFrameImplCreateChildFrameEvents.push(event);\n    }\n    if (Types.Events.isDomLoading(event)) {\n        domLoadingEvents.push(event);\n    }\n    if (Types.Events.isBeginRemoteFontLoad(event)) {\n        beginRemoteFontLoadEvents.push(event);\n    }\n}\nfunction traceWindowFromTime(time) {\n    return {\n        min: time,\n        max: time,\n        range: Types.Timing.MicroSeconds(0),\n    };\n}\nfunction updateTraceWindowMax(traceWindow, newMax) {\n    traceWindow.max = newMax;\n    traceWindow.range = Types.Timing.MicroSeconds(traceWindow.max - traceWindow.min);\n}\nfunction findScreenshots(timestamp) {\n    const screenshots = screenshotsHandlerData().all;\n    const before = Helpers.Trace.findPreviousEventBeforeTimestamp(screenshots, timestamp);\n    const after = before ? screenshots[screenshots.indexOf(before) + 1] : null;\n    return { before, after };\n}\nfunction buildScoreRecords() {\n    const { traceBounds } = metaHandlerData();\n    scoreRecords.push({ ts: traceBounds.min, score: 0 });\n    for (const cluster of clusters) {\n        let clusterScore = 0;\n        if (cluster.events[0].args.data) {\n            scoreRecords.push({ ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta });\n        }\n        for (let i = 0; i < cluster.events.length; i++) {\n            const event = cluster.events[i];\n            if (!event.args.data) {\n                continue;\n            }\n            clusterScore += event.args.data.weighted_score_delta;\n            scoreRecords.push({ ts: event.ts, score: clusterScore });\n        }\n        scoreRecords.push({ ts: cluster.clusterWindow.max, score: 0 });\n    }\n}\n/**\n * Collects backend node ids coming from LayoutShift and LayoutInvalidation\n * events.\n */\nfunction collectNodes() {\n    backendNodeIds.clear();\n    // Collect the node ids present in the shifts.\n    for (const layoutShift of layoutShiftEvents) {\n        if (!layoutShift.args.data?.impacted_nodes) {\n            continue;\n        }\n        for (const node of layoutShift.args.data.impacted_nodes) {\n            backendNodeIds.add(node.node_id);\n        }\n    }\n    // Collect the node ids present in LayoutInvalidation & scheduleStyleInvalidation events.\n    for (const layoutInvalidation of layoutInvalidationEvents) {\n        if (!layoutInvalidation.args.data?.nodeId) {\n            continue;\n        }\n        backendNodeIds.add(layoutInvalidation.args.data.nodeId);\n    }\n    for (const scheduleStyleInvalidation of scheduleStyleInvalidationEvents) {\n        if (!scheduleStyleInvalidation.args.data?.nodeId) {\n            continue;\n        }\n        backendNodeIds.add(scheduleStyleInvalidation.args.data.nodeId);\n    }\n}\nexport async function finalize() {\n    // Ensure the events are sorted by #time ascending.\n    layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n    prePaintEvents.sort((a, b) => a.ts - b.ts);\n    layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n    renderFrameImplCreateChildFrameEvents.sort((a, b) => a.ts - b.ts);\n    domLoadingEvents.sort((a, b) => a.ts - b.ts);\n    beginRemoteFontLoadEvents.sort((a, b) => a.ts - b.ts);\n    // Each function transforms the data used by the next, as such the invoke order\n    // is important.\n    await buildLayoutShiftsClusters();\n    buildScoreRecords();\n    collectNodes();\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nasync function buildLayoutShiftsClusters() {\n    const { navigationsByFrameId, mainFrameId, traceBounds } = metaHandlerData();\n    const navigations = navigationsByFrameId.get(mainFrameId) || [];\n    if (layoutShiftEvents.length === 0) {\n        return;\n    }\n    let firstShiftTime = layoutShiftEvents[0].ts;\n    let lastShiftTime = layoutShiftEvents[0].ts;\n    let lastShiftNavigation = null;\n    // Now step through each and create clusters.\n    // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n    // To make the line chart clear, we explicitly demark the limits of each session window\n    // by starting the cumulative score of the window at the time of the first layout shift\n    // and ending it (dropping the line back to 0) when the window ends according to the\n    // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n    for (const event of layoutShiftEvents) {\n        // First detect if either the cluster duration or the #time between this and\n        // the last shift has been exceeded.\n        const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n        const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n        // Next take a look at navigations. If between this and the last shift we have navigated,\n        // note it.\n        const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n        const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n        // If any of the above criteria are met or if we don't have any cluster yet we should\n        // start a new one.\n        if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n            // The cluster starts #time should be the timestamp of the first layout shift in it.\n            const clusterStartTime = event.ts;\n            // If the last session window ended because the max delta time between shifts\n            // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n            // last shift in the session.\n            const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n            // If the last session window ended because the max session duration was\n            // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n            const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n            // If there was a navigation during the last window, close it at the time\n            // of the navigation.\n            const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n            // End the previous cluster at the time of the first of the criteria above that was met.\n            const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n            // If there is an existing cluster update its closing time.\n            if (clusters.length > 0) {\n                const currentCluster = clusters[clusters.length - 1];\n                updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.MicroSeconds(previousClusterEndTime));\n            }\n            // If this cluster happened after a navigation, set the navigationId to\n            // the current navigation. This lets us easily group clusters by\n            // navigation.\n            const navigationId = currentShiftNavigation === null ?\n                Types.Events.NO_NAVIGATION :\n                navigations[currentShiftNavigation].args.data?.navigationId;\n            // TODO: `navigationId` is `string | undefined`, but the undefined portion\n            // comes from `data.navigationId`. I don't think that is possible for this\n            // event type. Can we make this typing stronger? In the meantime, we allow\n            // `navigationId` to include undefined values.\n            clusters.push({\n                name: 'SyntheticLayoutShiftCluster',\n                events: [],\n                clusterWindow: traceWindowFromTime(clusterStartTime),\n                clusterCumulativeScore: 0,\n                scoreWindows: {\n                    good: traceWindowFromTime(clusterStartTime),\n                },\n                navigationId,\n                // Set default Event so that this event is treated accordingly for the track appender.\n                ts: event.ts,\n                pid: event.pid,\n                tid: event.tid,\n                ph: \"X\" /* Types.Events.Phase.COMPLETE */,\n                cat: '',\n                dur: Types.Timing.MicroSeconds(-1), // This `cluster.dur` is updated below.\n            });\n            firstShiftTime = clusterStartTime;\n        }\n        // Given the above we should have a cluster available, so pick the most\n        // recent one and append the shift, bump its score and window values accordingly.\n        const currentCluster = clusters[clusters.length - 1];\n        const timeFromNavigation = currentShiftNavigation !== null ?\n            Types.Timing.MicroSeconds(event.ts - navigations[currentShiftNavigation].ts) :\n            undefined;\n        currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n        if (!event.args.data) {\n            continue;\n        }\n        const shift = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent({\n            rawSourceEvent: event,\n            ...event,\n            args: {\n                frame: event.args.frame,\n                data: {\n                    ...event.args.data,\n                    rawEvent: event,\n                    navigationId: currentCluster.navigationId ?? undefined,\n                },\n            },\n            parsedData: {\n                timeFromNavigation,\n                screenshots: findScreenshots(event.ts),\n                cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n                // The score of the session window is temporarily set to 0 just\n                // to initialize it. Since we need to get the score of all shifts\n                // in the session window to determine its value, its definite\n                // value is set when stepping through the built clusters.\n                sessionWindowData: { cumulativeWindowScore: 0, id: clusters.length },\n            },\n        });\n        currentCluster.events.push(shift);\n        updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n        lastShiftTime = event.ts;\n        lastShiftNavigation = currentShiftNavigation;\n    }\n    // Now step through each cluster and set up the times at which the value\n    // goes from Good, to needs improvement, to Bad. Note that if there is a\n    // large jump we may go from Good to Bad without ever creating a Needs\n    // Improvement window at all.\n    for (const cluster of clusters) {\n        let weightedScore = 0;\n        let windowID = -1;\n        // If this is the last cluster update its window. The cluster duration is determined\n        // by the minimum between: time to next navigation, trace end time, time to maximum\n        // cluster duration and time to maximum gap between layout shifts.\n        if (cluster === clusters[clusters.length - 1]) {\n            const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n            const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n            const nextNavigationIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n            const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n            const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n            updateTraceWindowMax(cluster.clusterWindow, Types.Timing.MicroSeconds(clusterEnd));\n        }\n        let largestScore = 0;\n        let worstShiftEvent = null;\n        for (const shift of cluster.events) {\n            weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n            windowID = shift.parsedData.sessionWindowData.id;\n            const ts = shift.ts;\n            // Update the the CLS score of this shift's session window now that\n            // we have it.\n            shift.parsedData.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n            if (weightedScore < 0.1 /* LayoutShiftsThreshold.NEEDS_IMPROVEMENT */) {\n                // Expand the Good window.\n                updateTraceWindowMax(cluster.scoreWindows.good, ts);\n            }\n            else if (weightedScore >= 0.1 /* LayoutShiftsThreshold.NEEDS_IMPROVEMENT */ && weightedScore < 0.25 /* LayoutShiftsThreshold.BAD */) {\n                if (!cluster.scoreWindows.needsImprovement) {\n                    // Close the Good window, and open the needs improvement window.\n                    updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n                    cluster.scoreWindows.needsImprovement = traceWindowFromTime(ts);\n                }\n                // Expand the needs improvement window.\n                updateTraceWindowMax(cluster.scoreWindows.needsImprovement, ts);\n            }\n            else if (weightedScore >= 0.25 /* LayoutShiftsThreshold.BAD */) {\n                if (!cluster.scoreWindows.bad) {\n                    // We may jump from Good to Bad here, so update whichever window is open.\n                    if (cluster.scoreWindows.needsImprovement) {\n                        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.MicroSeconds(ts - 1));\n                    }\n                    else {\n                        updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(ts - 1));\n                    }\n                    cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n                }\n                // Expand the Bad window.\n                updateTraceWindowMax(cluster.scoreWindows.bad, ts);\n            }\n            // At this point the windows are set by the timestamps of the events, but the\n            // next cluster begins at the timestamp of its first event. As such we now\n            // need to expand the score window to the end of the cluster, and we do so\n            // by using the Bad widow if it's there, or the NI window, or finally the\n            // Good window.\n            if (cluster.scoreWindows.bad) {\n                updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n            }\n            else if (cluster.scoreWindows.needsImprovement) {\n                updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n            }\n            else {\n                updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n            }\n            // Find the worst layout shift of the cluster.\n            const score = shift.args.data?.weighted_score_delta;\n            if (score !== undefined && score > largestScore) {\n                largestScore = score;\n                worstShiftEvent = shift;\n            }\n        }\n        // Update the cluster's worst layout shift.\n        if (worstShiftEvent) {\n            cluster.worstShiftEvent = worstShiftEvent;\n        }\n        // layout shifts are already sorted by time ascending.\n        // Capture the time range of the cluster.\n        cluster.ts = cluster.events[0].ts;\n        const lastShiftTimings = Helpers.Timing.eventTimingsMicroSeconds(cluster.events[cluster.events.length - 1]);\n        // Add MAX_SHIFT_TIME_DELTA, the section gap after the last layout shift. This marks the end of the cluster.\n        cluster.dur = Types.Timing.MicroSeconds((lastShiftTimings.endTime - cluster.events[0].ts) + MAX_SHIFT_TIME_DELTA);\n        if (weightedScore > sessionMaxScore) {\n            clsWindowID = windowID;\n            sessionMaxScore = weightedScore;\n        }\n        if (cluster.navigationId) {\n            const clustersForId = Platform.MapUtilities.getWithDefault(clustersByNavigationId, cluster.navigationId, () => {\n                return [];\n            });\n            clustersForId.push(cluster);\n        }\n    }\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('Layout Shifts Handler is not finalized');\n    }\n    return {\n        clusters,\n        sessionMaxScore,\n        clsWindowID,\n        prePaintEvents,\n        layoutInvalidationEvents,\n        scheduleStyleInvalidationEvents,\n        styleRecalcInvalidationEvents: [],\n        renderFrameImplCreateChildFrameEvents,\n        domLoadingEvents,\n        beginRemoteFontLoadEvents,\n        scoreRecords,\n        // TODO(crbug/41484172): change the type so no need to clone\n        backendNodeIds: [...backendNodeIds],\n        clustersByNavigationId: new Map(clustersByNavigationId),\n    };\n}\nexport function deps() {\n    return ['Screenshots', 'Meta'];\n}\nexport function scoreClassificationForLayoutShift(score) {\n    let state = \"good\" /* ScoreClassification.GOOD */;\n    if (score >= 0.1 /* LayoutShiftsThreshold.NEEDS_IMPROVEMENT */) {\n        state = \"ok\" /* ScoreClassification.OK */;\n    }\n    if (score >= 0.25 /* LayoutShiftsThreshold.BAD */) {\n        state = \"bad\" /* ScoreClassification.BAD */;\n    }\n    return state;\n}\n//# sourceMappingURL=LayoutShiftsHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\nconst updateCountersByProcess = new Map();\nexport function reset() {\n    updateCountersByProcess.clear();\n}\nexport function handleEvent(event) {\n    if (Types.Events.isUpdateCounters(event)) {\n        const countersForProcess = Platform.MapUtilities.getWithDefault(updateCountersByProcess, event.pid, () => []);\n        countersForProcess.push(event);\n        updateCountersByProcess.set(event.pid, countersForProcess);\n    }\n}\nexport function data() {\n    return { updateCountersByProcess };\n}\n//# sourceMappingURL=MemoryHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\nconst webSocketData = new Map();\nconst requestMap = new Map();\nconst requestsById = new Map();\nconst requestsByOrigin = new Map();\nconst requestsByTime = [];\nconst networkRequestEventByInitiatorUrl = new Map();\nconst eventToInitiatorMap = new Map();\nfunction storeTraceEventWithRequestId(requestId, key, value) {\n    if (!requestMap.has(requestId)) {\n        requestMap.set(requestId, {});\n    }\n    const traceEvents = requestMap.get(requestId);\n    if (!traceEvents) {\n        throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n    }\n    if (Array.isArray(traceEvents[key])) {\n        const target = traceEvents[key];\n        const values = value;\n        target.push(...values);\n    }\n    else {\n        traceEvents[key] = value;\n    }\n}\nfunction firstPositiveValueInList(entries) {\n    for (const entry of entries) {\n        if (entry > 0) {\n            return entry;\n        }\n    }\n    // In the event we don't find a positive value, we return 0 so as to\n    // be a mathematical noop. It's typically not correct to return  say \n    // a -1 here because it would affect the calculation of stats below.\n    return 0;\n}\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function reset() {\n    requestsById.clear();\n    requestsByOrigin.clear();\n    requestMap.clear();\n    requestsByTime.length = 0;\n    networkRequestEventByInitiatorUrl.clear();\n    eventToInitiatorMap.clear();\n    webSocketData.clear();\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n}\nexport function initialize() {\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Network Request handler is not initialized');\n    }\n    if (Types.Events.isResourceChangePriority(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'changePriority', event);\n        return;\n    }\n    if (Types.Events.isResourceWillSendRequest(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n        return;\n    }\n    if (Types.Events.isResourceSendRequest(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n        return;\n    }\n    if (Types.Events.isResourceReceiveResponse(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n        return;\n    }\n    if (Types.Events.isResourceReceivedData(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n        return;\n    }\n    if (Types.Events.isResourceFinish(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n        return;\n    }\n    if (Types.Events.isResourceMarkAsCached(event)) {\n        storeTraceEventWithRequestId(event.args.data.requestId, 'resourceMarkAsCached', event);\n        return;\n    }\n    if (Types.Events.isWebSocketCreate(event) || Types.Events.isWebSocketInfo(event) ||\n        Types.Events.isWebSocketTransfer(event)) {\n        const identifier = event.args.data.identifier;\n        if (!webSocketData.has(identifier)) {\n            if (event.args.data.frame) {\n                webSocketData.set(identifier, {\n                    frame: event.args.data.frame,\n                    webSocketIdentifier: identifier,\n                    events: [],\n                    syntheticConnection: null,\n                });\n            }\n            else if (event.args.data.workerId) {\n                webSocketData.set(identifier, {\n                    workerId: event.args.data.workerId,\n                    webSocketIdentifier: identifier,\n                    events: [],\n                    syntheticConnection: null,\n                });\n            }\n        }\n        webSocketData.get(identifier)?.events.push(event);\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Network Request handler is not initialized');\n    }\n    const { rendererProcessesByFrame } = metaHandlerData();\n    for (const [requestId, request] of requestMap.entries()) {\n        // If we have an incomplete set of events here, we choose to drop the network\n        // request rather than attempt to synthesize the missing data.\n        if (!request.sendRequests || !request.receiveResponse) {\n            continue;\n        }\n        // In the data we may get multiple willSendRequests and sendRequests, which\n        // will indicate that there are redirects for a given (sub)resource. In the\n        // case of a navigation, e.g., example.com/ we will get willSendRequests,\n        // and we should use these to calculate time spent in redirects.\n        // In the case of sub-resources, however, e.g., example.com/foo.js we will\n        // *only* get sendRequests, and we use these instead of willSendRequests\n        // to detect the time in redirects. We always use the sendRequest for the\n        // url, priority etc since it contains those values, but we use the\n        // willSendRequest (if it exists) to calculate the timestamp and durations\n        // of redirects.\n        const redirects = [];\n        for (let i = 0; i < request.sendRequests.length - 1; i++) {\n            const sendRequest = request.sendRequests[i];\n            const nextSendRequest = request.sendRequests[i + 1];\n            // Use the willSendRequests as the source for redirects if possible.\n            // We default to those of the sendRequests, however, since willSendRequest\n            // is not guaranteed to be present in the data for every request.\n            let ts = sendRequest.ts;\n            let dur = Types.Timing.MicroSeconds(nextSendRequest.ts - sendRequest.ts);\n            if (request.willSendRequests && request.willSendRequests[i] && request.willSendRequests[i + 1]) {\n                const willSendRequest = request.willSendRequests[i];\n                const nextWillSendRequest = request.willSendRequests[i + 1];\n                ts = willSendRequest.ts;\n                dur = Types.Timing.MicroSeconds(nextWillSendRequest.ts - willSendRequest.ts);\n            }\n            redirects.push({\n                url: sendRequest.args.data.url,\n                priority: sendRequest.args.data.priority,\n                requestMethod: sendRequest.args.data.requestMethod,\n                ts,\n                dur,\n            });\n        }\n        // If a ResourceFinish event with an encoded data length is received,\n        // then the resource was not cached; it was fetched before it was\n        // requested, e.g. because it was pushed in this navigation.\n        const isPushedResource = request.resourceFinish?.args.data.encodedDataLength !== 0;\n        // This works around crbug.com/998397, which reports pushed resources, and resources served by a service worker as disk cached.\n        const isDiskCached = request.receiveResponse.args.data.fromCache &&\n            !request.receiveResponse.args.data.fromServiceWorker && !isPushedResource;\n        // If the request contains a resourceMarkAsCached event, it was served from memory cache.\n        // The timing data returned is from the original (uncached) request, which\n        // means that if we leave the above network record data as-is when the\n        // request came from either the disk cache or memory cache, our calculations\n        // will be incorrect.\n        //\n        // So we use this flag so when we calculate the timestamps of the various\n        // events, we can overwrite them.\n        // These timestamps may not be perfect (indeed they don't always match\n        // the Network CDP domain exactly, which is likely an artifact of the way\n        // the data is routed on the backend), but they're the closest we have.\n        const isMemoryCached = request.resourceMarkAsCached !== undefined;\n        // If a request has `resourceMarkAsCached` field, the `timing` field is not correct.\n        // So let's discard it and override to 0 (which will be handled in later logic if timing field is undefined).\n        const timing = isMemoryCached ? undefined : request.receiveResponse.args.data.timing;\n        // If a non-cached request has no |timing| indicates data URLs, we ignore it.\n        if (!timing && !isMemoryCached) {\n            continue;\n        }\n        const firstSendRequest = request.sendRequests[0];\n        const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n        const initialPriority = finalSendRequest.args.data.priority;\n        let finalPriority = initialPriority;\n        if (request.changePriority) {\n            finalPriority = request.changePriority.args.data.priority;\n        }\n        // Start time\n        // =======================\n        // The time where the request started, which is either the first willSendRequest\n        // event if there is one, or, if there is not, the sendRequest.\n        const startTime = (request.willSendRequests && request.willSendRequests.length) ?\n            Types.Timing.MicroSeconds(request.willSendRequests[0].ts) :\n            Types.Timing.MicroSeconds(firstSendRequest.ts);\n        // End redirect time\n        // =======================\n        // It's possible that when we start requesting data we will receive redirections.\n        // Here we note the time of the *last* willSendRequest / sendRequest event,\n        // which is used later on in the calculations for time queueing etc.\n        const endRedirectTime = (request.willSendRequests && request.willSendRequests.length) ?\n            Types.Timing.MicroSeconds(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n            Types.Timing.MicroSeconds(finalSendRequest.ts);\n        // Finish time and end time\n        // =======================\n        // The finish time and the end time are subtly different.\n        //  - Finish time: records the point at which the network stack stopped receiving the data\n        //  - End time: the timestamp of the finish event itself (if one exists)\n        //\n        // The end time, then, will be slightly after the finish time.\n        const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n        const finishTime = request.resourceFinish?.args.data.finishTime ?\n            Types.Timing.MicroSeconds(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(endTime);\n        // Network duration\n        // =======================\n        // Time spent on the network.\n        const networkDuration = Types.Timing.MicroSeconds(timing ? (finishTime || endRedirectTime) - endRedirectTime : 0);\n        // Processing duration\n        // =======================\n        // Time spent from start to end.\n        const processingDuration = Types.Timing.MicroSeconds(endTime - (finishTime || endTime));\n        // Redirection duration\n        // =======================\n        // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n        // queueing, since the queueing time that we know about from the trace data is only the last request,\n        // i.e., the one that occurs after all the redirects.\n        const redirectionDuration = Types.Timing.MicroSeconds(endRedirectTime - startTime);\n        // Queueing\n        // =======================\n        // The amount of time queueing is the time between the request's start time to the requestTime\n        // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n        // that the requestTime we set queueing time to zero.\n        const queueingFromTraceData = timing ? timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime : 0;\n        const queueing = Types.Timing.MicroSeconds(Platform.NumberUtilities.clamp(queueingFromTraceData, 0, Number.MAX_VALUE));\n        // Stalled\n        // =======================\n        // If the request is cached, the amount of time stalled is the time between the start time and\n        // receiving a response.\n        // Otherwise it is whichever positive number comes first from the following timing info:\n        // DNS start, Connection start, Send Start, or the time duration between our start time and\n        // receiving a response.\n        const stalled = timing ? Types.Timing.MicroSeconds(firstPositiveValueInList([\n            timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n            timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n            timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n            (request.receiveResponse.ts - endRedirectTime),\n        ])) :\n            Types.Timing.MicroSeconds(request.receiveResponse.ts - startTime);\n        // Sending HTTP request\n        // =======================\n        // Time when the HTTP request is sent.\n        const sendStartTime = timing ?\n            Types.Timing.MicroSeconds(timing.requestTime * SECONDS_TO_MICROSECONDS + timing.sendStart * MILLISECONDS_TO_MICROSECONDS) :\n            startTime;\n        // Waiting\n        // =======================\n        // Time from when the send finished going to when the headers were received.\n        const waiting = timing ?\n            Types.Timing.MicroSeconds((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        // Download\n        // =======================\n        // Time from receipt of headers to the finish time.\n        const downloadStart = timing ?\n            Types.Timing.MicroSeconds(timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS) :\n            startTime;\n        const download = timing ? Types.Timing.MicroSeconds(((finishTime || downloadStart) - downloadStart)) :\n            Types.Timing.MicroSeconds(endTime - request.receiveResponse.ts);\n        const totalTime = Types.Timing.MicroSeconds(networkDuration + processingDuration);\n        // Collect a few values from the timing info.\n        // If the Network request is cached, these fields will be zero, so the minus will zero out them.\n        const dnsLookup = timing ?\n            Types.Timing.MicroSeconds((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        const ssl = timing ? Types.Timing.MicroSeconds((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        const proxyNegotiation = timing ?\n            Types.Timing.MicroSeconds((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        const requestSent = timing ?\n            Types.Timing.MicroSeconds((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        const initialConnection = timing ?\n            Types.Timing.MicroSeconds((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS) :\n            Types.Timing.MicroSeconds(0);\n        // Finally get some of the general data from the trace events.\n        const { frame, url, renderBlocking } = finalSendRequest.args.data;\n        const { encodedDataLength, decodedBodyLength } = request.resourceFinish ? request.resourceFinish.args.data : { encodedDataLength: 0, decodedBodyLength: 0 };\n        const parsedUrl = new URL(url);\n        const isHttps = parsedUrl.protocol === 'https:';\n        const requestingFrameUrl = Helpers.Trace.activeURLForFrameAtTime(frame, finalSendRequest.ts, rendererProcessesByFrame) || '';\n        // Construct a synthetic trace event for this network request.\n        const networkEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent({\n            rawSourceEvent: finalSendRequest,\n            args: {\n                data: {\n                    // All data we create from trace events should be added to |syntheticData|.\n                    syntheticData: {\n                        dnsLookup,\n                        download,\n                        downloadStart,\n                        finishTime,\n                        initialConnection,\n                        isDiskCached,\n                        isHttps,\n                        isMemoryCached,\n                        isPushedResource,\n                        networkDuration,\n                        processingDuration,\n                        proxyNegotiation,\n                        queueing,\n                        redirectionDuration,\n                        requestSent,\n                        sendStartTime,\n                        ssl,\n                        stalled,\n                        totalTime,\n                        waiting,\n                    },\n                    // All fields below are from TraceEventsForNetworkRequest.\n                    decodedBodyLength,\n                    encodedDataLength,\n                    frame,\n                    fromServiceWorker: request.receiveResponse.args.data.fromServiceWorker,\n                    isLinkPreload: finalSendRequest.args.data.isLinkPreload || false,\n                    mimeType: request.receiveResponse.args.data.mimeType,\n                    priority: finalPriority,\n                    initialPriority,\n                    protocol: request.receiveResponse.args.data.protocol ?? 'unknown',\n                    redirects,\n                    // In the event the property isn't set, assume non-blocking.\n                    renderBlocking: renderBlocking ?? 'non_blocking',\n                    requestId,\n                    requestingFrameUrl,\n                    requestMethod: finalSendRequest.args.data.requestMethod,\n                    resourceType: finalSendRequest.args.data.resourceType ?? \"Other\" /* Protocol.Network.ResourceType.Other */,\n                    statusCode: request.receiveResponse.args.data.statusCode,\n                    responseHeaders: request.receiveResponse.args.data.headers || [],\n                    fetchPriorityHint: finalSendRequest.args.data.fetchPriorityHint ?? 'auto',\n                    initiator: finalSendRequest.args.data.initiator,\n                    stackTrace: finalSendRequest.args.data.stackTrace,\n                    timing,\n                    url,\n                    failed: request.resourceFinish?.args.data.didFail ?? false,\n                    finished: Boolean(request.resourceFinish),\n                    connectionId: request.receiveResponse.args.data.connectionId,\n                    connectionReused: request.receiveResponse.args.data.connectionReused,\n                },\n            },\n            cat: 'loading',\n            name: 'SyntheticNetworkRequest',\n            ph: \"X\" /* Types.Events.Phase.COMPLETE */,\n            dur: Types.Timing.MicroSeconds(endTime - startTime),\n            tdur: Types.Timing.MicroSeconds(endTime - startTime),\n            ts: Types.Timing.MicroSeconds(startTime),\n            tts: Types.Timing.MicroSeconds(startTime),\n            pid: finalSendRequest.pid,\n            tid: finalSendRequest.tid,\n        });\n        const requests = Platform.MapUtilities.getWithDefault(requestsByOrigin, parsedUrl.host, () => {\n            return {\n                renderBlocking: [],\n                nonRenderBlocking: [],\n                all: [],\n            };\n        });\n        // For ease of rendering we sometimes want to differentiate between\n        // render-blocking and non-render-blocking, so we divide the data here.\n        if (!Helpers.Network.isSyntheticNetworkRequestEventRenderBlocking(networkEvent)) {\n            requests.nonRenderBlocking.push(networkEvent);\n        }\n        else {\n            requests.renderBlocking.push(networkEvent);\n        }\n        // However, there are also times where we just want to loop through all\n        // the captured requests, so here we store all of them together.\n        requests.all.push(networkEvent);\n        requestsByTime.push(networkEvent);\n        requestsById.set(networkEvent.args.data.requestId, networkEvent);\n        const initiatorUrl = networkEvent.args.data.initiator?.url ||\n            Helpers.Trace.getZeroIndexedStackTraceForEvent(networkEvent)?.at(0)?.url;\n        if (initiatorUrl) {\n            const events = networkRequestEventByInitiatorUrl.get(initiatorUrl) ?? [];\n            events.push(networkEvent);\n            networkRequestEventByInitiatorUrl.set(initiatorUrl, events);\n        }\n    }\n    for (const request of requestsByTime) {\n        const initiatedEvents = networkRequestEventByInitiatorUrl.get(request.args.data.url);\n        if (initiatedEvents) {\n            for (const initiatedEvent of initiatedEvents) {\n                eventToInitiatorMap.set(initiatedEvent, request);\n            }\n        }\n    }\n    finalizeWebSocketData();\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('Network Request handler is not finalized');\n    }\n    return {\n        byId: requestsById,\n        byOrigin: requestsByOrigin,\n        byTime: requestsByTime,\n        eventToInitiator: eventToInitiatorMap,\n        webSocket: [...webSocketData.values()],\n    };\n}\nexport function deps() {\n    return ['Meta'];\n}\nfunction finalizeWebSocketData() {\n    // for each WebSocketTraceData in webSocketData map, we create a synthetic event\n    // to represent the entire WebSocket connection. This is done by finding the start and end event\n    // if they exist, and if they don't, we use the first event in the list for start, and the traceBounds.max\n    // for the end. So each WebSocketTraceData will have\n    // {\n    //    events:  the list of WebSocket events\n    //    syntheticConnection:  the synthetic event representing the entire WebSocket connection\n    // }\n    webSocketData.forEach(data => {\n        let startEvent = null;\n        let endEvent = null;\n        for (const event of data.events) {\n            if (Types.Events.isWebSocketCreate(event)) {\n                startEvent = event;\n            }\n            if (Types.Events.isWebSocketDestroy(event)) {\n                endEvent = event;\n            }\n        }\n        data.syntheticConnection = createSyntheticWebSocketConnection(startEvent, endEvent, data.events[0]);\n    });\n}\nfunction createSyntheticWebSocketConnection(startEvent, endEvent, firstRecordedEvent) {\n    const { traceBounds } = metaHandlerData();\n    const startTs = startEvent ? startEvent.ts : traceBounds.min;\n    const endTs = endEvent ? endEvent.ts : traceBounds.max;\n    const duration = endTs - startTs;\n    const mainEvent = startEvent || endEvent || firstRecordedEvent;\n    return {\n        name: 'SyntheticWebSocketConnection',\n        cat: mainEvent.cat,\n        ph: \"X\" /* Types.Events.Phase.COMPLETE */,\n        ts: startTs,\n        dur: duration,\n        pid: mainEvent.pid,\n        tid: mainEvent.tid,\n        s: mainEvent.s,\n        rawSourceEvent: mainEvent,\n        _tag: 'SyntheticEntryTag',\n        args: {\n            data: {\n                identifier: mainEvent.args.data.identifier,\n                priority: \"Low\" /* Protocol.Network.ResourcePriority.Low */,\n                url: mainEvent.args.data.url || '',\n            },\n        },\n    };\n}\n//# sourceMappingURL=NetworkRequestsHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\nconst frames = new Map();\nexport function reset() {\n    frames.clear();\n}\nexport function handleEvent(event) {\n    if (Types.Events.isTracingStartedInBrowser(event)) {\n        for (const frame of event.args.data?.frames ?? []) {\n            // The ID of a frame is stored under the `frame` key.\n            frames.set(frame.frame, frame);\n        }\n        return;\n    }\n    // CommitLoad events can contain an updated URL or Name for a frame.\n    if (Types.Events.isCommitLoad(event)) {\n        const frameData = event.args.data;\n        if (!frameData) {\n            return;\n        }\n        // We don't want to mutate the original object, hence why\n        // we set a new object from the new and existing values.\n        const frame = frames.get(frameData.frame);\n        if (!frame) {\n            return;\n        }\n        frames.set(frameData.frame, {\n            ...frame,\n            url: frameData.url || frame.url,\n            name: frameData.name || frameData.name,\n        });\n    }\n}\nexport function data() {\n    return {\n        frames,\n    };\n}\n//# sourceMappingURL=PageFramesHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/**\n * This handler stores page load metrics, including web vitals,\n * and exports them in the shape of a map with the following shape:\n * Map(FrameId -> Map(navigationID -> metrics) )\n *\n * It also exports all markers in a trace in an array.\n *\n * Some metrics are taken directly from a page load events (AKA markers) like DCL.\n * Others require processing multiple events to be determined, like CLS and TBT.\n */\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId = new Map();\n/**\n * Page load events with no associated duration that happened in the\n * main frame.\n */\nlet allMarkerEvents = [];\nexport function reset() {\n    metricScoresByFrameId.clear();\n    pageLoadEventsArray = [];\n    allMarkerEvents = [];\n    selectedLCPCandidateEvents.clear();\n}\nlet pageLoadEventsArray = [];\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set();\nexport function handleEvent(event) {\n    if (!Types.Events.eventIsPageLoadEvent(event)) {\n        return;\n    }\n    pageLoadEventsArray.push(event);\n}\nfunction storePageLoadMetricAgainstNavigationId(navigation, event) {\n    const navigationId = navigation.args.data?.navigationId;\n    if (!navigationId) {\n        throw new Error('Navigation event unexpectedly had no navigation ID.');\n    }\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const { rendererProcessesByFrame } = metaHandlerData();\n    // If either of these pieces of data do not exist, the most likely\n    // explanation is that the page load metric we found is for a frame/process\n    // combo that the MetaHandler discarded. This typically happens if we get a\n    // navigation event with an empty URL. Therefore, we will silently return and\n    // drop this metric. If we didn't care about the navigation, we certainly do\n    // not need to care about metrics for that navigation.\n    const rendererProcessesInFrame = rendererProcessesByFrame.get(frameId);\n    if (!rendererProcessesInFrame) {\n        return;\n    }\n    const processData = rendererProcessesInFrame.get(event.pid);\n    if (!processData) {\n        return;\n    }\n    if (Types.Events.isNavigationStart(event)) {\n        return;\n    }\n    if (Types.Events.isFirstContentfulPaint(event)) {\n        const fcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n        const metricScore = { event, metricName: \"FCP\" /* MetricName.FCP */, classification, navigation, timing: fcpTime };\n        storeMetricScore(frameId, navigationId, metricScore);\n        return;\n    }\n    if (Types.Events.isFirstPaint(event)) {\n        const paintTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const classification = \"unclassified\" /* ScoreClassification.UNCLASSIFIED */;\n        const metricScore = { event, metricName: \"FP\" /* MetricName.FP */, classification, navigation, timing: paintTime };\n        storeMetricScore(frameId, navigationId, metricScore);\n        return;\n    }\n    if (Types.Events.isMarkDOMContent(event)) {\n        const dclTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const metricScore = {\n            event,\n            metricName: \"DCL\" /* MetricName.DCL */,\n            classification: scoreClassificationForDOMContentLoaded(dclTime),\n            navigation,\n            timing: dclTime,\n        };\n        storeMetricScore(frameId, navigationId, metricScore);\n        return;\n    }\n    if (Types.Events.isInteractiveTime(event)) {\n        const ttiValue = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const tti = {\n            event,\n            metricName: \"TTI\" /* MetricName.TTI */,\n            classification: scoreClassificationForTimeToInteractive(ttiValue),\n            navigation,\n            timing: ttiValue,\n        };\n        storeMetricScore(frameId, navigationId, tti);\n        const tbtValue = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(event.args.args.total_blocking_time_ms));\n        const tbt = {\n            event,\n            metricName: \"TBT\" /* MetricName.TBT */,\n            classification: scoreClassificationForTotalBlockingTime(tbtValue),\n            navigation,\n            timing: tbtValue,\n        };\n        storeMetricScore(frameId, navigationId, tbt);\n        return;\n    }\n    if (Types.Events.isMarkLoad(event)) {\n        const loadTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const metricScore = {\n            event,\n            metricName: \"L\" /* MetricName.L */,\n            classification: \"unclassified\" /* ScoreClassification.UNCLASSIFIED */,\n            navigation,\n            timing: loadTime,\n        };\n        storeMetricScore(frameId, navigationId, metricScore);\n        return;\n    }\n    if (Types.Events.isLargestContentfulPaintCandidate(event)) {\n        const candidateIndex = event.args.data?.candidateIndex;\n        if (!candidateIndex) {\n            throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n        }\n        const lcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n        const lcp = {\n            event,\n            metricName: \"LCP\" /* MetricName.LCP */,\n            classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n            navigation,\n            timing: lcpTime,\n        };\n        const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n        const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n        const lastLCPCandidate = metrics.get(\"LCP\" /* MetricName.LCP */);\n        if (lastLCPCandidate === undefined) {\n            selectedLCPCandidateEvents.add(lcp.event);\n            storeMetricScore(frameId, navigationId, lcp);\n            return;\n        }\n        const lastLCPCandidateEvent = lastLCPCandidate.event;\n        if (!Types.Events.isLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n            return;\n        }\n        const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n        if (!lastCandidateIndex) {\n            // lastCandidateIndex cannot be undefined because we don't store candidates with\n            // with an undefined candidateIndex value. This check is only to make TypeScript\n            // treat the field as not undefined below.\n            return;\n        }\n        if (lastCandidateIndex < candidateIndex) {\n            selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n            selectedLCPCandidateEvents.add(lcp.event);\n            storeMetricScore(frameId, navigationId, lcp);\n        }\n        return;\n    }\n    if (Types.Events.isLayoutShift(event)) {\n        return;\n    }\n    return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\nfunction storeMetricScore(frameId, navigationId, metricScore) {\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    // If an entry with that metric name is present, delete it so that the new entry that\n    // will replace it is added at the end of the map. This way we guarantee the map entries\n    // are ordered in ASC manner by timestamp.\n    metrics.delete(metricScore.metricName);\n    metrics.set(metricScore.metricName, metricScore);\n}\nexport function getFrameIdForPageLoadEvent(event) {\n    if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isInteractiveTime(event) ||\n        Types.Events.isLargestContentfulPaintCandidate(event) || Types.Events.isNavigationStart(event) ||\n        Types.Events.isLayoutShift(event) || Types.Events.isFirstPaint(event)) {\n        return event.args.frame;\n    }\n    if (Types.Events.isMarkDOMContent(event) || Types.Events.isMarkLoad(event)) {\n        const frameId = event.args.data?.frame;\n        if (!frameId) {\n            throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n        }\n        return frameId;\n    }\n    Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\nfunction getNavigationForPageLoadEvent(event) {\n    if (Types.Events.isFirstContentfulPaint(event) || Types.Events.isLargestContentfulPaintCandidate(event) ||\n        Types.Events.isFirstPaint(event)) {\n        const navigationId = event.args.data?.navigationId;\n        if (!navigationId) {\n            throw new Error('Trace event unexpectedly had no navigation ID.');\n        }\n        const { navigationsByNavigationId } = metaHandlerData();\n        const navigation = navigationsByNavigationId.get(navigationId);\n        if (!navigation) {\n            // This event's navigation has been filtered out by the meta handler as a noise event.\n            return null;\n        }\n        return navigation;\n    }\n    if (Types.Events.isMarkDOMContent(event) || Types.Events.isInteractiveTime(event) ||\n        Types.Events.isLayoutShift(event) || Types.Events.isMarkLoad(event)) {\n        const frameId = getFrameIdForPageLoadEvent(event);\n        const { navigationsByFrameId } = metaHandlerData();\n        return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n    }\n    if (Types.Events.isNavigationStart(event)) {\n        // We don't want to compute metrics of the navigation relative to itself, so we'll avoid avoid all that.\n        return null;\n    }\n    return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds) {\n    const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(1.8));\n    const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.0));\n    let scoreClassification = \"bad\" /* ScoreClassification.BAD */;\n    if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n        scoreClassification = \"ok\" /* ScoreClassification.OK */;\n    }\n    if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n        scoreClassification = \"good\" /* ScoreClassification.GOOD */;\n    }\n    return scoreClassification;\n}\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds) {\n    const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.8));\n    const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(7.3));\n    let scoreClassification = \"bad\" /* ScoreClassification.BAD */;\n    if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n        scoreClassification = \"ok\" /* ScoreClassification.OK */;\n    }\n    if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n        scoreClassification = \"good\" /* ScoreClassification.GOOD */;\n    }\n    return scoreClassification;\n}\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds) {\n    const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(2.5));\n    const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(4));\n    let scoreClassification = \"bad\" /* ScoreClassification.BAD */;\n    if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n        scoreClassification = \"ok\" /* ScoreClassification.OK */;\n    }\n    if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n        scoreClassification = \"good\" /* ScoreClassification.GOOD */;\n    }\n    return scoreClassification;\n}\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds) {\n    return \"unclassified\" /* ScoreClassification.UNCLASSIFIED */;\n}\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds) {\n    const TBT_GOOD_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n    const TBT_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(600));\n    let scoreClassification = \"bad\" /* ScoreClassification.BAD */;\n    if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n        scoreClassification = \"ok\" /* ScoreClassification.OK */;\n    }\n    if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n        scoreClassification = \"good\" /* ScoreClassification.GOOD */;\n    }\n    return scoreClassification;\n}\n/**\n * Gets all the Largest Contentful Paint scores of all the frames in the\n * trace.\n */\nfunction gatherFinalLCPEvents() {\n    const allFinalLCPEvents = [];\n    const dataForAllFrames = [...metricScoresByFrameId.values()];\n    const dataForAllNavigations = dataForAllFrames.flatMap(frameData => [...frameData.values()]);\n    for (let i = 0; i < dataForAllNavigations.length; i++) {\n        const navigationData = dataForAllNavigations[i];\n        const lcpInNavigation = navigationData.get(\"LCP\" /* MetricName.LCP */);\n        if (!lcpInNavigation || !lcpInNavigation.event) {\n            continue;\n        }\n        allFinalLCPEvents.push(lcpInNavigation.event);\n    }\n    return allFinalLCPEvents;\n}\nexport async function finalize() {\n    pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n    for (const pageLoadEvent of pageLoadEventsArray) {\n        const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n        if (navigation) {\n            // Event's navigation was not filtered out as noise.\n            storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n        }\n    }\n    // NOTE: if you are looking for the TBT calculation, it has temporarily been\n    // removed. See crbug.com/1424335 for details.\n    const allFinalLCPEvents = gatherFinalLCPEvents();\n    const mainFrame = metaHandlerData().mainFrameId;\n    // Filter out LCP candidates to use only definitive LCP values\n    const allEventsButLCP = pageLoadEventsArray.filter(event => !Types.Events.isLargestContentfulPaintCandidate(event));\n    const markerEvents = [...allFinalLCPEvents, ...allEventsButLCP].filter(Types.Events.isMarkerEvent);\n    // Filter by main frame and sort.\n    allMarkerEvents =\n        markerEvents.filter(event => getFrameIdForPageLoadEvent(event) === mainFrame).sort((a, b) => a.ts - b.ts);\n}\nexport function data() {\n    return {\n        metricScoresByFrameId,\n        allMarkerEvents,\n    };\n}\nexport function deps() {\n    return ['Meta'];\n}\n//# sourceMappingURL=PageLoadMetricsHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\nlet lastUpdateLayoutTreeEvent = null;\nconst selectorDataForUpdateLayoutTree = new Map();\nexport function reset() {\n    lastUpdateLayoutTreeEvent = null;\n    selectorDataForUpdateLayoutTree.clear();\n}\nexport function handleEvent(event) {\n    if (Types.Events.isSelectorStats(event) && lastUpdateLayoutTreeEvent && event.args.selector_stats) {\n        selectorDataForUpdateLayoutTree.set(lastUpdateLayoutTreeEvent, {\n            timings: event.args.selector_stats.selector_timings,\n        });\n        return;\n    }\n    if (Types.Events.isUpdateLayoutTree(event)) {\n        lastUpdateLayoutTreeEvent = event;\n        return;\n    }\n}\nexport function data() {\n    return {\n        dataForUpdateLayoutEvent: selectorDataForUpdateLayoutTree,\n    };\n}\n//# sourceMappingURL=SelectorStatsHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as networkData } from './NetworkRequestsHandler.js';\nconst serverTimings = [];\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function reset() {\n    serverTimings.length = 0;\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n}\nexport function initialize() {\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(_event) {\n    // Implementation not needed because data is sourced from NetworkRequestsHandler\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Server Timings handler is not initialized');\n    }\n    extractServerTimings();\n    Helpers.Trace.sortTraceEventsInPlace(serverTimings);\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nconst RESPONSE_START_METRIC_NAME = 'response-start';\nconst RESPONSE_END_METRIC_NAME = 'response-end';\n/**\n * Creates synthetic trace events based on server timings in the\n * `Server-Timing` response header. A non-standard `start` param is\n * expected on each metric that contains the start time of the timing\n * based on the server clock.\n *\n * In order to estimate the offset between the server and client clocks,\n * we look for the non-standard `response-start` and `response-end`\n * metrics in the response header, which contain the start and end\n * timestamps of the network request processing in the server. We\n * compare these with the times the request was sent and received in the\n * client to estimate the offset between the client and the server\n * clocks.\n *\n * With this offset estimation at hand, we can map timestamps from the\n * server clock to the tracing clock and locate the timings in the\n * performance timeline.\n */\nfunction extractServerTimings() {\n    for (const networkEvent of networkData().byTime) {\n        let timingsInRequest = null;\n        for (const header of networkEvent.args.data.responseHeaders) {\n            const headerName = header.name.toLocaleLowerCase();\n            // Some popular hosting providers like vercel or render get rid of\n            // Server-Timing headers added by users, so as a workaround we\n            // also support server timing headers with the `-test` suffix\n            // while this feature is experimental, to enable easier trials.\n            if (headerName === 'server-timing' || headerName === 'server-timing-test') {\n                header.name = 'server-timing';\n                timingsInRequest = Platform.ServerTiming.ServerTiming.parseHeaders([header]);\n                continue;\n            }\n        }\n        const serverStart = timingsInRequest?.find(timing => timing.metric === RESPONSE_START_METRIC_NAME)?.start;\n        const serverEnd = timingsInRequest?.find(timing => timing.metric === RESPONSE_END_METRIC_NAME)?.start;\n        if (!serverStart || !serverEnd || !timingsInRequest) {\n            continue;\n        }\n        const serverStartInMicro = serverStart * 1_000;\n        const serverEndInMicro = serverEnd * 1_000;\n        serverTimings.push(...createSyntheticServerTiming(networkEvent, serverStartInMicro, serverEndInMicro, timingsInRequest));\n    }\n}\nfunction createSyntheticServerTiming(request, serverStart, serverEnd, timingsInRequest) {\n    const clientStart = request.args.data.syntheticData.sendStartTime;\n    const clientEndTime = request.args.data.syntheticData.sendStartTime + request.args.data.syntheticData.waiting;\n    const offset = Types.Timing.MicroSeconds((serverStart - clientStart + serverEnd - clientEndTime) / 2);\n    const convertedServerTimings = [];\n    for (const timing of timingsInRequest) {\n        if (timing.metric === RESPONSE_START_METRIC_NAME || timing.metric === RESPONSE_END_METRIC_NAME) {\n            continue;\n        }\n        if (timing.start === null) {\n            continue;\n        }\n        const convertedTimestamp = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(timing.start)) - offset;\n        const parsedUrl = new URL(request.args.data.url);\n        const origin = parsedUrl.origin;\n        const serverTiming = Helpers.SyntheticEvents.SyntheticEventsManager.registerServerTiming({\n            rawSourceEvent: request.rawSourceEvent,\n            name: timing.metric,\n            ph: \"X\" /* Types.Events.Phase.COMPLETE */,\n            pid: Types.Events.ProcessID(0),\n            tid: Types.Events.ThreadID(0),\n            ts: Types.Timing.MicroSeconds(convertedTimestamp),\n            dur: Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(timing.value)),\n            cat: 'devtools.server-timing',\n            args: { data: { desc: timing.description || undefined, origin } },\n        });\n        if (!request.args.data.syntheticServerTimings) {\n            request.args.data.syntheticServerTimings = [];\n        }\n        request.args.data.syntheticServerTimings.push(serverTiming);\n        convertedServerTimings.push(serverTiming);\n    }\n    return convertedServerTimings;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('Server Timing handler is not finalized');\n    }\n    return {\n        serverTimings,\n    };\n}\nexport function deps() {\n    return ['NetworkRequests'];\n}\n//# sourceMappingURL=ServerTimingsHandler.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as metaHandlerData } from './MetaHandler.js';\n// This handler serves two purposes. It generates a list of events that are\n// used to show user clicks in the timeline. It is also used to gather\n// EventTimings into Interactions, which we use to show interactions and\n// highlight long interactions to the user, along with INP.\n// We don't need to know which process / thread these events occurred in,\n// because they are effectively global, so we just track all that we find.\nconst allEvents = [];\nconst beginCommitCompositorFrameEvents = [];\nconst parseMetaViewportEvents = [];\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(500));\nlet longestInteractionEvent = null;\nconst interactionEvents = [];\nconst interactionEventsWithNoNesting = [];\nconst eventTimingEndEventsById = new Map();\nconst eventTimingStartEventsForInteractions = [];\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nexport function reset() {\n    allEvents.length = 0;\n    beginCommitCompositorFrameEvents.length = 0;\n    parseMetaViewportEvents.length = 0;\n    interactionEvents.length = 0;\n    eventTimingStartEventsForInteractions.length = 0;\n    eventTimingEndEventsById.clear();\n    interactionEventsWithNoNesting.length = 0;\n    longestInteractionEvent = null;\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Handler is not initialized');\n    }\n    if (Types.Events.isBeginCommitCompositorFrame(event)) {\n        beginCommitCompositorFrameEvents.push(event);\n        return;\n    }\n    if (Types.Events.isParseMetaViewport(event)) {\n        parseMetaViewportEvents.push(event);\n        return;\n    }\n    if (!Types.Events.isEventTiming(event)) {\n        return;\n    }\n    if (Types.Events.isEventTimingEnd(event)) {\n        // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n        eventTimingEndEventsById.set(event.id, event);\n    }\n    allEvents.push(event);\n    // From this point on we want to find events that represent interactions.\n    // These events are always start events - those are the ones that contain all\n    // the metadata about the interaction.\n    if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n        return;\n    }\n    const { duration, interactionId } = event.args.data;\n    // We exclude events for the sake of interactions if:\n    // 1. They have no duration.\n    // 2. They have no interactionId\n    // 3. They have an interactionId of 0: this indicates that it's not an\n    //    interaction that we care about because it hasn't had its own interactionId\n    //    set (0 is the default on the backend).\n    // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n    if (duration < 1 || interactionId === undefined || interactionId === 0) {\n        return;\n    }\n    // Store the start event. In the finalize() function we will pair this with\n    // its end event and create the synthetic interaction event.\n    eventTimingStartEventsForInteractions.push(event);\n}\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n    'pointerdown',\n    'touchstart',\n    'pointerup',\n    'touchend',\n    'mousedown',\n    'mouseup',\n    'click',\n]);\nconst keyboardEventTypes = new Set([\n    'keydown',\n    'keypress',\n    'keyup',\n]);\nexport function categoryOfInteraction(interaction) {\n    if (pointerEventTypes.has(interaction.type)) {\n        return 'POINTER';\n    }\n    if (keyboardEventTypes.has(interaction.type)) {\n        return 'KEYBOARD';\n    }\n    return 'OTHER';\n}\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n **/\nexport function removeNestedInteractions(interactions) {\n    /**\n     * Because we nest events only that are in the same category, we store the\n     * longest event for a given end time by category.\n     **/\n    const earliestEventForEndTimePerCategory = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n    };\n    function storeEventIfEarliestForCategoryAndEndTime(interaction) {\n        const category = categoryOfInteraction(interaction);\n        const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n        const endTime = Types.Timing.MicroSeconds(interaction.ts + interaction.dur);\n        const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n        if (!earliestCurrentEvent) {\n            earliestEventForEndTime.set(endTime, interaction);\n            return;\n        }\n        if (interaction.ts < earliestCurrentEvent.ts) {\n            earliestEventForEndTime.set(endTime, interaction);\n        }\n        else if (interaction.ts === earliestCurrentEvent.ts &&\n            interaction.interactionId === earliestCurrentEvent.interactionId) {\n            // We have seen in traces that the same interaction can have multiple\n            // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n            // events will have an event handler bound to it which caused delay on\n            // the main thread, and the others will not. This leads to a situation\n            // where if we pick one of the events that had no event handler, its\n            // processing duration (processingEnd - processingStart) will be 0, but if we\n            // had picked the event that had the slow event handler, we would show\n            // correctly the main thread delay due to the event handler.\n            // So, if we find events with the same interactionId and the same\n            // begin/end times, we pick the one with the largest (processingEnd -\n            // processingStart) time in order to make sure we find the event with the\n            // worst main thread delay, as that is the one the user should care\n            // about.\n            const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n            const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n            // Use the new interaction if it has a longer processing duration than the existing one.\n            if (newProcessingDuration > currentProcessingDuration) {\n                earliestEventForEndTime.set(endTime, interaction);\n            }\n        }\n        // Maximize the processing duration based on the \"children\" interactions.\n        // We pick the earliest start processing duration, and the latest end\n        // processing duration to avoid under-reporting.\n        if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n            earliestCurrentEvent.processingStart = interaction.processingStart;\n            writeSyntheticTimespans(earliestCurrentEvent);\n        }\n        if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n            earliestCurrentEvent.processingEnd = interaction.processingEnd;\n            writeSyntheticTimespans(earliestCurrentEvent);\n        }\n    }\n    for (const interaction of interactions) {\n        storeEventIfEarliestForCategoryAndEndTime(interaction);\n    }\n    // Combine all the events that we have kept from all the per-category event\n    // maps back into an array and sort them by timestamp.\n    const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n        .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n    keptEvents.sort((eventA, eventB) => {\n        return eventA.ts - eventB.ts;\n    });\n    return keptEvents;\n}\nfunction writeSyntheticTimespans(event) {\n    const startEvent = event.args.data.beginEvent;\n    const endEvent = event.args.data.endEvent;\n    event.inputDelay = Types.Timing.MicroSeconds(event.processingStart - startEvent.ts);\n    event.mainThreadHandling = Types.Timing.MicroSeconds(event.processingEnd - event.processingStart);\n    event.presentationDelay = Types.Timing.MicroSeconds(endEvent.ts - event.processingEnd);\n}\nexport async function finalize() {\n    const { navigationsByFrameId } = metaHandlerData();\n    // For each interaction start event, find the async end event by the ID, and then create the Synthetic Interaction event.\n    for (const interactionStartEvent of eventTimingStartEventsForInteractions) {\n        const endEvent = eventTimingEndEventsById.get(interactionStartEvent.id);\n        if (!endEvent) {\n            // If we cannot find an end event, bail and drop this event.\n            continue;\n        }\n        if (!interactionStartEvent.args.data?.type || !interactionStartEvent.args.data?.interactionId) {\n            // A valid interaction event that we care about has to have a type (e.g.\n            // pointerdown, keyup).\n            //\n            // We also need to ensure it has an interactionId. We already checked\n            // this in the handleEvent() function, but we do it here also to satisfy\n            // TypeScript.\n            continue;\n        }\n        // In the future we will add microsecond timestamps to the trace events,\n        // but until then we can use the millisecond precision values that are in\n        // the trace event. To adjust them to be relative to the event.ts and the\n        // trace timestamps, for both processingStart and processingEnd we subtract\n        // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n        // emitted in args.data), and then add that value to the event.ts. This\n        // will give us a processingStart and processingEnd time in microseconds\n        // that is relative to event.ts, and can be used when drawing boxes.\n        // There is some inaccuracy here as we are converting milliseconds to microseconds, but it is good enough until the backend emits more accurate numbers.\n        const processingStartRelativeToTraceTime = Types.Timing.MicroSeconds(Helpers.Timing.millisecondsToMicroseconds(interactionStartEvent.args.data.processingStart) -\n            Helpers.Timing.millisecondsToMicroseconds(interactionStartEvent.args.data.timeStamp) +\n            interactionStartEvent.ts);\n        const processingEndRelativeToTraceTime = Types.Timing.MicroSeconds((Helpers.Timing.millisecondsToMicroseconds(interactionStartEvent.args.data.processingEnd) -\n            Helpers.Timing.millisecondsToMicroseconds(interactionStartEvent.args.data.timeStamp)) +\n            interactionStartEvent.ts);\n        const frameId = interactionStartEvent.args.frame ?? interactionStartEvent.args.data.frame;\n        const navigation = Helpers.Trace.getNavigationForTraceEvent(interactionStartEvent, frameId, navigationsByFrameId);\n        const navigationId = navigation?.args.data?.navigationId;\n        const interactionEvent = Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent({\n            // Use the start event to define the common fields.\n            rawSourceEvent: interactionStartEvent,\n            cat: interactionStartEvent.cat,\n            name: interactionStartEvent.name,\n            pid: interactionStartEvent.pid,\n            tid: interactionStartEvent.tid,\n            ph: interactionStartEvent.ph,\n            processingStart: processingStartRelativeToTraceTime,\n            processingEnd: processingEndRelativeToTraceTime,\n            // These will be set in writeSyntheticTimespans()\n            inputDelay: Types.Timing.MicroSeconds(-1),\n            mainThreadHandling: Types.Timing.MicroSeconds(-1),\n            presentationDelay: Types.Timing.MicroSeconds(-1),\n            args: {\n                data: {\n                    beginEvent: interactionStartEvent,\n                    endEvent,\n                    frame: frameId,\n                    navigationId,\n                },\n            },\n            ts: interactionStartEvent.ts,\n            dur: Types.Timing.MicroSeconds(endEvent.ts - interactionStartEvent.ts),\n            type: interactionStartEvent.args.data.type,\n            interactionId: interactionStartEvent.args.data.interactionId,\n        });\n        writeSyntheticTimespans(interactionEvent);\n        interactionEvents.push(interactionEvent);\n    }\n    handlerState = 3 /* HandlerState.FINALIZED */;\n    interactionEventsWithNoNesting.push(...removeNestedInteractions(interactionEvents));\n    // Pick the longest interactions from the set that were not nested, as we\n    // know those are the set of the largest interactions.\n    for (const interactionEvent of interactionEventsWithNoNesting) {\n        if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n            longestInteractionEvent = interactionEvent;\n        }\n    }\n}\nexport function data() {\n    return {\n        allEvents,\n        beginCommitCompositorFrameEvents,\n        parseMetaViewportEvents,\n        interactionEvents,\n        interactionEventsWithNoNesting,\n        longestInteractionEvent,\n        interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n            return event.dur > LONG_INTERACTION_THRESHOLD;\n        })),\n    };\n}\nexport function deps() {\n    return ['Meta'];\n}\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing) {\n    if (timing <= INP_GOOD_TIMING) {\n        return \"good\" /* ScoreClassification.GOOD */;\n    }\n    if (timing <= INP_MEDIUM_TIMING) {\n        return \"ok\" /* ScoreClassification.OK */;\n    }\n    return \"bad\" /* ScoreClassification.BAD */;\n}\n//# sourceMappingURL=UserInteractionsHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { data as userInteractionsHandlerData } from './UserInteractionsHandler.js';\nconst warningsPerEvent = new Map();\nconst eventsPerWarning = new Map();\n/**\n * Tracks the stack formed by nested trace events up to a given point\n */\nconst allEventsStack = [];\n/**\n * Tracks the stack formed by JS invocation trace events up to a given point.\n * F.e. FunctionCall, EvaluateScript, V8Execute.\n * Not to be confused with ProfileCalls.\n */\nconst jsInvokeStack = [];\n/**\n * Tracks reflow events in a task.\n */\nconst taskReflowEvents = [];\nexport const FORCED_REFLOW_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(30));\nexport const LONG_MAIN_THREAD_TASK_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\nexport function reset() {\n    warningsPerEvent.clear();\n    eventsPerWarning.clear();\n    allEventsStack.length = 0;\n    jsInvokeStack.length = 0;\n    taskReflowEvents.length = 0;\n}\nfunction storeWarning(event, warning) {\n    const existingWarnings = Platform.MapUtilities.getWithDefault(warningsPerEvent, event, () => []);\n    existingWarnings.push(warning);\n    warningsPerEvent.set(event, existingWarnings);\n    const existingEvents = Platform.MapUtilities.getWithDefault(eventsPerWarning, warning, () => []);\n    existingEvents.push(event);\n    eventsPerWarning.set(warning, existingEvents);\n}\nexport function handleEvent(event) {\n    processForcedReflowWarning(event);\n    if (event.name === \"RunTask\" /* Types.Events.Name.RUN_TASK */) {\n        const { duration } = Helpers.Timing.eventTimingsMicroSeconds(event);\n        if (duration > LONG_MAIN_THREAD_TASK_THRESHOLD) {\n            storeWarning(event, 'LONG_TASK');\n        }\n        return;\n    }\n    if (Types.Events.isFireIdleCallback(event)) {\n        const { duration } = Helpers.Timing.eventTimingsMilliSeconds(event);\n        if (duration > event.args.data.allottedMilliseconds) {\n            storeWarning(event, 'IDLE_CALLBACK_OVER_TIME');\n        }\n        return;\n    }\n}\n/**\n * Reflows* are added a warning to if:\n * 1. They are forced/sync, meaning they are invoked by JS and finish\n *    during the Script execution.\n * 2. Their duration exceeds a threshold.\n * - *Reflow: The style recalculation and layout steps in a render task.\n */\nfunction processForcedReflowWarning(event) {\n    // Update the event and the JS invocation stacks.\n    accomodateEventInStack(event, allEventsStack);\n    accomodateEventInStack(event, jsInvokeStack, /* pushEventToStack */ Types.Events.isJSInvocationEvent(event));\n    if (jsInvokeStack.length) {\n        // Current event falls inside a JS call.\n        if (event.name === \"Layout\" /* Types.Events.Name.LAYOUT */ || event.name === \"UpdateLayoutTree\" /* Types.Events.Name.UPDATE_LAYOUT_TREE */) {\n            // A forced reflow happened. However we need to check if\n            // the threshold is surpassed to add a warning. Accumulate the\n            // event to check for this after the current Task is over.\n            taskReflowEvents.push(event);\n            return;\n        }\n    }\n    if (allEventsStack.length === 1) {\n        // We hit a new task. Check if the forced reflows in the previous\n        // task exceeded the threshold and add a warning if so.\n        const totalTime = taskReflowEvents.reduce((time, event) => time + (event.dur || 0), 0);\n        if (totalTime >= FORCED_REFLOW_THRESHOLD) {\n            taskReflowEvents.forEach(reflowEvent => storeWarning(reflowEvent, 'FORCED_REFLOW'));\n        }\n        taskReflowEvents.length = 0;\n    }\n}\n/**\n * Updates a given trace event stack given a new event.\n */\nfunction accomodateEventInStack(event, stack, pushEventToStack = true) {\n    let nextItem = stack.at(-1);\n    while (nextItem && event.ts > nextItem.ts + (nextItem.dur || 0)) {\n        stack.pop();\n        nextItem = stack.at(-1);\n    }\n    if (!pushEventToStack) {\n        return;\n    }\n    stack.push(event);\n}\nexport function deps() {\n    return ['UserInteractions'];\n}\nexport async function finalize() {\n    // These events do exist on the UserInteractionsHandler, but we also put\n    // them into the WarningsHandler so that the warnings handler can be the\n    // source of truth and the way to look up all warnings for a given event.\n    // Otherwise, we would have to look up warnings across multiple handlers for\n    // a given event, which will start to get messy very quickly.\n    const longInteractions = userInteractionsHandlerData().interactionsOverThreshold;\n    for (const interaction of longInteractions) {\n        storeWarning(interaction, 'LONG_INTERACTION');\n    }\n}\nexport function data() {\n    return {\n        perEvent: warningsPerEvent,\n        perWarning: eventsPerWarning,\n    };\n}\n//# sourceMappingURL=WarningsHandler.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Types from '../types/types.js';\nlet handlerState = 1 /* HandlerState.UNINITIALIZED */;\nconst sessionIdEvents = [];\nconst workerIdByThread = new Map();\nconst workerURLById = new Map();\nexport function initialize() {\n    if (handlerState !== 1 /* HandlerState.UNINITIALIZED */) {\n        throw new Error('Workers Handler was not reset');\n    }\n    handlerState = 2 /* HandlerState.INITIALIZED */;\n}\nexport function reset() {\n    sessionIdEvents.length = 0;\n    workerIdByThread.clear();\n    workerURLById.clear();\n    handlerState = 1 /* HandlerState.UNINITIALIZED */;\n}\nexport function handleEvent(event) {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Workers Handler is not initialized');\n    }\n    if (Types.Events.isTracingSessionIdForWorker(event)) {\n        sessionIdEvents.push(event);\n    }\n}\nexport async function finalize() {\n    if (handlerState !== 2 /* HandlerState.INITIALIZED */) {\n        throw new Error('Handler is not initialized');\n    }\n    for (const sessionIdEvent of sessionIdEvents) {\n        if (!sessionIdEvent.args.data) {\n            continue;\n        }\n        workerIdByThread.set(sessionIdEvent.args.data.workerThreadId, sessionIdEvent.args.data.workerId);\n        workerURLById.set(sessionIdEvent.args.data.workerId, sessionIdEvent.args.data.url);\n    }\n    handlerState = 3 /* HandlerState.FINALIZED */;\n}\nexport function data() {\n    if (handlerState !== 3 /* HandlerState.FINALIZED */) {\n        throw new Error('Workers Handler is not finalized');\n    }\n    return {\n        workerSessionIdEvents: sessionIdEvents,\n        workerIdByThread,\n        workerURLById,\n    };\n}\n//# sourceMappingURL=WorkersHandler.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nexport function getInsight(insightName, insights, key) {\n    if (!insights || !key) {\n        return null;\n    }\n    const insightSets = insights.get(key);\n    if (!insightSets) {\n        return null;\n    }\n    const insight = insightSets.data[insightName];\n    if (insight instanceof Error) {\n        return null;\n    }\n    // For some reason typescript won't narrow the type by removing Error, so do it manually.\n    return insight;\n}\n/**\n * Finds a network request given a navigation context and URL.\n * Considers redirects.\n */\nexport function findRequest(parsedTrace, context, url) {\n    const request = parsedTrace.NetworkRequests.byTime.find(req => {\n        const urlMatch = req.args.data.url === url || req.args.data.redirects.some(r => r.url === url);\n        if (!urlMatch) {\n            return false;\n        }\n        const nav = Helpers.Trace.getNavigationForTraceEvent(req, context.frameId, parsedTrace.Meta.navigationsByFrameId);\n        return nav === context.navigation;\n    });\n    return request ?? null;\n}\nexport function findLCPRequest(parsedTrace, context, lcpEvent) {\n    const lcpNodeId = lcpEvent.args.data?.nodeId;\n    if (!lcpNodeId) {\n        throw new Error('no lcp node id');\n    }\n    const imagePaint = parsedTrace.LargestImagePaint.get(lcpNodeId);\n    if (!imagePaint) {\n        return null;\n    }\n    const lcpUrl = imagePaint.args.data?.imageUrl;\n    if (!lcpUrl) {\n        throw new Error('no lcp url');\n    }\n    const lcpRequest = findRequest(parsedTrace, context, lcpUrl);\n    if (!lcpRequest) {\n        throw new Error('no lcp request found');\n    }\n    return lcpRequest;\n}\n//# sourceMappingURL=Common.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nexport function deps() {\n    return ['Meta', 'Animations', 'LayoutShifts', 'NetworkRequests'];\n}\n/**\n * Each failure reason is represented by a bit flag. The bit shift operator '<<' is used to define\n * which bit corresponds to each failure reason.\n * https://source.chromium.org/search?q=f:compositor_animations.h%20%22enum%20FailureReason%22\n * @type {{flag: number, failure: AnimationFailureReasons}[]}\n */\nconst ACTIONABLE_FAILURE_REASONS = [\n    {\n        flag: 1 << 0,\n        failure: \"ACCELERATED_ANIMATIONS_DISABLED\" /* AnimationFailureReasons.ACCELERATED_ANIMATIONS_DISABLED */,\n    },\n    {\n        flag: 1 << 1,\n        failure: \"EFFECT_SUPPRESSED_BY_DEVTOOLS\" /* AnimationFailureReasons.EFFECT_SUPPRESSED_BY_DEVTOOLS */,\n    },\n    {\n        flag: 1 << 2,\n        failure: \"INVALID_ANIMATION_OR_EFFECT\" /* AnimationFailureReasons.INVALID_ANIMATION_OR_EFFECT */,\n    },\n    {\n        flag: 1 << 3,\n        failure: \"EFFECT_HAS_UNSUPPORTED_TIMING_PARAMS\" /* AnimationFailureReasons.EFFECT_HAS_UNSUPPORTED_TIMING_PARAMS */,\n    },\n    {\n        flag: 1 << 4,\n        failure: \"EFFECT_HAS_NON_REPLACE_COMPOSITE_MODE\" /* AnimationFailureReasons.EFFECT_HAS_NON_REPLACE_COMPOSITE_MODE */,\n    },\n    {\n        flag: 1 << 5,\n        failure: \"TARGET_HAS_INVALID_COMPOSITING_STATE\" /* AnimationFailureReasons.TARGET_HAS_INVALID_COMPOSITING_STATE */,\n    },\n    {\n        flag: 1 << 6,\n        failure: \"TARGET_HAS_INCOMPATIBLE_ANIMATIONS\" /* AnimationFailureReasons.TARGET_HAS_INCOMPATIBLE_ANIMATIONS */,\n    },\n    {\n        flag: 1 << 7,\n        failure: \"TARGET_HAS_CSS_OFFSET\" /* AnimationFailureReasons.TARGET_HAS_CSS_OFFSET */,\n    },\n    // The failure 1 << 8 is marked as obsolete in Blink\n    {\n        flag: 1 << 9,\n        failure: \"ANIMATION_AFFECTS_NON_CSS_PROPERTIES\" /* AnimationFailureReasons.ANIMATION_AFFECTS_NON_CSS_PROPERTIES */,\n    },\n    {\n        flag: 1 << 10,\n        failure: \"TRANSFORM_RELATED_PROPERTY_CANNOT_BE_ACCELERATED_ON_TARGET\" /* AnimationFailureReasons.TRANSFORM_RELATED_PROPERTY_CANNOT_BE_ACCELERATED_ON_TARGET */,\n    },\n    {\n        flag: 1 << 11,\n        failure: \"TRANSFROM_BOX_SIZE_DEPENDENT\" /* AnimationFailureReasons.TRANSFROM_BOX_SIZE_DEPENDENT */,\n    },\n    {\n        flag: 1 << 12,\n        failure: \"FILTER_RELATED_PROPERTY_MAY_MOVE_PIXELS\" /* AnimationFailureReasons.FILTER_RELATED_PROPERTY_MAY_MOVE_PIXELS */,\n    },\n    {\n        flag: 1 << 13,\n        failure: \"UNSUPPORTED_CSS_PROPERTY\" /* AnimationFailureReasons.UNSUPPORTED_CSS_PROPERTY */,\n    },\n    // The failure 1 << 14 is marked as obsolete in Blink\n    {\n        flag: 1 << 15,\n        failure: \"MIXED_KEYFRAME_VALUE_TYPES\" /* AnimationFailureReasons.MIXED_KEYFRAME_VALUE_TYPES */,\n    },\n    {\n        flag: 1 << 16,\n        failure: \"TIMELINE_SOURCE_HAS_INVALID_COMPOSITING_STATE\" /* AnimationFailureReasons.TIMELINE_SOURCE_HAS_INVALID_COMPOSITING_STATE */,\n    },\n    {\n        flag: 1 << 17,\n        failure: \"ANIMATION_HAS_NO_VISIBLE_CHANGE\" /* AnimationFailureReasons.ANIMATION_HAS_NO_VISIBLE_CHANGE */,\n    },\n    {\n        flag: 1 << 18,\n        failure: \"AFFECTS_IMPORTANT_PROPERTY\" /* AnimationFailureReasons.AFFECTS_IMPORTANT_PROPERTY */,\n    },\n    {\n        flag: 1 << 19,\n        failure: \"SVG_TARGET_HAS_INDEPENDENT_TRANSFORM_PROPERTY\" /* AnimationFailureReasons.SVG_TARGET_HAS_INDEPENDENT_TRANSFORM_PROPERTY */,\n    },\n];\n// 500ms window.\n// Use this window to consider events and requests that may have caused a layout shift.\nconst INVALIDATION_WINDOW = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(0.5));\nfunction isInInvalidationWindow(event, targetEvent) {\n    const eventEnd = event.dur ? event.ts + event.dur : event.ts;\n    return eventEnd < targetEvent.ts && eventEnd >= targetEvent.ts - INVALIDATION_WINDOW;\n}\nexport function getNonCompositedFailure(animationEvent) {\n    const failures = [];\n    const beginEvent = animationEvent.args.data.beginEvent;\n    const instantEvents = animationEvent.args.data.instantEvents || [];\n    /**\n     * Animation events containing composite information are ASYNC_NESTABLE_INSTANT ('n').\n     * An animation may also contain multiple 'n' events, so we look through those with useful non-composited data.\n     */\n    for (const event of instantEvents) {\n        const failureMask = event.args.data.compositeFailed;\n        const unsupportedProperties = event.args.data.unsupportedProperties;\n        if (!failureMask) {\n            continue;\n        }\n        const failureReasons = ACTIONABLE_FAILURE_REASONS.filter(reason => failureMask & reason.flag).map(reason => reason.failure);\n        const failure = {\n            name: beginEvent.args.data.displayName,\n            failureReasons,\n            unsupportedProperties,\n            animation: animationEvent,\n        };\n        failures.push(failure);\n    }\n    return failures;\n}\nfunction getNonCompositedFailureRootCauses(animationEvents, prePaintEvents, shiftsByPrePaint, rootCausesByShift) {\n    const allAnimationFailures = [];\n    for (const animation of animationEvents) {\n        /**\n         * Animation events containing composite information are ASYNC_NESTABLE_INSTANT ('n').\n         * An animation may also contain multiple 'n' events, so we look through those with useful non-composited data.\n         */\n        const failures = getNonCompositedFailure(animation);\n        if (!failures) {\n            continue;\n        }\n        allAnimationFailures.push(...failures);\n        const nextPrePaint = getNextPrePaintEvent(prePaintEvents, animation);\n        // If no following prePaint, this is not a root cause.\n        if (!nextPrePaint) {\n            continue;\n        }\n        // If the animation event is outside the INVALIDATION_WINDOW, it could not be a root cause.\n        if (!isInInvalidationWindow(animation, nextPrePaint)) {\n            continue;\n        }\n        const shifts = shiftsByPrePaint.get(nextPrePaint);\n        // if no layout shift(s), this is not a root cause.\n        if (!shifts) {\n            continue;\n        }\n        for (const shift of shifts) {\n            const rootCausesForShift = rootCausesByShift.get(shift);\n            if (!rootCausesForShift) {\n                throw new Error('Unaccounted shift');\n            }\n            rootCausesForShift.nonCompositedAnimations.push(...failures);\n        }\n    }\n    return allAnimationFailures;\n}\n/**\n * Given an array of layout shift and PrePaint events, returns a mapping from\n * PrePaint events to layout shifts dispatched within it.\n */\nfunction getShiftsByPrePaintEvents(layoutShifts, prePaintEvents) {\n    // Maps from PrePaint events to LayoutShifts that occured in each one.\n    const shiftsByPrePaint = new Map();\n    // Associate all shifts to their corresponding PrePaint.\n    for (const prePaintEvent of prePaintEvents) {\n        const firstShiftIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(layoutShifts, shift => shift.ts >= prePaintEvent.ts);\n        if (firstShiftIndex === null) {\n            // No layout shifts registered after this PrePaint start. Continue.\n            continue;\n        }\n        for (let i = firstShiftIndex; i < layoutShifts.length; i++) {\n            const shift = layoutShifts[i];\n            if (shift.ts >= prePaintEvent.ts && shift.ts <= prePaintEvent.ts + prePaintEvent.dur) {\n                const shiftsInPrePaint = Platform.MapUtilities.getWithDefault(shiftsByPrePaint, prePaintEvent, () => []);\n                shiftsInPrePaint.push(shift);\n            }\n            if (shift.ts > prePaintEvent.ts + prePaintEvent.dur) {\n                // Reached all layoutShifts of this PrePaint. Break out to continue with the next prePaint event.\n                break;\n            }\n        }\n    }\n    return shiftsByPrePaint;\n}\n/**\n * This gets the first prePaint event that follows the provided event and returns it.\n */\nfunction getNextPrePaintEvent(prePaintEvents, targetEvent) {\n    // Get the first PrePaint event that happened after the targetEvent.\n    const nextPrePaintIndex = Platform.ArrayUtilities.nearestIndexFromBeginning(prePaintEvents, prePaint => prePaint.ts > targetEvent.ts + (targetEvent.dur || 0));\n    // No PrePaint event registered after this event\n    if (nextPrePaintIndex === null) {\n        return undefined;\n    }\n    return prePaintEvents[nextPrePaintIndex];\n}\n/**\n * An Iframe is considered a root cause if the iframe event occurs before a prePaint event\n * and within this prePaint event a layout shift(s) occurs.\n */\nfunction getIframeRootCauses(iframeCreatedEvents, prePaintEvents, shiftsByPrePaint, rootCausesByShift, domLoadingEvents) {\n    for (const iframeEvent of iframeCreatedEvents) {\n        const nextPrePaint = getNextPrePaintEvent(prePaintEvents, iframeEvent);\n        // If no following prePaint, this is not a root cause.\n        if (!nextPrePaint) {\n            continue;\n        }\n        const shifts = shiftsByPrePaint.get(nextPrePaint);\n        // if no layout shift(s), this is not a root cause.\n        if (!shifts) {\n            continue;\n        }\n        for (const shift of shifts) {\n            const rootCausesForShift = rootCausesByShift.get(shift);\n            if (!rootCausesForShift) {\n                throw new Error('Unaccounted shift');\n            }\n            // Look for the first dom event that occurs within the bounds of the iframe event.\n            // This contains the frame id.\n            const domEvent = domLoadingEvents.find(e => {\n                const maxIframe = Types.Timing.MicroSeconds(iframeEvent.ts + (iframeEvent.dur ?? 0));\n                return e.ts >= iframeEvent.ts && e.ts <= maxIframe;\n            });\n            if (domEvent && domEvent.args.frame) {\n                rootCausesForShift.iframeIds.push(domEvent.args.frame);\n            }\n        }\n    }\n    return rootCausesByShift;\n}\n/**\n * A font request is considered a root cause if the request occurs before a prePaint event\n * and within this prePaint event a layout shift(s) occurs. Additionally, this font request should\n * happen within the INVALIDATION_WINDOW of the prePaint event.\n */\nfunction getFontRootCauses(networkRequests, prePaintEvents, shiftsByPrePaint, rootCausesByShift) {\n    const fontRequests = networkRequests.filter(req => req.args.data.resourceType === 'Font' && req.args.data.mimeType.startsWith('font'));\n    for (const req of fontRequests) {\n        const nextPrePaint = getNextPrePaintEvent(prePaintEvents, req);\n        if (!nextPrePaint) {\n            continue;\n        }\n        // If the req is outside the INVALIDATION_WINDOW, it could not be a root cause.\n        if (!isInInvalidationWindow(req, nextPrePaint)) {\n            continue;\n        }\n        // Get the shifts that belong to this prepaint\n        const shifts = shiftsByPrePaint.get(nextPrePaint);\n        // if no layout shift(s) in this prePaint, the request is not a root cause.\n        if (!shifts) {\n            continue;\n        }\n        // Include the root cause to the shifts in this prePaint.\n        for (const shift of shifts) {\n            const rootCausesForShift = rootCausesByShift.get(shift);\n            if (!rootCausesForShift) {\n                throw new Error('Unaccounted shift');\n            }\n            rootCausesForShift.fontRequests.push(req);\n        }\n    }\n    return rootCausesByShift;\n}\nexport function generateInsight(parsedTrace, context) {\n    const isWithinContext = (event) => Helpers.Timing.eventIsInBounds(event, context.bounds);\n    const compositeAnimationEvents = parsedTrace.Animations.animations.filter(isWithinContext);\n    const iframeEvents = parsedTrace.LayoutShifts.renderFrameImplCreateChildFrameEvents.filter(isWithinContext);\n    const networkRequests = parsedTrace.NetworkRequests.byTime.filter(isWithinContext);\n    const domLoadingEvents = parsedTrace.LayoutShifts.domLoadingEvents.filter(isWithinContext);\n    const clusterKey = context.navigation ? context.navigationId : Types.Events.NO_NAVIGATION;\n    const clusters = parsedTrace.LayoutShifts.clustersByNavigationId.get(clusterKey) ?? [];\n    const clustersByScore = clusters.toSorted((a, b) => b.clusterCumulativeScore - a.clusterCumulativeScore);\n    const worstCluster = clustersByScore.at(0);\n    const layoutShifts = clusters.flatMap(cluster => cluster.events);\n    const prePaintEvents = parsedTrace.LayoutShifts.prePaintEvents.filter(isWithinContext);\n    // Get root causes.\n    const rootCausesByShift = new Map();\n    const shiftsByPrePaint = getShiftsByPrePaintEvents(layoutShifts, prePaintEvents);\n    for (const shift of layoutShifts) {\n        rootCausesByShift.set(shift, { iframeIds: [], fontRequests: [], nonCompositedAnimations: [] });\n    }\n    // Populate root causes for rootCausesByShift.\n    getIframeRootCauses(iframeEvents, prePaintEvents, shiftsByPrePaint, rootCausesByShift, domLoadingEvents);\n    getFontRootCauses(networkRequests, prePaintEvents, shiftsByPrePaint, rootCausesByShift);\n    const animationFailures = getNonCompositedFailureRootCauses(compositeAnimationEvents, prePaintEvents, shiftsByPrePaint, rootCausesByShift);\n    const relatedEvents = [...layoutShifts];\n    if (worstCluster) {\n        relatedEvents.push(worstCluster);\n    }\n    return {\n        relatedEvents,\n        animationFailures,\n        shifts: rootCausesByShift,\n        clusters,\n        worstCluster,\n    };\n}\n//# sourceMappingURL=CumulativeLayoutShift.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n// Due to the way that DevTools throttling works we cannot see if server response took less than ~570ms.\n// We set our failure threshold to 600ms to avoid those false positives but we want devs to shoot for 100ms.\nconst TOO_SLOW_THRESHOLD_MS = 600;\nconst TARGET_MS = 100;\n// Threshold for compression savings.\nconst IGNORE_THRESHOLD_IN_BYTES = 1400;\nexport function deps() {\n    return ['Meta', 'NetworkRequests'];\n}\nfunction getServerResponseTime(request) {\n    const timing = request.args.data.timing;\n    if (!timing) {\n        return null;\n    }\n    const ms = Helpers.Timing.microSecondsToMilliseconds(request.args.data.syntheticData.waiting);\n    return Math.round(ms);\n}\nfunction getCompressionSavings(request) {\n    // Check from headers if compression was already applied.\n    // Older devtools logs are lower case, while modern logs are Cased-Like-This.\n    const patterns = [\n        /^content-encoding$/i,\n        /^x-content-encoding-over-network$/i,\n    ];\n    const compressionTypes = ['gzip', 'br', 'deflate', 'zstd'];\n    const isCompressed = request.args.data.responseHeaders.some(header => patterns.some(p => header.name.match(p)) && compressionTypes.includes(header.value));\n    if (isCompressed) {\n        return 0;\n    }\n    // We don't know how many bytes this asset used on the network, but we can guess it was\n    // roughly the size of the content gzipped.\n    // See https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer for specific CSS/Script examples\n    // See https://discuss.httparchive.org/t/file-size-and-compression-savings/145 for fallback multipliers\n    // See https://letstalkaboutwebperf.com/en/gzip-brotli-server-config/ for MIME types to compress\n    const originalSize = request.args.data.decodedBodyLength;\n    let estimatedSavings = 0;\n    switch (request.args.data.mimeType) {\n        case 'text/css':\n            // Stylesheets tend to compress extremely well.\n            estimatedSavings = Math.round(originalSize * 0.8);\n            break;\n        case 'text/html':\n        case 'text/javascript':\n            // Scripts and HTML compress fairly well too.\n            estimatedSavings = Math.round(originalSize * 0.67);\n            break;\n        case 'text/plain':\n        case 'text/xml':\n        case 'text/x-component':\n        case 'application/javascript':\n        case 'application/json':\n        case 'application/manifest+json':\n        case 'application/vnd.api+json':\n        case 'application/xml':\n        case 'application/xhtml+xml':\n        case 'application/rss+xml':\n        case 'application/atom+xml':\n        case 'application/vnd.ms-fontobject':\n        case 'application/x-font-ttf':\n        case 'application/x-font-opentype':\n        case 'application/x-font-truetype':\n        case 'image/svg+xml':\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n        case 'font/ttf':\n        case 'font/eot':\n        case 'font/otf':\n        case 'font/opentype':\n            // Use the average savings in HTTPArchive.\n            estimatedSavings = Math.round(originalSize * 0.5);\n            break;\n        default: // Any other MIME types are likely already compressed.\n    }\n    // Check if the estimated savings are greater than the byte ignore threshold.\n    // Note that the estimated gzip savings are always more than 10%, so there is\n    // no percent threshold.\n    return estimatedSavings < IGNORE_THRESHOLD_IN_BYTES ? 0 : estimatedSavings;\n}\nexport function generateInsight(parsedTrace, context) {\n    if (!context.navigation) {\n        return {};\n    }\n    const documentRequest = parsedTrace.NetworkRequests.byTime.find(req => req.args.data.requestId === context.navigationId);\n    if (!documentRequest) {\n        throw new Error('missing document request');\n    }\n    const serverResponseTime = getServerResponseTime(documentRequest);\n    if (serverResponseTime === null) {\n        throw new Error('missing document request timing');\n    }\n    const serverResponseTooSlow = serverResponseTime > TOO_SLOW_THRESHOLD_MS;\n    let overallSavingsMs = 0;\n    if (serverResponseTime > TOO_SLOW_THRESHOLD_MS) {\n        overallSavingsMs = Math.max(serverResponseTime - TARGET_MS, 0);\n    }\n    const redirectDuration = Math.round(documentRequest.args.data.syntheticData.redirectionDuration / 1000);\n    overallSavingsMs += redirectDuration;\n    const metricSavings = {\n        FCP: overallSavingsMs,\n        LCP: overallSavingsMs,\n    };\n    return {\n        relatedEvents: [documentRequest],\n        data: {\n            serverResponseTime,\n            serverResponseTooSlow,\n            redirectDuration: Types.Timing.MilliSeconds(redirectDuration),\n            uncompressedResponseBytes: getCompressionSavings(documentRequest),\n            documentRequest,\n        },\n        metricSavings,\n    };\n}\n//# sourceMappingURL=DocumentLatency.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nexport function deps() {\n    return ['Meta', 'NetworkRequests', 'LayoutShifts'];\n}\nexport function generateInsight(parsedTrace, context) {\n    const fonts = [];\n    for (const event of parsedTrace.LayoutShifts.beginRemoteFontLoadEvents) {\n        if (!Helpers.Timing.eventIsInBounds(event, context.bounds)) {\n            continue;\n        }\n        const requestId = `${event.pid}.${event.args.id}`;\n        const request = parsedTrace.NetworkRequests.byId.get(requestId);\n        if (!request) {\n            continue;\n        }\n        const display = event.args.display;\n        let wastedTime = Types.Timing.MilliSeconds(0);\n        if (/^(block|fallback|auto)$/.test(display)) {\n            const wastedTimeMicro = Types.Timing.MicroSeconds(request.args.data.syntheticData.finishTime - request.args.data.syntheticData.sendStartTime);\n            // TODO(crbug.com/352244504): should really end at the time of the next Commit trace event.\n            wastedTime = Platform.NumberUtilities.floor(Helpers.Timing.microSecondsToMilliseconds(wastedTimeMicro), 1 / 5);\n            // All browsers wait for no more than 3s.\n            wastedTime = Math.min(wastedTime, 3000);\n        }\n        fonts.push({\n            request,\n            display,\n            wastedTime,\n        });\n    }\n    fonts.sort((a, b) => b.wastedTime - a.wastedTime);\n    const savings = Math.max(...fonts.map(f => f.wastedTime));\n    return {\n        relatedEvents: fonts.map(f => f.request),\n        fonts,\n        metricSavings: { FCP: savings },\n    };\n}\n//# sourceMappingURL=FontDisplay.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nexport function deps() {\n    return ['UserInteractions'];\n}\nexport function generateInsight(parsedTrace, context) {\n    const interactionEvents = parsedTrace.UserInteractions.interactionEventsWithNoNesting.filter(event => {\n        return Helpers.Timing.eventIsInBounds(event, context.bounds);\n    });\n    if (!interactionEvents.length) {\n        // A valid result, when there is no user interaction.\n        return {};\n    }\n    const longestByInteractionId = new Map();\n    for (const event of interactionEvents) {\n        const key = event.interactionId;\n        const longest = longestByInteractionId.get(key);\n        if (!longest || event.dur > longest.dur) {\n            longestByInteractionId.set(key, event);\n        }\n    }\n    const normalizedInteractionEvents = [...longestByInteractionId.values()];\n    normalizedInteractionEvents.sort((a, b) => b.dur - a.dur);\n    // INP is the \"nearest-rank\"/inverted_cdf 98th percentile, except Chrome only\n    // keeps the 10 worst events around, so it can never be more than the 10th from\n    // last array element. To keep things simpler, sort desc and pick from front.\n    // See https://source.chromium.org/chromium/chromium/src/+/main:components/page_load_metrics/browser/responsiveness_metrics_normalization.cc;l=45-59;drc=cb0f9c8b559d9c7c3cb4ca94fc1118cc015d38ad\n    const highPercentileIndex = Math.min(9, Math.floor(normalizedInteractionEvents.length / 50));\n    return {\n        relatedEvents: [normalizedInteractionEvents[0]],\n        longestInteractionEvent: normalizedInteractionEvents[0],\n        highPercentileInteractionEvent: normalizedInteractionEvents[highPercentileIndex],\n    };\n}\n//# sourceMappingURL=InteractionToNextPaint.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { findLCPRequest } from './Common.js';\nimport { InsightWarning } from './types.js';\nexport function deps() {\n    return ['NetworkRequests', 'PageLoadMetrics', 'LargestImagePaint', 'Meta'];\n}\nfunction anyValuesNaN(...values) {\n    return values.some(v => Number.isNaN(v));\n}\n/**\n * Calculates the 4 phases of an LCP and the timings of each.\n * Will return `null` if any required values were missing. We don't ever expect\n * them to be missing on newer traces, but old trace files may lack some of the\n * data we rely on, so we want to handle that case.\n */\nfunction breakdownPhases(nav, docRequest, lcpMs, lcpRequest) {\n    const docReqTiming = docRequest.args.data.timing;\n    if (!docReqTiming) {\n        throw new Error('no timing for document request');\n    }\n    const firstDocByteTs = Helpers.Timing.secondsToMicroseconds(docReqTiming.requestTime) +\n        Helpers.Timing.millisecondsToMicroseconds(docReqTiming.receiveHeadersStart);\n    const firstDocByteTiming = Types.Timing.MicroSeconds(firstDocByteTs - nav.ts);\n    const ttfb = Helpers.Timing.microSecondsToMilliseconds(firstDocByteTiming);\n    let renderDelay = Types.Timing.MilliSeconds(lcpMs - ttfb);\n    if (!lcpRequest) {\n        if (anyValuesNaN(ttfb, renderDelay)) {\n            return null;\n        }\n        return { ttfb, renderDelay };\n    }\n    const lcpStartTs = Types.Timing.MicroSeconds(lcpRequest.ts - nav.ts);\n    const requestStart = Helpers.Timing.microSecondsToMilliseconds(lcpStartTs);\n    const lcpReqEndTs = Types.Timing.MicroSeconds(lcpRequest.args.data.syntheticData.finishTime - nav.ts);\n    const requestEnd = Helpers.Timing.microSecondsToMilliseconds(lcpReqEndTs);\n    const loadDelay = Types.Timing.MilliSeconds(requestStart - ttfb);\n    const loadTime = Types.Timing.MilliSeconds(requestEnd - requestStart);\n    renderDelay = Types.Timing.MilliSeconds(lcpMs - requestEnd);\n    if (anyValuesNaN(ttfb, loadDelay, loadTime, renderDelay)) {\n        return null;\n    }\n    return {\n        ttfb,\n        loadDelay,\n        loadTime,\n        renderDelay,\n    };\n}\nexport function generateInsight(parsedTrace, context) {\n    if (!context.navigation) {\n        return {};\n    }\n    const networkRequests = parsedTrace.NetworkRequests;\n    const frameMetrics = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(context.frameId);\n    if (!frameMetrics) {\n        throw new Error('no frame metrics');\n    }\n    const navMetrics = frameMetrics.get(context.navigationId);\n    if (!navMetrics) {\n        throw new Error('no navigation metrics');\n    }\n    const metricScore = navMetrics.get(\"LCP\" /* Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP */);\n    const lcpEvent = metricScore?.event;\n    if (!lcpEvent || !Types.Events.isLargestContentfulPaintCandidate(lcpEvent)) {\n        return { warnings: [InsightWarning.NO_LCP] };\n    }\n    // This helps calculate the phases.\n    const lcpMs = Helpers.Timing.microSecondsToMilliseconds(metricScore.timing);\n    // This helps position things on the timeline's UI accurately for a trace.\n    const lcpTs = metricScore.event?.ts ? Helpers.Timing.microSecondsToMilliseconds(metricScore.event?.ts) : undefined;\n    const lcpRequest = findLCPRequest(parsedTrace, context, lcpEvent);\n    const docRequest = networkRequests.byTime.find(req => req.args.data.requestId === context.navigationId);\n    if (!docRequest) {\n        return { lcpMs, lcpTs, lcpEvent, warnings: [InsightWarning.NO_DOCUMENT_REQUEST] };\n    }\n    if (!lcpRequest) {\n        return {\n            lcpMs,\n            lcpTs,\n            lcpEvent,\n            phases: breakdownPhases(context.navigation, docRequest, lcpMs, lcpRequest) ?? undefined,\n        };\n    }\n    const initiatorUrl = lcpRequest.args.data.initiator?.url;\n    // TODO(b/372319476): Explore using trace event HTMLDocumentParser::FetchQueuedPreloads to determine if the request\n    // is discovered by the preload scanner.\n    const initiatedByMainDoc = lcpRequest?.args.data.initiator?.type === 'parser' && docRequest.args.data.url === initiatorUrl;\n    const imgPreloadedOrFoundInHTML = lcpRequest?.args.data.isLinkPreload || initiatedByMainDoc;\n    const imageLoadingAttr = lcpEvent.args.data?.loadingAttr;\n    const imageFetchPriorityHint = lcpRequest?.args.data.fetchPriorityHint;\n    // This is the earliest discovery time an LCP request could have - it's TTFB.\n    const earliestDiscoveryTime = docRequest && docRequest.args.data.timing ?\n        Helpers.Timing.secondsToMicroseconds(docRequest.args.data.timing.requestTime) +\n            Helpers.Timing.millisecondsToMicroseconds(docRequest.args.data.timing.receiveHeadersStart) :\n        undefined;\n    return {\n        lcpMs,\n        lcpTs,\n        lcpEvent,\n        phases: breakdownPhases(context.navigation, docRequest, lcpMs, lcpRequest) ?? undefined,\n        shouldRemoveLazyLoading: imageLoadingAttr === 'lazy',\n        shouldIncreasePriorityHint: imageFetchPriorityHint !== 'high',\n        shouldPreloadImage: !imgPreloadedOrFoundInHTML,\n        lcpRequest,\n        earliestDiscoveryTimeTs: earliestDiscoveryTime ? Types.Timing.MicroSeconds(earliestDiscoveryTime) : undefined,\n    };\n}\n//# sourceMappingURL=LargestContentfulPaint.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from '../handlers/handlers.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nimport { findLCPRequest } from './Common.js';\nimport { InsightWarning, } from './types.js';\n// Because of the way we detect blocking stylesheets, asynchronously loaded\n// CSS with link[rel=preload] and an onload handler (see https://github.com/filamentgroup/loadCSS)\n// can be falsely flagged as blocking. Therefore, ignore stylesheets that loaded fast enough\n// to possibly be non-blocking (and they have minimal impact anyway).\nconst MINIMUM_WASTED_MS = 50;\nexport function deps() {\n    return ['NetworkRequests', 'PageLoadMetrics', 'LargestImagePaint'];\n}\n/**\n * Given a simulation's nodeTimings, return an object with the nodes/timing keyed by network URL\n */\nfunction getNodesAndTimingByRequestId(nodeTimings) {\n    const requestIdToNode = new Map();\n    for (const [node, nodeTiming] of nodeTimings) {\n        if (node.type !== 'network') {\n            continue;\n        }\n        requestIdToNode.set(node.request.requestId, { node, nodeTiming });\n    }\n    return requestIdToNode;\n}\nfunction estimateSavingsWithGraphs(deferredIds, lanternContext) {\n    const simulator = lanternContext.simulator;\n    const fcpGraph = lanternContext.metrics.firstContentfulPaint.optimisticGraph;\n    const { nodeTimings } = lanternContext.simulator.simulate(fcpGraph);\n    const adjustedNodeTimings = new Map(nodeTimings);\n    const totalChildNetworkBytes = 0;\n    const minimalFCPGraph = fcpGraph.cloneWithRelationships(node => {\n        // If a node can be deferred, exclude it from the new FCP graph\n        const canDeferRequest = deferredIds.has(node.id);\n        return !canDeferRequest;\n    });\n    if (minimalFCPGraph.type !== 'network') {\n        throw new Error('minimalFCPGraph not a NetworkNode');\n    }\n    // Recalculate the \"before\" time based on our adjusted node timings.\n    const estimateBeforeInline = Math.max(...Array.from(Array.from(adjustedNodeTimings).map(timing => timing[1].endTime)));\n    // Add the inlined bytes to the HTML response\n    const originalTransferSize = minimalFCPGraph.request.transferSize;\n    const safeTransferSize = originalTransferSize || 0;\n    minimalFCPGraph.request.transferSize = safeTransferSize + totalChildNetworkBytes;\n    const estimateAfterInline = simulator.simulate(minimalFCPGraph).timeInMs;\n    minimalFCPGraph.request.transferSize = originalTransferSize;\n    return Math.round(Math.max(estimateBeforeInline - estimateAfterInline, 0));\n}\nfunction hasImageLCP(parsedTrace, context) {\n    const frameMetrics = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(context.frameId);\n    if (!frameMetrics) {\n        throw new Error('no frame metrics');\n    }\n    const navMetrics = frameMetrics.get(context.navigationId);\n    if (!navMetrics) {\n        throw new Error('no navigation metrics');\n    }\n    const metricScore = navMetrics.get(\"LCP\" /* Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP */);\n    const lcpEvent = metricScore?.event;\n    if (!lcpEvent || !Types.Events.isLargestContentfulPaintCandidate(lcpEvent)) {\n        return false;\n    }\n    return findLCPRequest(parsedTrace, context, lcpEvent) !== null;\n}\nfunction computeSavings(parsedTrace, context, renderBlockingRequests) {\n    if (!context.lantern) {\n        return;\n    }\n    const nodesAndTimingsByRequestId = getNodesAndTimingByRequestId(context.lantern.metrics.firstContentfulPaint.optimisticEstimate.nodeTimings);\n    const metricSavings = { FCP: 0, LCP: 0 };\n    const requestIdToWastedMs = new Map();\n    const deferredNodeIds = new Set();\n    for (const request of renderBlockingRequests) {\n        const nodeAndTiming = nodesAndTimingsByRequestId.get(request.args.data.requestId);\n        if (!nodeAndTiming) {\n            continue;\n        }\n        const { node, nodeTiming } = nodeAndTiming;\n        // Mark this node and all its dependents as deferrable\n        node.traverse(node => deferredNodeIds.add(node.id));\n        // \"wastedMs\" is the download time of the network request, responseReceived - requestSent\n        const wastedMs = Math.round(nodeTiming.duration);\n        if (wastedMs < MINIMUM_WASTED_MS) {\n            continue;\n        }\n        requestIdToWastedMs.set(node.id, wastedMs);\n    }\n    if (requestIdToWastedMs.size) {\n        metricSavings.FCP = estimateSavingsWithGraphs(deferredNodeIds, context.lantern);\n        // In most cases, render blocking resources only affect LCP if LCP isn't an image.\n        if (!hasImageLCP(parsedTrace, context)) {\n            metricSavings.LCP = metricSavings.FCP;\n        }\n    }\n    return { metricSavings, requestIdToWastedMs };\n}\nexport function generateInsight(parsedTrace, context) {\n    if (!context.navigation) {\n        return {\n            renderBlockingRequests: [],\n        };\n    }\n    const firstPaintTs = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(context.frameId)\n        ?.get(context.navigationId)\n        ?.get(\"FP\" /* Handlers.ModelHandlers.PageLoadMetrics.MetricName.FP */)\n        ?.event?.ts;\n    if (!firstPaintTs) {\n        return {\n            renderBlockingRequests: [],\n            warnings: [InsightWarning.NO_FP],\n        };\n    }\n    let renderBlockingRequests = [];\n    for (const req of parsedTrace.NetworkRequests.byTime) {\n        if (req.args.data.frame !== context.frameId) {\n            continue;\n        }\n        if (!Helpers.Network.isSyntheticNetworkRequestEventRenderBlocking(req)) {\n            continue;\n        }\n        if (req.args.data.syntheticData.finishTime > firstPaintTs) {\n            continue;\n        }\n        // If a request is marked `in_body_parser_blocking` it should only be considered render blocking if it is a\n        // high enough priority. Some requests (e.g. scripts) are not marked as high priority if they are fetched\n        // after a non-preloaded image. (See \"early\" definition in https://web.dev/articles/fetch-priority)\n        //\n        // There are edge cases and exceptions (e.g. priority hints) but this gives us the best approximation\n        // of render blocking resources in the document body.\n        if (req.args.data.renderBlocking === 'in_body_parser_blocking') {\n            const priority = req.args.data.priority;\n            const isScript = req.args.data.resourceType === \"Script\" /* Protocol.Network.ResourceType.Script */;\n            const isBlockingScript = isScript && priority === \"High\" /* Protocol.Network.ResourcePriority.High */;\n            if (priority !== \"VeryHigh\" /* Protocol.Network.ResourcePriority.VeryHigh */ && !isBlockingScript) {\n                continue;\n            }\n        }\n        const navigation = Helpers.Trace.getNavigationForTraceEvent(req, context.frameId, parsedTrace.Meta.navigationsByFrameId);\n        if (navigation === context.navigation) {\n            renderBlockingRequests.push(req);\n        }\n    }\n    const savings = computeSavings(parsedTrace, context, renderBlockingRequests);\n    // Sort by request duration for insights.\n    renderBlockingRequests = renderBlockingRequests.sort((a, b) => {\n        return b.dur - a.dur;\n    });\n    return {\n        relatedEvents: renderBlockingRequests,\n        renderBlockingRequests,\n        ...savings,\n    };\n}\n//# sourceMappingURL=RenderBlocking.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport { SelectorTimingsKey } from '../types/TraceEvents.js';\nimport * as Types from '../types/types.js';\nexport function deps() {\n    return ['SelectorStats'];\n}\nfunction aggregateSelectorStats(data, context) {\n    const selectorMap = new Map();\n    for (const [event, value] of data) {\n        if (event.args.beginData?.frame !== context.frameId) {\n            continue;\n        }\n        if (!Helpers.Timing.eventIsInBounds(event, context.bounds)) {\n            continue;\n        }\n        for (const timing of value.timings) {\n            const key = timing[SelectorTimingsKey.Selector] + '_' + timing[SelectorTimingsKey.StyleSheetId];\n            const findTiming = selectorMap.get(key);\n            if (findTiming !== undefined) {\n                findTiming[SelectorTimingsKey.Elapsed] += timing[SelectorTimingsKey.Elapsed];\n                findTiming[SelectorTimingsKey.FastRejectCount] += timing[SelectorTimingsKey.FastRejectCount];\n                findTiming[SelectorTimingsKey.MatchAttempts] += timing[SelectorTimingsKey.MatchAttempts];\n                findTiming[SelectorTimingsKey.MatchCount] += timing[SelectorTimingsKey.MatchCount];\n            }\n            else {\n                selectorMap.set(key, { ...timing });\n            }\n        }\n    }\n    return [...selectorMap.values()];\n}\nexport function generateInsight(parsedTrace, context) {\n    const selectorStatsData = parsedTrace.SelectorStats;\n    if (!selectorStatsData) {\n        throw new Error('no selector stats data');\n    }\n    const selectorTimings = aggregateSelectorStats(selectorStatsData.dataForUpdateLayoutEvent, context);\n    let totalElapsedUs = 0;\n    let totalMatchAttempts = 0;\n    let totalMatchCount = 0;\n    selectorTimings.map(timing => {\n        totalElapsedUs += timing[SelectorTimingsKey.Elapsed];\n        totalMatchAttempts += timing[SelectorTimingsKey.MatchAttempts];\n        totalMatchCount += timing[SelectorTimingsKey.MatchCount];\n    });\n    // sort by elapsed time\n    const sortByElapsedMs = selectorTimings.toSorted((a, b) => {\n        return b[SelectorTimingsKey.Elapsed] - a[SelectorTimingsKey.Elapsed];\n    });\n    // sort by match attempts\n    const sortByMatchAttempts = selectorTimings.toSorted((a, b) => {\n        return b[SelectorTimingsKey.MatchAttempts] - a[SelectorTimingsKey.MatchAttempts];\n    });\n    return {\n        // TODO: should we identify UpdateLayout events as linked to this insight?\n        relatedEvents: [],\n        totalElapsedMs: Types.Timing.MilliSeconds(totalElapsedUs / 1000.0),\n        totalMatchAttempts,\n        totalMatchCount,\n        topElapsedMs: sortByElapsedMs.slice(0, 3),\n        topMatchAttempts: sortByMatchAttempts.slice(0, 3),\n    };\n}\n//# sourceMappingURL=SlowCSSSelector.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as ThirdPartyWeb from '../../../third_party/third-party-web/third-party-web.js';\nimport * as Extras from '../extras/extras.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\nexport function deps() {\n    return ['Meta', 'NetworkRequests', 'Renderer', 'ImagePainting'];\n}\n/**\n * Returns the origin portion of a Chrome extension URL.\n */\nfunction getChromeExtensionOrigin(url) {\n    return url.protocol + '//' + url.host;\n}\nfunction makeUpChromeExtensionEntity(entityCache, url, extensionName) {\n    const parsedUrl = new URL(url);\n    const origin = getChromeExtensionOrigin(parsedUrl);\n    const host = new URL(origin).host;\n    const name = extensionName || host;\n    const cachedEntity = entityCache.get(origin);\n    if (cachedEntity) {\n        return cachedEntity;\n    }\n    const chromeExtensionEntity = {\n        name,\n        company: name,\n        category: 'Chrome Extension',\n        homepage: 'https://chromewebstore.google.com/detail/' + host,\n        categories: [],\n        domains: [],\n        averageExecutionTime: 0,\n        totalExecutionTime: 0,\n        totalOccurrences: 0,\n    };\n    entityCache.set(origin, chromeExtensionEntity);\n    return chromeExtensionEntity;\n}\nfunction makeUpEntity(entityCache, url) {\n    if (url.startsWith('chrome-extension:')) {\n        return makeUpChromeExtensionEntity(entityCache, url);\n    }\n    // Make up an entity only for valid http/https URLs.\n    if (!url.startsWith('http')) {\n        return;\n    }\n    // NOTE: Lighthouse uses a tld database to determine the root domain, but here\n    // we are using third party web's database. Doesn't really work for the case of classifying\n    // domains 3pweb doesn't know about, so it will just give us a guess.\n    const rootDomain = ThirdPartyWeb.ThirdPartyWeb.getRootDomain(url);\n    if (!rootDomain) {\n        return;\n    }\n    if (entityCache.has(rootDomain)) {\n        return entityCache.get(rootDomain);\n    }\n    const unrecognizedEntity = {\n        name: rootDomain,\n        company: rootDomain,\n        category: '',\n        categories: [],\n        domains: [rootDomain],\n        averageExecutionTime: 0,\n        totalExecutionTime: 0,\n        totalOccurrences: 0,\n        isUnrecognized: true,\n    };\n    entityCache.set(rootDomain, unrecognizedEntity);\n    return unrecognizedEntity;\n}\nfunction getSelfTimeByUrl(parsedTrace, context) {\n    const selfTimeByUrl = new Map();\n    for (const process of parsedTrace.Renderer.processes.values()) {\n        if (!process.isOnMainFrame) {\n            continue;\n        }\n        for (const thread of process.threads.values()) {\n            if (thread.name === 'CrRendererMain') {\n                if (!thread.tree) {\n                    break;\n                }\n                for (const event of thread.entries) {\n                    if (!Helpers.Timing.eventIsInBounds(event, context.bounds)) {\n                        continue;\n                    }\n                    const node = parsedTrace.Renderer.entryToNode.get(event);\n                    if (!node || !node.selfTime) {\n                        continue;\n                    }\n                    const url = Extras.URLForEntry.getNonResolved(parsedTrace, event);\n                    if (!url) {\n                        continue;\n                    }\n                    selfTimeByUrl.set(url, node.selfTime + (selfTimeByUrl.get(url) ?? 0));\n                }\n            }\n        }\n    }\n    return selfTimeByUrl;\n}\nfunction getSummaries(requests, entityByRequest, selfTimeByUrl) {\n    const byRequest = new Map();\n    const byEntity = new Map();\n    const defaultSummary = { transferSize: 0, mainThreadTime: Types.Timing.MicroSeconds(0) };\n    for (const request of requests) {\n        const urlSummary = byRequest.get(request) || { ...defaultSummary };\n        urlSummary.transferSize += request.args.data.encodedDataLength;\n        urlSummary.mainThreadTime =\n            Types.Timing.MicroSeconds(urlSummary.mainThreadTime + (selfTimeByUrl.get(request.args.data.url) ?? 0));\n        byRequest.set(request, urlSummary);\n    }\n    // Map each request's stat to a particular entity.\n    const requestsByEntity = new Map();\n    for (const [request, requestSummary] of byRequest.entries()) {\n        const entity = entityByRequest.get(request);\n        if (!entity) {\n            byRequest.delete(request);\n            continue;\n        }\n        const entitySummary = byEntity.get(entity) || { ...defaultSummary };\n        entitySummary.transferSize += requestSummary.transferSize;\n        entitySummary.mainThreadTime =\n            Types.Timing.MicroSeconds(entitySummary.mainThreadTime + requestSummary.mainThreadTime);\n        byEntity.set(entity, entitySummary);\n        const entityRequests = requestsByEntity.get(entity) || [];\n        entityRequests.push(request);\n        requestsByEntity.set(entity, entityRequests);\n    }\n    return { byEntity, byRequest, requestsByEntity };\n}\nfunction getRelatedEvents(summaries, firstPartyEntity) {\n    const events = [];\n    for (const [entity, requests] of summaries.requestsByEntity.entries()) {\n        if (entity !== firstPartyEntity) {\n            events.push(...requests);\n        }\n    }\n    return events;\n}\nexport function generateInsight(parsedTrace, context) {\n    const networkRequests = parsedTrace.NetworkRequests.byTime.filter(event => {\n        if (!context.navigation) {\n            return false;\n        }\n        if (event.args.data.frame !== context.frameId) {\n            return false;\n        }\n        return Helpers.Timing.eventIsInBounds(event, context.bounds);\n    });\n    const entityByRequest = new Map();\n    const madeUpEntityCache = new Map();\n    for (const request of networkRequests) {\n        const url = request.args.data.url;\n        const entity = ThirdPartyWeb.ThirdPartyWeb.getEntity(url) ?? makeUpEntity(madeUpEntityCache, url);\n        if (entity) {\n            entityByRequest.set(request, entity);\n        }\n    }\n    const selfTimeByUrl = getSelfTimeByUrl(parsedTrace, context);\n    // TODO(crbug.com/352244718): re-work to still collect main thread activity if no request is present\n    const summaries = getSummaries(networkRequests, entityByRequest, selfTimeByUrl);\n    const firstPartyUrl = context.navigation?.args.data?.documentLoaderURL ?? parsedTrace.Meta.mainFrameURL;\n    const firstPartyEntity = ThirdPartyWeb.ThirdPartyWeb.getEntity(firstPartyUrl) || makeUpEntity(madeUpEntityCache, firstPartyUrl);\n    return {\n        relatedEvents: getRelatedEvents(summaries, firstPartyEntity),\n        entityByRequest,\n        requestsByEntity: summaries.requestsByEntity,\n        summaryByRequest: summaries.byRequest,\n        summaryByEntity: summaries.byEntity,\n        firstPartyEntity,\n    };\n}\n//# sourceMappingURL=ThirdPartyWeb.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Helpers from '../helpers/helpers.js';\nimport { InsightWarning } from './types.js';\nexport function deps() {\n    return ['Meta', 'UserInteractions'];\n}\nexport function generateInsight(parsedTrace, context) {\n    const compositorEvents = parsedTrace.UserInteractions.beginCommitCompositorFrameEvents.filter(event => {\n        if (event.args.frame !== context.frameId) {\n            return false;\n        }\n        return Helpers.Timing.eventIsInBounds(event, context.bounds);\n    });\n    if (!compositorEvents.length) {\n        // Trace doesn't have the data we need.\n        return {\n            mobileOptimized: null,\n            warnings: [InsightWarning.NO_LAYOUT],\n        };\n    }\n    const viewportEvent = parsedTrace.UserInteractions.parseMetaViewportEvents.find(event => {\n        if (event.args.data.frame !== context.frameId) {\n            return false;\n        }\n        return Helpers.Timing.eventIsInBounds(event, context.bounds);\n    });\n    // Returns true only if all events are mobile optimized.\n    for (const event of compositorEvents) {\n        if (!event.args.is_mobile_optimized) {\n            return {\n                mobileOptimized: false,\n                viewportEvent,\n                metricSavings: { INP: 300 },\n            };\n        }\n    }\n    return {\n        mobileOptimized: true,\n        viewportEvent,\n    };\n}\n//# sourceMappingURL=Viewport.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nclass LanternError extends Error {\n}\nexport { LanternError };\n//# sourceMappingURL=LanternError.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport { LanternError } from './LanternError.js';\nclass UrlUtils {\n    /**\n     * There is fancy URL rewriting logic for the chrome://settings page that we need to work around.\n     * Why? Special handling was added by Chrome team to allow a pushState transition between chrome:// pages.\n     * As a result, the network URL (chrome://chrome/settings/) doesn't match the final document URL (chrome://settings/).\n     */\n    static rewriteChromeInternalUrl(url) {\n        if (!url || !url.startsWith('chrome://')) {\n            return url;\n        }\n        // Chrome adds a trailing slash to `chrome://` URLs, but the spec does not.\n        //   https://github.com/GoogleChrome/lighthouse/pull/3941#discussion_r154026009\n        if (url.endsWith('/')) {\n            url = url.replace(/\\/$/, '');\n        }\n        return url.replace(/^chrome:\\/\\/chrome\\//, 'chrome://');\n    }\n    /**\n     * Determine if url1 equals url2, ignoring URL fragments.\n     */\n    static equalWithExcludedFragments(url1, url2) {\n        [url1, url2] = [url1, url2].map(this.rewriteChromeInternalUrl);\n        try {\n            const urla = new URL(url1);\n            urla.hash = '';\n            const urlb = new URL(url2);\n            urlb.hash = '';\n            return urla.href === urlb.href;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n}\nconst INITIAL_CWD = 14 * 1024;\n// Assume that 40% of TTFB was server response time by default for static assets\nconst DEFAULT_SERVER_RESPONSE_PERCENTAGE = 0.4;\n/**\n * For certain resource types, server response time takes up a greater percentage of TTFB (dynamic\n * assets like HTML documents, XHR/API calls, etc)\n */\nconst SERVER_RESPONSE_PERCENTAGE_OF_TTFB = {\n    Document: 0.9,\n    XHR: 0.9,\n    Fetch: 0.9,\n};\nclass NetworkAnalyzer {\n    static get summary() {\n        return '__SUMMARY__';\n    }\n    static groupByOrigin(records) {\n        const grouped = new Map();\n        records.forEach(item => {\n            const key = item.parsedURL.securityOrigin;\n            const group = grouped.get(key) || [];\n            group.push(item);\n            grouped.set(key, group);\n        });\n        return grouped;\n    }\n    static getSummary(values) {\n        values.sort((a, b) => a - b);\n        let median;\n        if (values.length === 0) {\n            median = values[0];\n        }\n        else if (values.length % 2 === 0) {\n            const a = values[Math.floor((values.length - 1) / 2)];\n            const b = values[Math.floor((values.length - 1) / 2) + 1];\n            median = (a + b) / 2;\n        }\n        else {\n            median = values[Math.floor((values.length - 1) / 2)];\n        }\n        return {\n            min: values[0],\n            max: values[values.length - 1],\n            avg: values.reduce((a, b) => a + b, 0) / values.length,\n            median,\n        };\n    }\n    static summarize(values) {\n        const summaryByKey = new Map();\n        const allEstimates = [];\n        for (const [key, estimates] of values) {\n            summaryByKey.set(key, NetworkAnalyzer.getSummary(estimates));\n            allEstimates.push(...estimates);\n        }\n        summaryByKey.set(NetworkAnalyzer.summary, NetworkAnalyzer.getSummary(allEstimates));\n        return summaryByKey;\n    }\n    static estimateValueByOrigin(requests, iteratee) {\n        const connectionWasReused = NetworkAnalyzer.estimateIfConnectionWasReused(requests);\n        const groupedByOrigin = NetworkAnalyzer.groupByOrigin(requests);\n        const estimates = new Map();\n        for (const [origin, originRequests] of groupedByOrigin.entries()) {\n            let originEstimates = [];\n            for (const request of originRequests) {\n                const timing = request.timing;\n                if (!timing) {\n                    continue;\n                }\n                const value = iteratee({\n                    request,\n                    timing,\n                    connectionReused: connectionWasReused.get(request.requestId),\n                });\n                if (typeof value !== 'undefined') {\n                    originEstimates = originEstimates.concat(value);\n                }\n            }\n            if (!originEstimates.length) {\n                continue;\n            }\n            estimates.set(origin, originEstimates);\n        }\n        return estimates;\n    }\n    /**\n     * Estimates the observed RTT to each origin based on how long the connection setup.\n     * For h1 and h2, this could includes two estimates - one for the TCP handshake, another for\n     * SSL negotiation.\n     * For h3, we get only one estimate since QUIC establishes a secure connection in a\n     * single handshake.\n     * This is the most accurate and preferred method of measurement when the data is available.\n     */\n    static estimateRTTViaConnectionTiming(info) {\n        const { timing, connectionReused, request } = info;\n        if (connectionReused) {\n            return;\n        }\n        const { connectStart, sslStart, sslEnd, connectEnd } = timing;\n        if (connectEnd >= 0 && connectStart >= 0 && request.protocol.startsWith('h3')) {\n            // These values are equal to sslStart and sslEnd for h3.\n            return connectEnd - connectStart;\n        }\n        if (sslStart >= 0 && sslEnd >= 0 && sslStart !== connectStart) {\n            // SSL can also be more than 1 RT but assume False Start was used.\n            return [connectEnd - sslStart, sslStart - connectStart];\n        }\n        if (connectStart >= 0 && connectEnd >= 0) {\n            return connectEnd - connectStart;\n        }\n        return;\n    }\n    /**\n     * Estimates the observed RTT to each origin based on how long a download took on a fresh connection.\n     * NOTE: this will tend to overestimate the actual RTT quite significantly as the download can be\n     * slow for other reasons as well such as bandwidth constraints.\n     */\n    static estimateRTTViaDownloadTiming(info) {\n        const { timing, connectionReused, request } = info;\n        if (connectionReused) {\n            return;\n        }\n        // Only look at downloads that went past the initial congestion window\n        if (request.transferSize <= INITIAL_CWD) {\n            return;\n        }\n        if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n            return;\n        }\n        // Compute the amount of time downloading everything after the first congestion window took\n        const totalTime = request.networkEndTime - request.networkRequestTime;\n        const downloadTimeAfterFirstByte = totalTime - timing.receiveHeadersEnd;\n        const numberOfRoundTrips = Math.log2(request.transferSize / INITIAL_CWD);\n        // Ignore requests that required a high number of round trips since bandwidth starts to play\n        // a larger role than latency\n        if (numberOfRoundTrips > 5) {\n            return;\n        }\n        return downloadTimeAfterFirstByte / numberOfRoundTrips;\n    }\n    /**\n     * Estimates the observed RTT to each origin based on how long it took until Chrome could\n     * start sending the actual request when a new connection was required.\n     * NOTE: this will tend to overestimate the actual RTT as the request can be delayed for other\n     * reasons as well such as more SSL handshakes if TLS False Start is not enabled.\n     */\n    static estimateRTTViaSendStartTiming(info) {\n        const { timing, connectionReused, request } = info;\n        if (connectionReused) {\n            return;\n        }\n        if (!Number.isFinite(timing.sendStart) || timing.sendStart < 0) {\n            return;\n        }\n        // Assume everything before sendStart was just DNS + (SSL)? + TCP handshake\n        // 1 RT for DNS, 1 RT (maybe) for SSL, 1 RT for TCP\n        let roundTrips = 1;\n        // TCP\n        if (!request.protocol.startsWith('h3')) {\n            roundTrips += 1;\n        }\n        if (request.parsedURL.scheme === 'https') {\n            roundTrips += 1;\n        }\n        return timing.sendStart / roundTrips;\n    }\n    /**\n     * Estimates the observed RTT to each origin based on how long it took until Chrome received the\n     * headers of the response (~TTFB).\n     * NOTE: this is the most inaccurate way to estimate the RTT, but in some environments it's all\n     * we have access to :(\n     */\n    static estimateRTTViaHeadersEndTiming(info) {\n        const { timing, connectionReused, request } = info;\n        if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n            return;\n        }\n        if (!request.resourceType) {\n            return;\n        }\n        const serverResponseTimePercentage = SERVER_RESPONSE_PERCENTAGE_OF_TTFB[request.resourceType] || DEFAULT_SERVER_RESPONSE_PERCENTAGE;\n        const estimatedServerResponseTime = timing.receiveHeadersEnd * serverResponseTimePercentage;\n        // When connection was reused...\n        // TTFB = 1 RT for request + server response time\n        let roundTrips = 1;\n        // When connection was fresh...\n        // TTFB = DNS + (SSL)? + TCP handshake + 1 RT for request + server response time\n        if (!connectionReused) {\n            roundTrips += 1; // DNS\n            if (!request.protocol.startsWith('h3')) {\n                roundTrips += 1; // TCP\n            }\n            if (request.parsedURL.scheme === 'https') {\n                roundTrips += 1; // SSL\n            }\n        }\n        // subtract out our estimated server response time\n        return Math.max((timing.receiveHeadersEnd - estimatedServerResponseTime) / roundTrips, 3);\n    }\n    /**\n     * Given the RTT to each origin, estimates the observed server response times.\n     */\n    static estimateResponseTimeByOrigin(records, rttByOrigin) {\n        return NetworkAnalyzer.estimateValueByOrigin(records, ({ request, timing }) => {\n            if (request.serverResponseTime !== undefined) {\n                return request.serverResponseTime;\n            }\n            if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) {\n                return;\n            }\n            if (!Number.isFinite(timing.sendEnd) || timing.sendEnd < 0) {\n                return;\n            }\n            const ttfb = timing.receiveHeadersEnd - timing.sendEnd;\n            const origin = request.parsedURL.securityOrigin;\n            const rtt = rttByOrigin.get(origin) || rttByOrigin.get(NetworkAnalyzer.summary) || 0;\n            return Math.max(ttfb - rtt, 0);\n        });\n    }\n    static canTrustConnectionInformation(requests) {\n        const connectionIdWasStarted = new Map();\n        for (const request of requests) {\n            const started = connectionIdWasStarted.get(request.connectionId) || !request.connectionReused;\n            connectionIdWasStarted.set(request.connectionId, started);\n        }\n        // We probably can't trust the network information if all the connection IDs were the same\n        if (connectionIdWasStarted.size <= 1) {\n            return false;\n        }\n        // Or if there were connections that were always reused (a connection had to have started at some point)\n        return Array.from(connectionIdWasStarted.values()).every(started => started);\n    }\n    /**\n     * Returns a map of requestId -> connectionReused, estimating the information if the information\n     * available in the records themselves appears untrustworthy.\n     */\n    static estimateIfConnectionWasReused(records, options) {\n        const { forceCoarseEstimates = false } = options || {};\n        // Check if we can trust the connection information coming from the protocol\n        if (!forceCoarseEstimates && NetworkAnalyzer.canTrustConnectionInformation(records)) {\n            return new Map(records.map(request => [request.requestId, Boolean(request.connectionReused)]));\n        }\n        // Otherwise we're on our own, a request may not have needed a fresh connection if...\n        //   - It was not the first request to the domain\n        //   - It was H2\n        //   - It was after the first request to the domain ended\n        const connectionWasReused = new Map();\n        const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);\n        for (const originRecords of groupedByOrigin.values()) {\n            const earliestReusePossible = originRecords.map(request => request.networkEndTime).reduce((a, b) => Math.min(a, b), Infinity);\n            for (const request of originRecords) {\n                connectionWasReused.set(request.requestId, request.networkRequestTime >= earliestReusePossible || request.protocol === 'h2');\n            }\n            const firstRecord = originRecords.reduce((a, b) => {\n                return a.networkRequestTime > b.networkRequestTime ? b : a;\n            });\n            connectionWasReused.set(firstRecord.requestId, false);\n        }\n        return connectionWasReused;\n    }\n    /**\n     * Estimates the RTT to each origin by examining observed network timing information.\n     * Attempts to use the most accurate information first and falls back to coarser estimates when it\n     * is unavailable.\n     */\n    static estimateRTTByOrigin(records, options) {\n        const { forceCoarseEstimates = false, \n        // coarse estimates include lots of extra time and noise\n        // multiply by some factor to deflate the estimates a bit.\n        coarseEstimateMultiplier = 0.3, useDownloadEstimates = true, useSendStartEstimates = true, useHeadersEndEstimates = true, } = options || {};\n        const connectionWasReused = NetworkAnalyzer.estimateIfConnectionWasReused(records);\n        const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);\n        const estimatesByOrigin = new Map();\n        for (const [origin, originRequests] of groupedByOrigin.entries()) {\n            const originEstimates = [];\n            // eslint-disable-next-line no-inner-declarations\n            function collectEstimates(estimator, multiplier = 1) {\n                for (const request of originRequests) {\n                    const timing = request.timing;\n                    if (!timing) {\n                        continue;\n                    }\n                    const estimates = estimator({\n                        request,\n                        timing,\n                        connectionReused: connectionWasReused.get(request.requestId),\n                    });\n                    if (estimates === undefined) {\n                        continue;\n                    }\n                    if (!Array.isArray(estimates)) {\n                        originEstimates.push(estimates * multiplier);\n                    }\n                    else {\n                        originEstimates.push(...estimates.map(e => e * multiplier));\n                    }\n                }\n            }\n            if (!forceCoarseEstimates) {\n                collectEstimates(this.estimateRTTViaConnectionTiming);\n            }\n            // Connection timing can be missing for a few reasons:\n            // - Origin was preconnected, which we don't have instrumentation for.\n            // - Trace began recording after a connection has already been established (for example, in timespan mode)\n            // - Perhaps Chrome established a connection already in the background (service worker? Just guessing here)\n            // - Not provided in LR netstack.\n            if (!originEstimates.length) {\n                if (useDownloadEstimates) {\n                    collectEstimates(this.estimateRTTViaDownloadTiming, coarseEstimateMultiplier);\n                }\n                if (useSendStartEstimates) {\n                    collectEstimates(this.estimateRTTViaSendStartTiming, coarseEstimateMultiplier);\n                }\n                if (useHeadersEndEstimates) {\n                    collectEstimates(this.estimateRTTViaHeadersEndTiming, coarseEstimateMultiplier);\n                }\n            }\n            if (originEstimates.length) {\n                estimatesByOrigin.set(origin, originEstimates);\n            }\n        }\n        if (!estimatesByOrigin.size) {\n            throw new LanternError('No timing information available');\n        }\n        return NetworkAnalyzer.summarize(estimatesByOrigin);\n    }\n    /**\n     * Estimates the server response time of each origin. RTT times can be passed in or will be\n     * estimated automatically if not provided.\n     */\n    static estimateServerResponseTimeByOrigin(records, options) {\n        let rttByOrigin = (options || {}).rttByOrigin;\n        if (!rttByOrigin) {\n            rttByOrigin = new Map();\n            const rttSummaryByOrigin = NetworkAnalyzer.estimateRTTByOrigin(records, options);\n            for (const [origin, summary] of rttSummaryByOrigin.entries()) {\n                rttByOrigin.set(origin, summary.min);\n            }\n        }\n        const estimatesByOrigin = NetworkAnalyzer.estimateResponseTimeByOrigin(records, rttByOrigin);\n        return NetworkAnalyzer.summarize(estimatesByOrigin);\n    }\n    /**\n     * Computes the average throughput for the given requests in bits/second.\n     * Excludes data URI, failed or otherwise incomplete, and cached requests.\n     * Returns Infinity if there were no analyzable network requests.\n     */\n    static estimateThroughput(records) {\n        let totalBytes = 0;\n        // We will measure throughput by summing the total bytes downloaded by the total time spent\n        // downloading those bytes. We slice up all the network requests into start/end boundaries, so\n        // it's easier to deal with the gaps in downloading.\n        const timeBoundaries = records\n            .reduce((boundaries, request) => {\n            const scheme = request.parsedURL?.scheme;\n            // Requests whose bodies didn't come over the network or didn't completely finish will mess\n            // with the computation, just skip over them.\n            if (scheme === 'data' || request.failed || !request.finished ||\n                request.statusCode > 300 || !request.transferSize) {\n                return boundaries;\n            }\n            // If we've made it this far, all the times we need should be valid (i.e. not undefined/-1).\n            totalBytes += request.transferSize;\n            boundaries.push({ time: request.responseHeadersEndTime / 1000, isStart: true });\n            boundaries.push({ time: request.networkEndTime / 1000, isStart: false });\n            return boundaries;\n        }, [])\n            .sort((a, b) => a.time - b.time);\n        if (!timeBoundaries.length) {\n            return Infinity;\n        }\n        let inflight = 0;\n        let currentStart = 0;\n        let totalDuration = 0;\n        timeBoundaries.forEach(boundary => {\n            if (boundary.isStart) {\n                if (inflight === 0) {\n                    // We just ended a quiet period, keep track of when the download period started\n                    currentStart = boundary.time;\n                }\n                inflight++;\n            }\n            else {\n                inflight--;\n                if (inflight === 0) {\n                    // We just entered a quiet period, update our duration with the time we spent downloading\n                    totalDuration += boundary.time - currentStart;\n                }\n            }\n        });\n        return totalBytes * 8 / totalDuration;\n    }\n    static computeRTTAndServerResponseTime(records) {\n        // First pass compute the estimated observed RTT to each origin's servers.\n        const rttByOrigin = new Map();\n        for (const [origin, summary] of NetworkAnalyzer.estimateRTTByOrigin(records).entries()) {\n            rttByOrigin.set(origin, summary.min);\n        }\n        // We'll use the minimum RTT as the assumed connection latency since we care about how much addt'l\n        // latency each origin introduces as Lantern will be simulating with its own connection latency.\n        const minimumRtt = Math.min(...Array.from(rttByOrigin.values()));\n        // We'll use the observed RTT information to help estimate the server response time\n        const responseTimeSummaries = NetworkAnalyzer.estimateServerResponseTimeByOrigin(records, {\n            rttByOrigin,\n        });\n        const additionalRttByOrigin = new Map();\n        const serverResponseTimeByOrigin = new Map();\n        for (const [origin, summary] of responseTimeSummaries.entries()) {\n            // Not all origins have usable timing data, we'll default to using no additional latency.\n            const rttForOrigin = rttByOrigin.get(origin) || minimumRtt;\n            additionalRttByOrigin.set(origin, rttForOrigin - minimumRtt);\n            serverResponseTimeByOrigin.set(origin, summary.median);\n        }\n        return {\n            rtt: minimumRtt,\n            additionalRttByOrigin,\n            serverResponseTimeByOrigin,\n        };\n    }\n    static analyze(records) {\n        const throughput = NetworkAnalyzer.estimateThroughput(records);\n        return {\n            throughput,\n            ...NetworkAnalyzer.computeRTTAndServerResponseTime(records),\n        };\n    }\n    static findResourceForUrl(records, resourceUrl) {\n        // equalWithExcludedFragments is expensive, so check that the resourceUrl starts with the request url first\n        return records.find(request => resourceUrl.startsWith(request.url) && UrlUtils.equalWithExcludedFragments(request.url, resourceUrl));\n    }\n    static findLastDocumentForUrl(records, resourceUrl) {\n        // equalWithExcludedFragments is expensive, so check that the resourceUrl starts with the request url first\n        const matchingRequests = records.filter(request => request.resourceType === 'Document' &&\n            // Note: `request.url` should never have a fragment, else this optimization gives wrong results.\n            resourceUrl.startsWith(request.url) && UrlUtils.equalWithExcludedFragments(request.url, resourceUrl));\n        return matchingRequests[matchingRequests.length - 1];\n    }\n    /**\n     * Resolves redirect chain given a main document.\n     * See: {@link NetworkAnalyzer.findLastDocumentForUrl} for how to retrieve main document.\n     */\n    static resolveRedirects(request) {\n        while (request.redirectDestination) {\n            request = request.redirectDestination;\n        }\n        return request;\n    }\n}\nexport { NetworkAnalyzer };\n//# sourceMappingURL=NetworkAnalyzer.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\n/**\n * @fileoverview This class encapsulates logic for handling resources and tasks used to model the\n * execution dependency graph of the page. A node has a unique identifier and can depend on other\n * nodes/be depended on. The construction of the graph maintains some important invariants that are\n * inherent to the model:\n *\n *    1. The graph is a DAG, there are no cycles.\n *    2. There is always a root node upon which all other nodes eventually depend.\n *\n * This allows particular optimizations in this class so that we do no need to check for cycles as\n * these methods are called and we can always start traversal at the root node.\n */\nclass BaseNode {\n    static types = {\n        NETWORK: 'network',\n        CPU: 'cpu',\n    };\n    _id;\n    _isMainDocument;\n    dependents;\n    dependencies;\n    constructor(id) {\n        this._id = id;\n        this._isMainDocument = false;\n        this.dependents = [];\n        this.dependencies = [];\n    }\n    get id() {\n        return this._id;\n    }\n    get type() {\n        throw new Core.LanternError('Unimplemented');\n    }\n    /**\n     * In microseconds\n     */\n    get startTime() {\n        throw new Core.LanternError('Unimplemented');\n    }\n    /**\n     * In microseconds\n     */\n    get endTime() {\n        throw new Core.LanternError('Unimplemented');\n    }\n    setIsMainDocument(value) {\n        this._isMainDocument = value;\n    }\n    isMainDocument() {\n        return this._isMainDocument;\n    }\n    getDependents() {\n        return this.dependents.slice();\n    }\n    getNumberOfDependents() {\n        return this.dependents.length;\n    }\n    getDependencies() {\n        return this.dependencies.slice();\n    }\n    getNumberOfDependencies() {\n        return this.dependencies.length;\n    }\n    getRootNode() {\n        let rootNode = this;\n        while (rootNode.dependencies.length) {\n            rootNode = rootNode.dependencies[0];\n        }\n        return rootNode;\n    }\n    addDependent(node) {\n        node.addDependency(this);\n    }\n    addDependency(node) {\n        // @ts-expect-error - in checkJs, ts doesn't know that CPUNode and NetworkNode *are* BaseNodes.\n        if (node === this) {\n            throw new Core.LanternError('Cannot add dependency on itself');\n        }\n        if (this.dependencies.includes(node)) {\n            return;\n        }\n        node.dependents.push(this);\n        this.dependencies.push(node);\n    }\n    removeDependent(node) {\n        node.removeDependency(this);\n    }\n    removeDependency(node) {\n        if (!this.dependencies.includes(node)) {\n            return;\n        }\n        const thisIndex = node.dependents.indexOf(this);\n        node.dependents.splice(thisIndex, 1);\n        this.dependencies.splice(this.dependencies.indexOf(node), 1);\n    }\n    removeAllDependencies() {\n        for (const node of this.dependencies.slice()) {\n            this.removeDependency(node);\n        }\n    }\n    /**\n     * Computes whether the given node is anywhere in the dependency graph of this node.\n     * While this method can prevent cycles, it walks the graph and should be used sparingly.\n     * Nodes are always considered dependent on themselves for the purposes of cycle detection.\n     */\n    isDependentOn(node) {\n        let isDependentOnNode = false;\n        this.traverse(currentNode => {\n            if (isDependentOnNode) {\n                return;\n            }\n            isDependentOnNode = currentNode === node;\n        }, currentNode => {\n            // If we've already found the dependency, don't traverse further.\n            if (isDependentOnNode) {\n                return [];\n            }\n            // Otherwise, traverse the dependencies.\n            return currentNode.getDependencies();\n        });\n        return isDependentOnNode;\n    }\n    /**\n     * Clones the node's information without adding any dependencies/dependents.\n     */\n    cloneWithoutRelationships() {\n        const node = new BaseNode(this.id);\n        node.setIsMainDocument(this._isMainDocument);\n        return node;\n    }\n    /**\n     * Clones the entire graph connected to this node filtered by the optional predicate. If a node is\n     * included by the predicate, all nodes along the paths between the node and the root will be included. If the\n     * node this was called on is not included in the resulting filtered graph, the method will throw.\n     *\n     * This does not clone NetworkNode's `record` or `rawRecord` fields. It may be reasonable to clone the former,\n     * to assist in graph construction, but the latter should never be cloned as one contraint of Lantern is that\n     * the underlying data records are accessible for plain object reference equality checks.\n     */\n    cloneWithRelationships(predicate) {\n        const rootNode = this.getRootNode();\n        const idsToIncludedClones = new Map();\n        // Walk down dependents.\n        rootNode.traverse(node => {\n            if (idsToIncludedClones.has(node.id)) {\n                return;\n            }\n            if (predicate === undefined) {\n                // No condition for entry, so clone every node.\n                idsToIncludedClones.set(node.id, node.cloneWithoutRelationships());\n                return;\n            }\n            if (predicate(node)) {\n                // Node included, so walk back up dependencies, cloning nodes from here back to the root.\n                node.traverse(node => idsToIncludedClones.set(node.id, node.cloneWithoutRelationships()), \n                // Dependencies already cloned have already cloned ancestors, so no need to visit again.\n                node => node.dependencies.filter(parent => !idsToIncludedClones.has(parent.id)));\n            }\n        });\n        // Copy dependencies between nodes.\n        rootNode.traverse(originalNode => {\n            const clonedNode = idsToIncludedClones.get(originalNode.id);\n            if (!clonedNode) {\n                return;\n            }\n            for (const dependency of originalNode.dependencies) {\n                const clonedDependency = idsToIncludedClones.get(dependency.id);\n                if (!clonedDependency) {\n                    throw new Core.LanternError('Dependency somehow not cloned');\n                }\n                clonedNode.addDependency(clonedDependency);\n            }\n        });\n        const clonedThisNode = idsToIncludedClones.get(this.id);\n        if (!clonedThisNode) {\n            throw new Core.LanternError('Cloned graph missing node');\n        }\n        return clonedThisNode;\n    }\n    /**\n     * Traverses all connected nodes in BFS order, calling `callback` exactly once\n     * on each. `traversalPath` is the shortest (though not necessarily unique)\n     * path from `node` to the root of the iteration.\n     *\n     * The `getNextNodes` function takes a visited node and returns which nodes to\n     * visit next. It defaults to returning the node's dependents.\n     */\n    traverse(callback, getNextNodes) {\n        for (const { node, traversalPath } of this.traverseGenerator(getNextNodes)) {\n            callback(node, traversalPath);\n        }\n    }\n    /**\n     * @see BaseNode.traverse\n     */\n    // clang-format off\n    *traverseGenerator(getNextNodes) {\n        // clang-format on\n        if (!getNextNodes) {\n            getNextNodes = node => node.getDependents();\n        }\n        // @ts-expect-error - only traverses graphs of Node, so force tsc to treat `this` as one\n        const queue = [[this]];\n        const visited = new Set([this.id]);\n        while (queue.length) {\n            // @ts-expect-error - queue has length so it's guaranteed to have an item\n            const traversalPath = queue.shift();\n            const node = traversalPath[0];\n            yield { node, traversalPath };\n            for (const nextNode of getNextNodes(node)) {\n                if (visited.has(nextNode.id)) {\n                    continue;\n                }\n                visited.add(nextNode.id);\n                queue.push([nextNode, ...traversalPath]);\n            }\n        }\n    }\n    /**\n     * Returns whether the given node has a cycle in its dependent graph by performing a DFS.\n     */\n    static hasCycle(node, direction = 'both') {\n        // Checking 'both' is the default entrypoint to recursively check both directions\n        if (direction === 'both') {\n            return BaseNode.hasCycle(node, 'dependents') || BaseNode.hasCycle(node, 'dependencies');\n        }\n        const visited = new Set();\n        const currentPath = [];\n        const toVisit = [node];\n        const depthAdded = new Map([[node, 0]]);\n        // Keep going while we have nodes to visit in the stack\n        while (toVisit.length) {\n            // Get the last node in the stack (DFS uses stack, not queue)\n            // @ts-expect-error - toVisit has length so it's guaranteed to have an item\n            const currentNode = toVisit.pop();\n            // We've hit a cycle if the node we're visiting is in our current dependency path\n            if (currentPath.includes(currentNode)) {\n                return true;\n            }\n            // If we've already visited the node, no need to revisit it\n            if (visited.has(currentNode)) {\n                continue;\n            }\n            // Since we're visiting this node, clear out any nodes in our path that we had to backtrack\n            // @ts-expect-error\n            while (currentPath.length > depthAdded.get(currentNode)) {\n                currentPath.pop();\n            }\n            // Update our data structures to reflect that we're adding this node to our path\n            visited.add(currentNode);\n            currentPath.push(currentNode);\n            // Add all of its dependents to our toVisit stack\n            const nodesToExplore = direction === 'dependents' ? currentNode.dependents : currentNode.dependencies;\n            for (const nextNode of nodesToExplore) {\n                if (toVisit.includes(nextNode)) {\n                    continue;\n                }\n                toVisit.push(nextNode);\n                depthAdded.set(nextNode, currentPath.length);\n            }\n        }\n        return false;\n    }\n    canDependOn(node) {\n        return node.startTime <= this.startTime;\n    }\n}\nexport { BaseNode };\n//# sourceMappingURL=BaseNode.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport { BaseNode } from './BaseNode.js';\nclass CPUNode extends BaseNode {\n    _event;\n    _childEvents;\n    correctedEndTs;\n    constructor(parentEvent, childEvents = [], correctedEndTs) {\n        const nodeId = `${parentEvent.tid}.${parentEvent.ts}`;\n        super(nodeId);\n        this._event = parentEvent;\n        this._childEvents = childEvents;\n        this.correctedEndTs = correctedEndTs;\n    }\n    get type() {\n        return BaseNode.types.CPU;\n    }\n    get startTime() {\n        return this._event.ts;\n    }\n    get endTime() {\n        if (this.correctedEndTs) {\n            return this.correctedEndTs;\n        }\n        return this._event.ts + this._event.dur;\n    }\n    get duration() {\n        return this.endTime - this.startTime;\n    }\n    get event() {\n        return this._event;\n    }\n    get childEvents() {\n        return this._childEvents;\n    }\n    /**\n     * Returns true if this node contains a Layout task.\n     */\n    didPerformLayout() {\n        return this._childEvents.some(evt => evt.name === 'Layout');\n    }\n    /**\n     * Returns the script URLs that had their EvaluateScript events occur in this task.\n     */\n    getEvaluateScriptURLs() {\n        const urls = new Set();\n        for (const event of this._childEvents) {\n            if (event.name !== 'EvaluateScript') {\n                continue;\n            }\n            if (!event.args.data || !event.args.data.url) {\n                continue;\n            }\n            urls.add(event.args.data.url);\n        }\n        return urls;\n    }\n    cloneWithoutRelationships() {\n        return new CPUNode(this._event, this._childEvents, this.correctedEndTs);\n    }\n}\nexport { CPUNode };\n//# sourceMappingURL=CPUNode.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport { BaseNode } from './BaseNode.js';\nconst NON_NETWORK_SCHEMES = [\n    'blob', // @see https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n    'data', // @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    'intent', // @see https://developer.chrome.com/docs/multidevice/android/intents/\n    'file', // @see https://en.wikipedia.org/wiki/File_URI_scheme\n    'filesystem', // @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystem\n    'chrome-extension',\n];\n/**\n * Note: the `protocol` field from CDP can be 'h2', 'http', (not 'https'!) or it'll be url's scheme.\n *   https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/network_handler.cc;l=598-611;drc=56d4a9a9deb30be73adcee8737c73bcb2a5ab64f\n * However, a `new URL(href).protocol` has a colon suffix.\n *   https://url.spec.whatwg.org/#dom-url-protocol\n * A URL's `scheme` is specced as the `protocol` sans-colon, but isn't exposed on a URL object.\n * This method can take all 3 of these string types as a parameter.\n *\n * @param protocol Either a networkRequest's `protocol` per CDP or a `new URL(href).protocol`\n */\nfunction isNonNetworkProtocol(protocol) {\n    // Strip off any colon\n    const urlScheme = protocol.includes(':') ? protocol.slice(0, protocol.indexOf(':')) : protocol;\n    return NON_NETWORK_SCHEMES.includes(urlScheme);\n}\nclass NetworkNode extends BaseNode {\n    _request;\n    constructor(networkRequest) {\n        super(networkRequest.requestId);\n        this._request = networkRequest;\n    }\n    get type() {\n        return BaseNode.types.NETWORK;\n    }\n    get startTime() {\n        return this._request.rendererStartTime * 1000;\n    }\n    get endTime() {\n        return this._request.networkEndTime * 1000;\n    }\n    get rawRequest() {\n        return this._request.rawRequest;\n    }\n    get request() {\n        return this._request;\n    }\n    get initiatorType() {\n        return this._request.initiator && this._request.initiator.type;\n    }\n    get fromDiskCache() {\n        return Boolean(this._request.fromDiskCache);\n    }\n    get isNonNetworkProtocol() {\n        // The 'protocol' field in devtools a string more like a `scheme`\n        return isNonNetworkProtocol(this.request.protocol) ||\n            // But `protocol` can fail to be populated if the request fails, so fallback to scheme.\n            isNonNetworkProtocol(this.request.parsedURL.scheme);\n    }\n    /**\n     * Returns whether this network request can be downloaded without a TCP connection.\n     * During simulation we treat data coming in over a network connection separately from on-device data.\n     */\n    get isConnectionless() {\n        return this.fromDiskCache || this.isNonNetworkProtocol;\n    }\n    hasRenderBlockingPriority() {\n        const priority = this._request.priority;\n        const isScript = this._request.resourceType === 'Script';\n        const isDocument = this._request.resourceType === 'Document';\n        const isBlockingScript = priority === 'High' && isScript;\n        const isBlockingHtmlImport = priority === 'High' && isDocument;\n        return priority === 'VeryHigh' || isBlockingScript || isBlockingHtmlImport;\n    }\n    cloneWithoutRelationships() {\n        const node = new NetworkNode(this._request);\n        node.setIsMainDocument(this._isMainDocument);\n        return node;\n    }\n}\nexport { NetworkNode };\n//# sourceMappingURL=NetworkNode.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport { CPUNode } from './CPUNode.js';\nimport { NetworkNode } from './NetworkNode.js';\n// COMPAT: m71+ We added RunTask to `disabled-by-default-lighthouse`\nconst SCHEDULABLE_TASK_TITLE_LH = 'RunTask';\n// m69-70 DoWork is different and we now need RunTask, see https://bugs.chromium.org/p/chromium/issues/detail?id=871204#c11\nconst SCHEDULABLE_TASK_TITLE_ALT1 = 'ThreadControllerImpl::RunTask';\n// In m66-68 refactored to this task title, https://crrev.com/c/883346\nconst SCHEDULABLE_TASK_TITLE_ALT2 = 'ThreadControllerImpl::DoWork';\n// m65 and earlier\nconst SCHEDULABLE_TASK_TITLE_ALT3 = 'TaskQueueManager::ProcessTaskFromWorkQueue';\n// Shorter tasks have negligible impact on simulation results.\nconst SIGNIFICANT_DUR_THRESHOLD_MS = 10;\n// TODO: video files tend to be enormous and throw off all graph traversals, move this ignore\n//    into estimation logic when we use the dependency graph for other purposes.\nconst IGNORED_MIME_TYPES_REGEX = /^video/;\nclass PageDependencyGraph {\n    static getNetworkInitiators(request) {\n        if (!request.initiator) {\n            return [];\n        }\n        if (request.initiator.url) {\n            return [request.initiator.url];\n        }\n        if (request.initiator.type === 'script') {\n            // Script initiators have the stack of callFrames from all functions that led to this request.\n            // If async stacks are enabled, then the stack will also have the parent functions that asynchronously\n            // led to this request chained in the `parent` property.\n            const scriptURLs = new Set();\n            let stack = request.initiator.stack;\n            while (stack) {\n                const callFrames = stack.callFrames || [];\n                for (const frame of callFrames) {\n                    if (frame.url) {\n                        scriptURLs.add(frame.url);\n                    }\n                }\n                stack = stack.parent;\n            }\n            return Array.from(scriptURLs);\n        }\n        return [];\n    }\n    static getNetworkNodeOutput(networkRequests) {\n        const nodes = [];\n        const idToNodeMap = new Map();\n        const urlToNodeMap = new Map();\n        const frameIdToNodeMap = new Map();\n        networkRequests.forEach(request => {\n            if (IGNORED_MIME_TYPES_REGEX.test(request.mimeType)) {\n                return;\n            }\n            if (request.fromWorker) {\n                return;\n            }\n            // Network requestIds can be duplicated for an unknown reason\n            // Suffix all subsequent requests with `:duplicate` until it's unique\n            // NOTE: This should never happen with modern NetworkRequest library, but old fixtures\n            // might still have this issue.\n            while (idToNodeMap.has(request.requestId)) {\n                request.requestId += ':duplicate';\n            }\n            const node = new NetworkNode(request);\n            nodes.push(node);\n            const urlList = urlToNodeMap.get(request.url) || [];\n            urlList.push(node);\n            idToNodeMap.set(request.requestId, node);\n            urlToNodeMap.set(request.url, urlList);\n            // If the request was for the root document of an iframe, save an entry in our\n            // map so we can link up the task `args.data.frame` dependencies later in graph creation.\n            if (request.frameId && request.resourceType === 'Document' && request.documentURL === request.url) {\n                // If there's ever any ambiguity, permanently set the value to `false` to avoid loops in the graph.\n                const value = frameIdToNodeMap.has(request.frameId) ? null : node;\n                frameIdToNodeMap.set(request.frameId, value);\n            }\n        });\n        return { nodes, idToNodeMap, urlToNodeMap, frameIdToNodeMap };\n    }\n    static isScheduleableTask(evt) {\n        return evt.name === SCHEDULABLE_TASK_TITLE_LH || evt.name === SCHEDULABLE_TASK_TITLE_ALT1 ||\n            evt.name === SCHEDULABLE_TASK_TITLE_ALT2 || evt.name === SCHEDULABLE_TASK_TITLE_ALT3;\n    }\n    /**\n     * There should *always* be at least one top level event, having 0 typically means something is\n     * drastically wrong with the trace and we should just give up early and loudly.\n     */\n    static assertHasToplevelEvents(events) {\n        const hasToplevelTask = events.some(this.isScheduleableTask);\n        if (!hasToplevelTask) {\n            throw new Core.LanternError('Could not find any top level events');\n        }\n    }\n    static getCPUNodes(mainThreadEvents) {\n        const nodes = [];\n        let i = 0;\n        PageDependencyGraph.assertHasToplevelEvents(mainThreadEvents);\n        while (i < mainThreadEvents.length) {\n            const evt = mainThreadEvents[i];\n            i++;\n            // Skip all trace events that aren't schedulable tasks with sizable duration\n            if (!PageDependencyGraph.isScheduleableTask(evt) || !evt.dur) {\n                continue;\n            }\n            let correctedEndTs = undefined;\n            // Capture all events that occurred within the task\n            const children = [];\n            for (const endTime = evt.ts + evt.dur; i < mainThreadEvents.length && mainThreadEvents[i].ts < endTime; i++) {\n                const event = mainThreadEvents[i];\n                // Temporary fix for a Chrome bug where some RunTask events can be overlapping.\n                // We correct that here be ensuring each RunTask ends at least 1 microsecond before the next\n                // https://github.com/GoogleChrome/lighthouse/issues/15896\n                // https://issues.chromium.org/issues/329678173\n                if (PageDependencyGraph.isScheduleableTask(event) && event.dur) {\n                    correctedEndTs = event.ts - 1;\n                    break;\n                }\n                children.push(event);\n            }\n            nodes.push(new CPUNode(evt, children, correctedEndTs));\n        }\n        return nodes;\n    }\n    static linkNetworkNodes(rootNode, networkNodeOutput) {\n        networkNodeOutput.nodes.forEach(node => {\n            const directInitiatorRequest = node.request.initiatorRequest || rootNode.request;\n            const directInitiatorNode = networkNodeOutput.idToNodeMap.get(directInitiatorRequest.requestId) || rootNode;\n            const canDependOnInitiator = !directInitiatorNode.isDependentOn(node) && node.canDependOn(directInitiatorNode);\n            const initiators = PageDependencyGraph.getNetworkInitiators(node.request);\n            if (initiators.length) {\n                initiators.forEach(initiator => {\n                    const parentCandidates = networkNodeOutput.urlToNodeMap.get(initiator) || [];\n                    // Only add the edge if the parent is unambiguous with valid timing and isn't circular.\n                    if (parentCandidates.length === 1 && parentCandidates[0].startTime <= node.startTime &&\n                        !parentCandidates[0].isDependentOn(node)) {\n                        node.addDependency(parentCandidates[0]);\n                    }\n                    else if (canDependOnInitiator) {\n                        directInitiatorNode.addDependent(node);\n                    }\n                });\n            }\n            else if (canDependOnInitiator) {\n                directInitiatorNode.addDependent(node);\n            }\n            // Make sure the nodes are attached to the graph if the initiator information was invalid.\n            if (node !== rootNode && node.getDependencies().length === 0 && node.canDependOn(rootNode)) {\n                node.addDependency(rootNode);\n            }\n            if (!node.request.redirects) {\n                return;\n            }\n            const redirects = [...node.request.redirects, node.request];\n            for (let i = 1; i < redirects.length; i++) {\n                const redirectNode = networkNodeOutput.idToNodeMap.get(redirects[i - 1].requestId);\n                const actualNode = networkNodeOutput.idToNodeMap.get(redirects[i].requestId);\n                if (actualNode && redirectNode) {\n                    actualNode.addDependency(redirectNode);\n                }\n            }\n        });\n    }\n    static linkCPUNodes(rootNode, networkNodeOutput, cpuNodes) {\n        const linkableResourceTypes = new Set([\n            'XHR',\n            'Fetch',\n            'Script',\n        ]);\n        function addDependentNetworkRequest(cpuNode, reqId) {\n            const networkNode = networkNodeOutput.idToNodeMap.get(reqId);\n            if (!networkNode ||\n                // Ignore all network nodes that started before this CPU task started\n                // A network request that started earlier could not possibly have been started by this task\n                networkNode.startTime <= cpuNode.startTime) {\n                return;\n            }\n            const { request } = networkNode;\n            const resourceType = request.resourceType || request.redirectDestination?.resourceType;\n            if (!linkableResourceTypes.has(resourceType)) {\n                // We only link some resources to CPU nodes because we observe LCP simulation\n                // regressions when including images, etc.\n                return;\n            }\n            cpuNode.addDependent(networkNode);\n        }\n        /**\n         * If the node has an associated frameId, then create a dependency on the root document request\n         * for the frame. The task obviously couldn't have started before the frame was even downloaded.\n         */\n        function addDependencyOnFrame(cpuNode, frameId) {\n            if (!frameId) {\n                return;\n            }\n            const networkNode = networkNodeOutput.frameIdToNodeMap.get(frameId);\n            if (!networkNode) {\n                return;\n            }\n            // Ignore all network nodes that started after this CPU task started\n            // A network request that started after could not possibly be required this task\n            if (networkNode.startTime >= cpuNode.startTime) {\n                return;\n            }\n            cpuNode.addDependency(networkNode);\n        }\n        function addDependencyOnUrl(cpuNode, url) {\n            if (!url) {\n                return;\n            }\n            // Allow network requests that end up to 100ms before the task started\n            // Some script evaluations can start before the script finishes downloading\n            const minimumAllowableTimeSinceNetworkNodeEnd = -100 * 1000;\n            const candidates = networkNodeOutput.urlToNodeMap.get(url) || [];\n            let minCandidate = null;\n            let minDistance = Infinity;\n            // Find the closest request that finished before this CPU task started\n            for (const candidate of candidates) {\n                // Explicitly ignore all requests that started after this CPU node\n                // A network request that started after this task started cannot possibly be a dependency\n                if (cpuNode.startTime <= candidate.startTime) {\n                    return;\n                }\n                const distance = cpuNode.startTime - candidate.endTime;\n                if (distance >= minimumAllowableTimeSinceNetworkNodeEnd && distance < minDistance) {\n                    minCandidate = candidate;\n                    minDistance = distance;\n                }\n            }\n            if (!minCandidate) {\n                return;\n            }\n            cpuNode.addDependency(minCandidate);\n        }\n        const timers = new Map();\n        for (const node of cpuNodes) {\n            for (const evt of node.childEvents) {\n                if (!evt.args.data) {\n                    continue;\n                }\n                const argsUrl = evt.args.data.url;\n                const stackTraceUrls = (evt.args.data.stackTrace || []).map(l => l.url).filter(Boolean);\n                switch (evt.name) {\n                    case 'TimerInstall':\n                        // @ts-expect-error - 'TimerInstall' event means timerId exists.\n                        timers.set(evt.args.data.timerId, node);\n                        stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n                        break;\n                    case 'TimerFire': {\n                        // @ts-expect-error - 'TimerFire' event means timerId exists.\n                        const installer = timers.get(evt.args.data.timerId);\n                        if (!installer || installer.endTime > node.startTime) {\n                            break;\n                        }\n                        installer.addDependent(node);\n                        break;\n                    }\n                    case 'InvalidateLayout':\n                    case 'ScheduleStyleRecalculation':\n                        addDependencyOnFrame(node, evt.args.data.frame);\n                        stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n                        break;\n                    case 'EvaluateScript':\n                        addDependencyOnFrame(node, evt.args.data.frame);\n                        // @ts-expect-error - 'EvaluateScript' event means argsUrl is defined.\n                        addDependencyOnUrl(node, argsUrl);\n                        stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n                        break;\n                    case 'XHRReadyStateChange':\n                        // Only create the dependency if the request was completed\n                        // 'XHRReadyStateChange' event means readyState is defined.\n                        if (evt.args.data.readyState !== 4) {\n                            break;\n                        }\n                        // @ts-expect-error - 'XHRReadyStateChange' event means argsUrl is defined.\n                        addDependencyOnUrl(node, argsUrl);\n                        stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n                        break;\n                    case 'FunctionCall':\n                    case 'v8.compile':\n                        addDependencyOnFrame(node, evt.args.data.frame);\n                        // @ts-expect-error - events mean argsUrl is defined.\n                        addDependencyOnUrl(node, argsUrl);\n                        break;\n                    case 'ParseAuthorStyleSheet':\n                        addDependencyOnFrame(node, evt.args.data.frame);\n                        // @ts-expect-error - 'ParseAuthorStyleSheet' event means styleSheetUrl is defined.\n                        addDependencyOnUrl(node, evt.args.data.styleSheetUrl);\n                        break;\n                    case 'ResourceSendRequest':\n                        addDependencyOnFrame(node, evt.args.data.frame);\n                        // @ts-expect-error - 'ResourceSendRequest' event means requestId is defined.\n                        addDependentNetworkRequest(node, evt.args.data.requestId);\n                        stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));\n                        break;\n                }\n            }\n            // Nodes starting before the root node cannot depend on it.\n            if (node.getNumberOfDependencies() === 0 && node.canDependOn(rootNode)) {\n                node.addDependency(rootNode);\n            }\n        }\n        // Second pass to prune the graph of short tasks.\n        const minimumEvtDur = SIGNIFICANT_DUR_THRESHOLD_MS * 1000;\n        let foundFirstLayout = false;\n        let foundFirstPaint = false;\n        let foundFirstParse = false;\n        for (const node of cpuNodes) {\n            // Don't prune if event is the first ParseHTML/Layout/Paint.\n            // See https://github.com/GoogleChrome/lighthouse/issues/9627#issuecomment-526699524 for more.\n            let isFirst = false;\n            if (!foundFirstLayout && node.childEvents.some(evt => evt.name === 'Layout')) {\n                isFirst = foundFirstLayout = true;\n            }\n            if (!foundFirstPaint && node.childEvents.some(evt => evt.name === 'Paint')) {\n                isFirst = foundFirstPaint = true;\n            }\n            if (!foundFirstParse && node.childEvents.some(evt => evt.name === 'ParseHTML')) {\n                isFirst = foundFirstParse = true;\n            }\n            if (isFirst || node.duration >= minimumEvtDur) {\n                // Don't prune this node. The task is long / important so it will impact simulation.\n                continue;\n            }\n            // Prune the node if it isn't highly connected to minimize graph size. Rewiring the graph\n            // here replaces O(M + N) edges with (M * N) edges, which is fine if either  M or N is at\n            // most 1.\n            if (node.getNumberOfDependencies() === 1 || node.getNumberOfDependents() <= 1) {\n                PageDependencyGraph.pruneNode(node);\n            }\n        }\n    }\n    /**\n     * Removes the given node from the graph, but retains all paths between its dependencies and\n     * dependents.\n     */\n    static pruneNode(node) {\n        const dependencies = node.getDependencies();\n        const dependents = node.getDependents();\n        for (const dependency of dependencies) {\n            node.removeDependency(dependency);\n            for (const dependent of dependents) {\n                dependency.addDependent(dependent);\n            }\n        }\n        for (const dependent of dependents) {\n            node.removeDependent(dependent);\n        }\n    }\n    /**\n     * TODO: remove when CDT backend in Lighthouse is gone. Until then, this is a useful debugging tool\n     * to find delta between using CDP or the trace to create the network requests.\n     *\n     * When a test fails using the trace backend, I enabled this debug method and copied the network\n     * requests when CDP was used, then when trace is used, and diff'd them. This method helped\n     * remove non-logical differences from the comparison (order of properties, slight rounding\n     * discrepancies, removing object cycles, etc).\n     *\n     * When using for a unit test, make sure to do `.only` so you are getting what you expect.\n     */\n    static debugNormalizeRequests(lanternRequests) {\n        for (const request of lanternRequests) {\n            request.rendererStartTime = Math.round(request.rendererStartTime * 1000) / 1000;\n            request.networkRequestTime = Math.round(request.networkRequestTime * 1000) / 1000;\n            request.responseHeadersEndTime = Math.round(request.responseHeadersEndTime * 1000) / 1000;\n            request.networkEndTime = Math.round(request.networkEndTime * 1000) / 1000;\n        }\n        for (const r of lanternRequests) {\n            delete r.rawRequest;\n            if (r.initiatorRequest) {\n                // @ts-expect-error\n                r.initiatorRequest = { id: r.initiatorRequest.requestId };\n            }\n            if (r.redirectDestination) {\n                // @ts-expect-error\n                r.redirectDestination = { id: r.redirectDestination.requestId };\n            }\n            if (r.redirectSource) {\n                // @ts-expect-error\n                r.redirectSource = { id: r.redirectSource.requestId };\n            }\n            if (r.redirects) {\n                // @ts-expect-error\n                r.redirects = r.redirects.map(r2 => r2.requestId);\n            }\n        }\n        const requests = lanternRequests\n            .map(r => ({\n            requestId: r.requestId,\n            connectionId: r.connectionId,\n            connectionReused: r.connectionReused,\n            url: r.url,\n            protocol: r.protocol,\n            parsedURL: r.parsedURL,\n            documentURL: r.documentURL,\n            rendererStartTime: r.rendererStartTime,\n            networkRequestTime: r.networkRequestTime,\n            responseHeadersEndTime: r.responseHeadersEndTime,\n            networkEndTime: r.networkEndTime,\n            transferSize: r.transferSize,\n            resourceSize: r.resourceSize,\n            fromDiskCache: r.fromDiskCache,\n            fromMemoryCache: r.fromMemoryCache,\n            finished: r.finished,\n            statusCode: r.statusCode,\n            redirectSource: r.redirectSource,\n            redirectDestination: r.redirectDestination,\n            redirects: r.redirects,\n            failed: r.failed,\n            initiator: r.initiator,\n            timing: r.timing ? {\n                requestTime: r.timing.requestTime,\n                proxyStart: r.timing.proxyStart,\n                proxyEnd: r.timing.proxyEnd,\n                dnsStart: r.timing.dnsStart,\n                dnsEnd: r.timing.dnsEnd,\n                connectStart: r.timing.connectStart,\n                connectEnd: r.timing.connectEnd,\n                sslStart: r.timing.sslStart,\n                sslEnd: r.timing.sslEnd,\n                workerStart: r.timing.workerStart,\n                workerReady: r.timing.workerReady,\n                workerFetchStart: r.timing.workerFetchStart,\n                workerRespondWithSettled: r.timing.workerRespondWithSettled,\n                sendStart: r.timing.sendStart,\n                sendEnd: r.timing.sendEnd,\n                pushStart: r.timing.pushStart,\n                pushEnd: r.timing.pushEnd,\n                receiveHeadersStart: r.timing.receiveHeadersStart,\n                receiveHeadersEnd: r.timing.receiveHeadersEnd,\n            } :\n                r.timing,\n            resourceType: r.resourceType,\n            mimeType: r.mimeType,\n            priority: r.priority,\n            initiatorRequest: r.initiatorRequest,\n            frameId: r.frameId,\n            fromWorker: r.fromWorker,\n            isLinkPreload: r.isLinkPreload,\n            serverResponseTime: r.serverResponseTime,\n        }))\n            .filter(r => !r.fromWorker);\n        // eslint-disable-next-line no-unused-vars\n        const debug = requests;\n        // Set breakpoint here.\n        // Copy `debug` and compare with https://www.diffchecker.com/text-compare/\n        // eslint-disable-next-line no-console\n        console.log(debug);\n    }\n    static createGraph(mainThreadEvents, networkRequests, url) {\n        // This is for debugging trace/devtoolslog network records.\n        // const debug = PageDependencyGraph.debugNormalizeRequests(networkRequests);\n        const networkNodeOutput = PageDependencyGraph.getNetworkNodeOutput(networkRequests);\n        const cpuNodes = PageDependencyGraph.getCPUNodes(mainThreadEvents);\n        const { requestedUrl, mainDocumentUrl } = url;\n        if (!requestedUrl) {\n            throw new Core.LanternError('requestedUrl is required to get the root request');\n        }\n        if (!mainDocumentUrl) {\n            throw new Core.LanternError('mainDocumentUrl is required to get the main resource');\n        }\n        const rootRequest = Core.NetworkAnalyzer.findResourceForUrl(networkRequests, requestedUrl);\n        if (!rootRequest) {\n            throw new Core.LanternError('rootRequest not found');\n        }\n        const rootNode = networkNodeOutput.idToNodeMap.get(rootRequest.requestId);\n        if (!rootNode) {\n            throw new Core.LanternError('rootNode not found');\n        }\n        const mainDocumentRequest = Core.NetworkAnalyzer.findLastDocumentForUrl(networkRequests, mainDocumentUrl);\n        if (!mainDocumentRequest) {\n            throw new Core.LanternError('mainDocumentRequest not found');\n        }\n        const mainDocumentNode = networkNodeOutput.idToNodeMap.get(mainDocumentRequest.requestId);\n        if (!mainDocumentNode) {\n            throw new Core.LanternError('mainDocumentNode not found');\n        }\n        PageDependencyGraph.linkNetworkNodes(rootNode, networkNodeOutput);\n        PageDependencyGraph.linkCPUNodes(rootNode, networkNodeOutput, cpuNodes);\n        mainDocumentNode.setIsMainDocument(true);\n        if (NetworkNode.hasCycle(rootNode)) {\n            throw new Core.LanternError('Invalid dependency graph created, cycle detected');\n        }\n        return rootNode;\n    }\n    static printGraph(rootNode, widthInCharacters = 100) {\n        function padRight(str, target, padChar = ' ') {\n            return str + padChar.repeat(Math.max(target - str.length, 0));\n        }\n        const nodes = [];\n        rootNode.traverse(node => nodes.push(node));\n        nodes.sort((a, b) => a.startTime - b.startTime);\n        const min = nodes[0].startTime;\n        const max = nodes.reduce((max, node) => Math.max(max, node.endTime), 0);\n        const totalTime = max - min;\n        const timePerCharacter = totalTime / widthInCharacters;\n        nodes.forEach(node => {\n            const offset = Math.round((node.startTime - min) / timePerCharacter);\n            const length = Math.ceil((node.endTime - node.startTime) / timePerCharacter);\n            const bar = padRight('', offset) + padRight('', length, '=');\n            // @ts-expect-error -- disambiguate displayName from across possible Node types.\n            const displayName = node.request ? node.request.url : node.type;\n            // eslint-disable-next-line\n            console.log(padRight(bar, widthInCharacters), `| ${displayName.slice(0, 30)}`);\n        });\n    }\n}\nexport { PageDependencyGraph };\n//# sourceMappingURL=PageDependencyGraph.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nclass Metric {\n    static getScriptUrls(dependencyGraph, treatNodeAsRenderBlocking) {\n        const scriptUrls = new Set();\n        dependencyGraph.traverse(node => {\n            if (node.type !== Graph.BaseNode.types.NETWORK) {\n                return;\n            }\n            if (node.request.resourceType !== 'Script') {\n                return;\n            }\n            if (treatNodeAsRenderBlocking?.(node)) {\n                scriptUrls.add(node.request.url);\n            }\n        });\n        return scriptUrls;\n    }\n    static get coefficients() {\n        throw new Core.LanternError('coefficients unimplemented!');\n    }\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    /**\n     * Returns the coefficients, scaled by the throttling settings if needed by the metric.\n     * Some lantern metrics (speed-index) use components in their estimate that are not\n     * from the simulator. In this case, we need to adjust the coefficients as the target throttling\n     * settings change.\n     */\n    static getScaledCoefficients(rttMs) {\n        return this.coefficients;\n    }\n    static getOptimisticGraph(dependencyGraph, processedNavigation) {\n        throw new Core.LanternError('Optimistic graph unimplemented!');\n    }\n    static getPessimisticGraph(dependencyGraph, processedNavigation) {\n        throw new Core.LanternError('Pessmistic graph unimplemented!');\n    }\n    static getEstimateFromSimulation(simulationResult, extras) {\n        return simulationResult;\n    }\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n    static compute(data, extras) {\n        const { simulator, graph, processedNavigation } = data;\n        const metricName = this.name.replace('Lantern', '');\n        const optimisticGraph = this.getOptimisticGraph(graph, processedNavigation);\n        const pessimisticGraph = this.getPessimisticGraph(graph, processedNavigation);\n        let simulateOptions = { label: `optimistic${metricName}` };\n        const optimisticSimulation = simulator.simulate(optimisticGraph, simulateOptions);\n        simulateOptions = { label: `pessimistic${metricName}` };\n        const pessimisticSimulation = simulator.simulate(pessimisticGraph, simulateOptions);\n        const optimisticEstimate = this.getEstimateFromSimulation(optimisticSimulation, { ...extras, optimistic: true });\n        const pessimisticEstimate = this.getEstimateFromSimulation(pessimisticSimulation, { ...extras, optimistic: false });\n        const coefficients = this.getScaledCoefficients(simulator.rtt);\n        // Estimates under 1s don't really follow the normal curve fit, minimize the impact of the intercept\n        const interceptMultiplier = coefficients.intercept > 0 ? Math.min(1, optimisticEstimate.timeInMs / 1000) : 1;\n        const timing = coefficients.intercept * interceptMultiplier +\n            coefficients.optimistic * optimisticEstimate.timeInMs + coefficients.pessimistic * pessimisticEstimate.timeInMs;\n        return {\n            timing,\n            optimisticEstimate,\n            pessimisticEstimate,\n            optimisticGraph,\n            pessimisticGraph,\n        };\n    }\n}\nexport { Metric };\n//# sourceMappingURL=Metric.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Graph from '../graph/graph.js';\nimport { Metric } from './Metric.js';\nclass FirstContentfulPaint extends Metric {\n    static get coefficients() {\n        return {\n            intercept: 0,\n            optimistic: 0.5,\n            pessimistic: 0.5,\n        };\n    }\n    /**\n     * Computes the set of URLs that *appeared* to be render-blocking based on our filter,\n     * *but definitely were not* render-blocking based on the timing of their EvaluateScript task.\n     * It also computes the set of corresponding CPU node ids that were needed for the paint at the\n     * given timestamp.\n     */\n    static getRenderBlockingNodeData(graph, { cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking }) {\n        /** A map of blocking script URLs to the earliest EvaluateScript task node that executed them. */\n        const scriptUrlToNodeMap = new Map();\n        const cpuNodes = [];\n        graph.traverse(node => {\n            if (node.type === Graph.BaseNode.types.CPU) {\n                // A task is *possibly* render blocking if it *started* before cutoffTimestamp.\n                // We use startTime here because the paint event can be *inside* the task that was render blocking.\n                if (node.startTime <= cutoffTimestamp) {\n                    cpuNodes.push(node);\n                }\n                // Build our script URL map to find the earliest EvaluateScript task node.\n                const scriptUrls = node.getEvaluateScriptURLs();\n                for (const url of scriptUrls) {\n                    // Use the earliest CPU node we find.\n                    const existing = scriptUrlToNodeMap.get(url) || node;\n                    scriptUrlToNodeMap.set(url, node.startTime < existing.startTime ? node : existing);\n                }\n            }\n        });\n        cpuNodes.sort((a, b) => a.startTime - b.startTime);\n        // A script is *possibly* render blocking if it finished loading before cutoffTimestamp.\n        const possiblyRenderBlockingScriptUrls = Metric.getScriptUrls(graph, node => {\n            // The optimistic LCP treatNodeAsRenderBlocking fn wants to exclude some images in the graph,\n            // but here it only receives scripts to evaluate. It's a no-op in this case, but it will\n            // matter below in the getFirstPaintBasedGraph clone operation.\n            return node.endTime <= cutoffTimestamp && treatNodeAsRenderBlocking(node);\n        });\n        // A script is *definitely not* render blocking if its EvaluateScript task started after cutoffTimestamp.\n        const definitelyNotRenderBlockingScriptUrls = new Set();\n        const renderBlockingCpuNodeIds = new Set();\n        for (const url of possiblyRenderBlockingScriptUrls) {\n            // Lookup the CPU node that had the earliest EvaluateScript for this URL.\n            const cpuNodeForUrl = scriptUrlToNodeMap.get(url);\n            // If we can't find it at all, we can't conclude anything, so just skip it.\n            if (!cpuNodeForUrl) {\n                continue;\n            }\n            // If we found it and it was in our `cpuNodes` set that means it finished before cutoffTimestamp, so it really is render-blocking.\n            if (cpuNodes.includes(cpuNodeForUrl)) {\n                renderBlockingCpuNodeIds.add(cpuNodeForUrl.id);\n                continue;\n            }\n            // We couldn't find the evaluate script in the set of CPU nodes that ran before our paint, so\n            // it must not have been necessary for the paint.\n            definitelyNotRenderBlockingScriptUrls.add(url);\n        }\n        // The first layout, first paint, and first ParseHTML are almost always necessary for first paint,\n        // so we always include those CPU nodes.\n        const firstLayout = cpuNodes.find(node => node.didPerformLayout());\n        if (firstLayout) {\n            renderBlockingCpuNodeIds.add(firstLayout.id);\n        }\n        const firstPaint = cpuNodes.find(node => node.childEvents.some(e => e.name === 'Paint'));\n        if (firstPaint) {\n            renderBlockingCpuNodeIds.add(firstPaint.id);\n        }\n        const firstParse = cpuNodes.find(node => node.childEvents.some(e => e.name === 'ParseHTML'));\n        if (firstParse) {\n            renderBlockingCpuNodeIds.add(firstParse.id);\n        }\n        // If a CPU filter was passed in, we also want to include those extra nodes.\n        if (additionalCpuNodesToTreatAsRenderBlocking) {\n            cpuNodes.filter(additionalCpuNodesToTreatAsRenderBlocking).forEach(node => renderBlockingCpuNodeIds.add(node.id));\n        }\n        return {\n            definitelyNotRenderBlockingScriptUrls,\n            renderBlockingCpuNodeIds,\n        };\n    }\n    /**\n     * Computes the graph required for the first paint of interest.\n     */\n    static getFirstPaintBasedGraph(dependencyGraph, { cutoffTimestamp, treatNodeAsRenderBlocking, additionalCpuNodesToTreatAsRenderBlocking }) {\n        const rbData = this.getRenderBlockingNodeData(dependencyGraph, {\n            cutoffTimestamp,\n            treatNodeAsRenderBlocking,\n            additionalCpuNodesToTreatAsRenderBlocking,\n        });\n        const { definitelyNotRenderBlockingScriptUrls, renderBlockingCpuNodeIds } = rbData;\n        return dependencyGraph.cloneWithRelationships(node => {\n            if (node.type === Graph.BaseNode.types.NETWORK) {\n                // Exclude all nodes that ended after cutoffTimestamp (except for the main document which we always consider necessary)\n                // endTime is negative if request does not finish, make sure startTime isn't after cutoffTimestamp in this case.\n                const endedAfterPaint = node.endTime > cutoffTimestamp || node.startTime > cutoffTimestamp;\n                if (endedAfterPaint && !node.isMainDocument()) {\n                    return false;\n                }\n                const url = node.request.url;\n                // If the URL definitely wasn't render-blocking then we filter it out.\n                if (definitelyNotRenderBlockingScriptUrls.has(url)) {\n                    return false;\n                }\n                // Lastly, build up the FCP graph of all nodes we consider render blocking\n                return treatNodeAsRenderBlocking(node);\n            }\n            // If it's a CPU node, just check if it was blocking.\n            return renderBlockingCpuNodeIds.has(node.id);\n        });\n    }\n    static getOptimisticGraph(dependencyGraph, processedNavigation) {\n        return this.getFirstPaintBasedGraph(dependencyGraph, {\n            cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n            // In the optimistic graph we exclude resources that appeared to be render blocking but were\n            // initiated by a script. While they typically have a very high importance and tend to have a\n            // significant impact on the page's content, these resources don't technically block rendering.\n            treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority() && node.initiatorType !== 'script',\n        });\n    }\n    static getPessimisticGraph(dependencyGraph, processedNavigation) {\n        return this.getFirstPaintBasedGraph(dependencyGraph, {\n            cutoffTimestamp: processedNavigation.timestamps.firstContentfulPaint,\n            treatNodeAsRenderBlocking: node => node.hasRenderBlockingPriority(),\n        });\n    }\n}\nexport { FirstContentfulPaint };\n//# sourceMappingURL=FirstContentfulPaint.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport { Metric, } from './Metric.js';\n// Any CPU task of 20 ms or more will end up being a critical long task on mobile\nconst CRITICAL_LONG_TASK_THRESHOLD = 20;\nclass Interactive extends Metric {\n    static get coefficients() {\n        return {\n            intercept: 0,\n            optimistic: 0.45,\n            pessimistic: 0.55,\n        };\n    }\n    static getOptimisticGraph(dependencyGraph) {\n        // Adjust the critical long task threshold for microseconds\n        const minimumCpuTaskDuration = CRITICAL_LONG_TASK_THRESHOLD * 1000;\n        return dependencyGraph.cloneWithRelationships(node => {\n            // Include everything that might be a long task\n            if (node.type === Graph.BaseNode.types.CPU) {\n                return node.duration > minimumCpuTaskDuration;\n            }\n            // Include all scripts and high priority requests, exclude all images\n            const isImage = node.request.resourceType === 'Image';\n            const isScript = node.request.resourceType === 'Script';\n            return (!isImage && (isScript || node.request.priority === 'High' || node.request.priority === 'VeryHigh'));\n        });\n    }\n    static getPessimisticGraph(dependencyGraph) {\n        return dependencyGraph;\n    }\n    static getEstimateFromSimulation(simulationResult, extras) {\n        if (!extras.lcpResult) {\n            throw new Core.LanternError('missing lcpResult');\n        }\n        const lastTaskAt = Interactive.getLastLongTaskEndTime(simulationResult.nodeTimings);\n        const minimumTime = extras.optimistic ? extras.lcpResult.optimisticEstimate.timeInMs :\n            extras.lcpResult.pessimisticEstimate.timeInMs;\n        return {\n            timeInMs: Math.max(minimumTime, lastTaskAt),\n            nodeTimings: simulationResult.nodeTimings,\n        };\n    }\n    static compute(data, extras) {\n        const lcpResult = extras?.lcpResult;\n        if (!lcpResult) {\n            throw new Core.LanternError('LCP is required to calculate the Interactive metric');\n        }\n        const metricResult = super.compute(data, extras);\n        metricResult.timing = Math.max(metricResult.timing, lcpResult.timing);\n        return metricResult;\n    }\n    static getLastLongTaskEndTime(nodeTimings, duration = 50) {\n        return Array.from(nodeTimings.entries())\n            .filter(([node, timing]) => {\n            if (node.type !== Graph.BaseNode.types.CPU) {\n                return false;\n            }\n            return timing.duration > duration;\n        })\n            .map(([_, timing]) => timing.endTime)\n            .reduce((max, x) => Math.max(max || 0, x || 0), 0);\n    }\n}\nexport { Interactive };\n//# sourceMappingURL=Interactive.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport { FirstContentfulPaint } from './FirstContentfulPaint.js';\nimport { Metric, } from './Metric.js';\nclass LargestContentfulPaint extends Metric {\n    static get coefficients() {\n        return {\n            intercept: 0,\n            optimistic: 0.5,\n            pessimistic: 0.5,\n        };\n    }\n    /**\n     * Low priority image nodes are usually offscreen and very unlikely to be the\n     * resource that is required for LCP. Our LCP graphs include everything except for these images.\n     */\n    static isNotLowPriorityImageNode(node) {\n        if (node.type !== 'network') {\n            return true;\n        }\n        const isImage = node.request.resourceType === 'Image';\n        const isLowPriority = node.request.priority === 'Low' || node.request.priority === 'VeryLow';\n        return !isImage || !isLowPriority;\n    }\n    static getOptimisticGraph(dependencyGraph, processedNavigation) {\n        const lcp = processedNavigation.timestamps.largestContentfulPaint;\n        if (!lcp) {\n            throw new Core.LanternError('NO_LCP');\n        }\n        return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n            cutoffTimestamp: lcp,\n            treatNodeAsRenderBlocking: LargestContentfulPaint.isNotLowPriorityImageNode,\n        });\n    }\n    static getPessimisticGraph(dependencyGraph, processedNavigation) {\n        const lcp = processedNavigation.timestamps.largestContentfulPaint;\n        if (!lcp) {\n            throw new Core.LanternError('NO_LCP');\n        }\n        return FirstContentfulPaint.getFirstPaintBasedGraph(dependencyGraph, {\n            cutoffTimestamp: lcp,\n            treatNodeAsRenderBlocking: _ => true,\n            // For pessimistic LCP we'll include *all* layout nodes\n            additionalCpuNodesToTreatAsRenderBlocking: node => node.didPerformLayout(),\n        });\n    }\n    static getEstimateFromSimulation(simulationResult) {\n        const nodeTimesNotOffscreenImages = Array.from(simulationResult.nodeTimings.entries())\n            .filter(entry => LargestContentfulPaint.isNotLowPriorityImageNode(entry[0]))\n            .map(entry => entry[1].endTime);\n        return {\n            timeInMs: Math.max(...nodeTimesNotOffscreenImages),\n            nodeTimings: simulationResult.nodeTimings,\n        };\n    }\n    static compute(data, extras) {\n        const fcpResult = extras?.fcpResult;\n        if (!fcpResult) {\n            throw new Core.LanternError('FCP is required to calculate the LCP metric');\n        }\n        const metricResult = super.compute(data, extras);\n        metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);\n        return metricResult;\n    }\n}\nexport { LargestContentfulPaint };\n//# sourceMappingURL=LargestContentfulPaint.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nconst BLOCKING_TIME_THRESHOLD = 50;\n/**\n * For TBT, We only want to consider tasks that fall in our time range\n * - FCP and TTI for navigation mode\n * - Trace start and trace end for timespan mode\n *\n * FCP is picked as `startTimeMs` because there is little risk of user input happening\n * before FCP so Long Queuing Qelay regions do not harm user experience. Developers should be\n * optimizing to reach FCP as fast as possible without having to worry about task lengths.\n *\n * TTI is picked as `endTimeMs` because we want a well defined end point for page load.\n *\n * @param startTimeMs Should be FCP in navigation mode and the trace start time in timespan mode\n * @param endTimeMs Should be TTI in navigation mode and the trace end time in timespan mode\n * @param topLevelEvent Leave unset if `event` is top level. Has no effect if `event` has the same duration as `topLevelEvent`.\n */\nfunction calculateTbtImpactForEvent(event, startTimeMs, endTimeMs, topLevelEvent) {\n    let threshold = BLOCKING_TIME_THRESHOLD;\n    // If a task is not top level, it doesn't make sense to subtract the entire 50ms\n    // blocking threshold from the event.\n    //\n    // e.g. A 80ms top level task with two 40ms children should attribute some blocking\n    // time to the 40ms tasks even though they do not meet the 50ms threshold.\n    //\n    // The solution is to scale the threshold for child events to be considered blocking.\n    if (topLevelEvent) {\n        threshold *= (event.duration / topLevelEvent.duration);\n    }\n    if (event.duration < threshold) {\n        return 0;\n    }\n    if (event.end < startTimeMs) {\n        return 0;\n    }\n    if (event.start > endTimeMs) {\n        return 0;\n    }\n    // Perform the clipping and then calculate Blocking Region. So if we have a 150ms task\n    // [0, 150] and `startTimeMs` is at 50ms, we first clip the task to [50, 150], and then\n    // calculate the Blocking Region to be [100, 150]. The rational here is that tasks before\n    // the start time are unimportant, so we care whether the main thread is busy more than\n    // 50ms at a time only after the start time.\n    const clippedStart = Math.max(event.start, startTimeMs);\n    const clippedEnd = Math.min(event.end, endTimeMs);\n    const clippedDuration = clippedEnd - clippedStart;\n    if (clippedDuration < threshold) {\n        return 0;\n    }\n    return clippedDuration - threshold;\n}\nfunction calculateSumOfBlockingTime(topLevelEvents, startTimeMs, endTimeMs) {\n    if (endTimeMs <= startTimeMs) {\n        return 0;\n    }\n    let sumBlockingTime = 0;\n    for (const event of topLevelEvents) {\n        sumBlockingTime += calculateTbtImpactForEvent(event, startTimeMs, endTimeMs);\n    }\n    return sumBlockingTime;\n}\nexport { BLOCKING_TIME_THRESHOLD, calculateSumOfBlockingTime, calculateTbtImpactForEvent, };\n//# sourceMappingURL=TBTUtils.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport { Metric, } from './Metric.js';\nimport { BLOCKING_TIME_THRESHOLD, calculateSumOfBlockingTime } from './TBTUtils.js';\nclass TotalBlockingTime extends Metric {\n    static get coefficients() {\n        return {\n            intercept: 0,\n            optimistic: 0.5,\n            pessimistic: 0.5,\n        };\n    }\n    static getOptimisticGraph(dependencyGraph) {\n        return dependencyGraph;\n    }\n    static getPessimisticGraph(dependencyGraph) {\n        return dependencyGraph;\n    }\n    static getEstimateFromSimulation(simulation, extras) {\n        if (!extras.fcpResult) {\n            throw new Core.LanternError('missing fcpResult');\n        }\n        if (!extras.interactiveResult) {\n            throw new Core.LanternError('missing interactiveResult');\n        }\n        // Intentionally use the opposite FCP estimate. A pessimistic FCP is higher than equal to an\n        // optimistic FCP, which means potentially more tasks are excluded from the Total Blocking Time\n        // computation. So a more pessimistic FCP gives a more optimistic Total Blocking Time for the\n        // same work.\n        const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n            extras.fcpResult.optimisticEstimate.timeInMs;\n        // Similarly, we always have pessimistic TTI >= optimistic TTI. Therefore, picking optimistic\n        // TTI means our window of interest is smaller and thus potentially more tasks are excluded from\n        // Total Blocking Time computation, yielding a lower (more optimistic) Total Blocking Time value\n        // for the same work.\n        const interactiveTimeMs = extras.optimistic ? extras.interactiveResult.optimisticEstimate.timeInMs :\n            extras.interactiveResult.pessimisticEstimate.timeInMs;\n        const minDurationMs = BLOCKING_TIME_THRESHOLD;\n        const events = TotalBlockingTime.getTopLevelEvents(simulation.nodeTimings, minDurationMs);\n        return {\n            timeInMs: calculateSumOfBlockingTime(events, fcpTimeInMs, interactiveTimeMs),\n            nodeTimings: simulation.nodeTimings,\n        };\n    }\n    static compute(data, extras) {\n        const fcpResult = extras?.fcpResult;\n        if (!fcpResult) {\n            throw new Core.LanternError('FCP is required to calculate the TBT metric');\n        }\n        const interactiveResult = extras?.fcpResult;\n        if (!interactiveResult) {\n            throw new Core.LanternError('Interactive is required to calculate the TBT metric');\n        }\n        return super.compute(data, extras);\n    }\n    static getTopLevelEvents(nodeTimings, minDurationMs) {\n        const events = [];\n        for (const [node, timing] of nodeTimings.entries()) {\n            if (node.type !== Graph.BaseNode.types.CPU) {\n                continue;\n            }\n            // Filtering out events below minimum duration.\n            if (timing.duration < minDurationMs) {\n                continue;\n            }\n            events.push({\n                start: timing.startTime,\n                end: timing.endTime,\n                duration: timing.duration,\n            });\n        }\n        return events;\n    }\n}\nexport { TotalBlockingTime };\n//# sourceMappingURL=TotalBlockingTime.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nconst INITIAL_CONGESTION_WINDOW = 10;\nconst TCP_SEGMENT_SIZE = 1460;\nclass TCPConnection {\n    warmed;\n    ssl;\n    h2;\n    rtt;\n    throughput;\n    serverLatency;\n    _congestionWindow;\n    h2OverflowBytesDownloaded;\n    constructor(rtt, throughput, serverLatency = 0, ssl = true, h2 = false) {\n        this.warmed = false;\n        this.ssl = ssl;\n        this.h2 = h2;\n        this.rtt = rtt;\n        this.throughput = throughput;\n        this.serverLatency = serverLatency;\n        this._congestionWindow = INITIAL_CONGESTION_WINDOW;\n        this.h2OverflowBytesDownloaded = 0;\n    }\n    static maximumSaturatedConnections(rtt, availableThroughput) {\n        const roundTripsPerSecond = 1000 / rtt;\n        const bytesPerRoundTrip = TCP_SEGMENT_SIZE;\n        const bytesPerSecond = roundTripsPerSecond * bytesPerRoundTrip;\n        const minimumThroughputRequiredPerRequest = bytesPerSecond * 8;\n        return Math.floor(availableThroughput / minimumThroughputRequiredPerRequest);\n    }\n    computeMaximumCongestionWindowInSegments() {\n        const bytesPerSecond = this.throughput / 8;\n        const secondsPerRoundTrip = this.rtt / 1000;\n        const bytesPerRoundTrip = bytesPerSecond * secondsPerRoundTrip;\n        return Math.floor(bytesPerRoundTrip / TCP_SEGMENT_SIZE);\n    }\n    setThroughput(throughput) {\n        this.throughput = throughput;\n    }\n    setCongestionWindow(congestion) {\n        this._congestionWindow = congestion;\n    }\n    setWarmed(warmed) {\n        this.warmed = warmed;\n    }\n    isWarm() {\n        return this.warmed;\n    }\n    isH2() {\n        return this.h2;\n    }\n    get congestionWindow() {\n        return this._congestionWindow;\n    }\n    /**\n     * Sets the number of excess bytes that are available to this connection on future downloads, only\n     * applies to H2 connections.\n     */\n    setH2OverflowBytesDownloaded(bytes) {\n        if (!this.h2) {\n            return;\n        }\n        this.h2OverflowBytesDownloaded = bytes;\n    }\n    clone() {\n        return Object.assign(new TCPConnection(this.rtt, this.throughput), this);\n    }\n    /**\n     * Simulates a network download of a particular number of bytes over an optional maximum amount of time\n     * and returns information about the ending state.\n     *\n     * See https://hpbn.co/building-blocks-of-tcp/#three-way-handshake and\n     *  https://hpbn.co/transport-layer-security-tls/#tls-handshake for details.\n     */\n    simulateDownloadUntil(bytesToDownload, options) {\n        const { timeAlreadyElapsed = 0, maximumTimeToElapse = Infinity, dnsResolutionTime = 0 } = options || {};\n        if (this.warmed && this.h2) {\n            bytesToDownload -= this.h2OverflowBytesDownloaded;\n        }\n        const twoWayLatency = this.rtt;\n        const oneWayLatency = twoWayLatency / 2;\n        const maximumCongestionWindow = this.computeMaximumCongestionWindowInSegments();\n        let handshakeAndRequest = oneWayLatency;\n        if (!this.warmed) {\n            handshakeAndRequest =\n                // DNS lookup\n                dnsResolutionTime +\n                    // SYN\n                    oneWayLatency +\n                    // SYN ACK\n                    oneWayLatency +\n                    // ACK + initial request\n                    oneWayLatency +\n                    // ClientHello/ServerHello assuming TLS False Start is enabled (https://istlsfastyet.com/#server-performance).\n                    (this.ssl ? twoWayLatency : 0);\n        }\n        let roundTrips = Math.ceil(handshakeAndRequest / twoWayLatency);\n        let timeToFirstByte = handshakeAndRequest + this.serverLatency + oneWayLatency;\n        if (this.warmed && this.h2) {\n            timeToFirstByte = 0;\n        }\n        const timeElapsedForTTFB = Math.max(timeToFirstByte - timeAlreadyElapsed, 0);\n        const maximumDownloadTimeToElapse = maximumTimeToElapse - timeElapsedForTTFB;\n        let congestionWindow = Math.min(this._congestionWindow, maximumCongestionWindow);\n        let totalBytesDownloaded = 0;\n        if (timeElapsedForTTFB > 0) {\n            totalBytesDownloaded = congestionWindow * TCP_SEGMENT_SIZE;\n        }\n        else {\n            roundTrips = 0;\n        }\n        let downloadTimeElapsed = 0;\n        let bytesRemaining = bytesToDownload - totalBytesDownloaded;\n        while (bytesRemaining > 0 && downloadTimeElapsed <= maximumDownloadTimeToElapse) {\n            roundTrips++;\n            downloadTimeElapsed += twoWayLatency;\n            congestionWindow = Math.max(Math.min(maximumCongestionWindow, congestionWindow * 2), 1);\n            const bytesDownloadedInWindow = congestionWindow * TCP_SEGMENT_SIZE;\n            totalBytesDownloaded += bytesDownloadedInWindow;\n            bytesRemaining -= bytesDownloadedInWindow;\n        }\n        const timeElapsed = timeElapsedForTTFB + downloadTimeElapsed;\n        const extraBytesDownloaded = this.h2 ? Math.max(totalBytesDownloaded - bytesToDownload, 0) : 0;\n        const bytesDownloaded = Math.max(Math.min(totalBytesDownloaded, bytesToDownload), 0);\n        let connectionTiming;\n        if (!this.warmed) {\n            connectionTiming = {\n                dnsResolutionTime,\n                connectionTime: handshakeAndRequest - dnsResolutionTime,\n                sslTime: this.ssl ? twoWayLatency : undefined,\n                timeToFirstByte,\n            };\n        }\n        else if (this.h2) {\n            // TODO: timing information currently difficult to model for warm h2 connections.\n            connectionTiming = {\n                timeToFirstByte,\n            };\n        }\n        else {\n            connectionTiming = {\n                connectionTime: handshakeAndRequest,\n                timeToFirstByte,\n            };\n        }\n        return {\n            roundTrips,\n            timeElapsed,\n            bytesDownloaded,\n            extraBytesDownloaded,\n            congestionWindow,\n            connectionTiming,\n        };\n    }\n}\nexport { TCPConnection };\n//# sourceMappingURL=TCPConnection.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport { TCPConnection } from './TCPConnection.js';\nconst DEFAULT_SERVER_RESPONSE_TIME = 30;\nconst TLS_SCHEMES = ['https', 'wss'];\n// Each origin can have 6 simulatenous connections open\n// https://cs.chromium.org/chromium/src/net/socket/client_socket_pool_manager.cc?type=cs&q=\"int+g_max_sockets_per_group\"\nconst CONNECTIONS_PER_ORIGIN = 6;\nexport class ConnectionPool {\n    options;\n    records;\n    connectionsByOrigin;\n    connectionsByRequest;\n    _connectionsInUse;\n    connectionReusedByRequestId;\n    constructor(records, options) {\n        this.options = options;\n        this.records = records;\n        this.connectionsByOrigin = new Map();\n        this.connectionsByRequest = new Map();\n        this._connectionsInUse = new Set();\n        this.connectionReusedByRequestId = Core.NetworkAnalyzer.estimateIfConnectionWasReused(records, {\n            forceCoarseEstimates: true,\n        });\n        this.initializeConnections();\n    }\n    connectionsInUse() {\n        return Array.from(this._connectionsInUse);\n    }\n    initializeConnections() {\n        const connectionReused = this.connectionReusedByRequestId;\n        const additionalRttByOrigin = this.options.additionalRttByOrigin;\n        const serverResponseTimeByOrigin = this.options.serverResponseTimeByOrigin;\n        const recordsByOrigin = Core.NetworkAnalyzer.groupByOrigin(this.records);\n        for (const [origin, requests] of recordsByOrigin.entries()) {\n            const connections = [];\n            const additionalRtt = additionalRttByOrigin.get(origin) || 0;\n            const responseTime = serverResponseTimeByOrigin.get(origin) || DEFAULT_SERVER_RESPONSE_TIME;\n            for (const request of requests) {\n                if (connectionReused.get(request.requestId)) {\n                    continue;\n                }\n                const isTLS = TLS_SCHEMES.includes(request.parsedURL.scheme);\n                const isH2 = request.protocol === 'h2';\n                const connection = new TCPConnection(this.options.rtt + additionalRtt, this.options.throughput, responseTime, isTLS, isH2);\n                connections.push(connection);\n            }\n            if (!connections.length) {\n                throw new Core.LanternError(`Could not find a connection for origin: ${origin}`);\n            }\n            // Make sure each origin has minimum number of connections available for max throughput.\n            // But only if it's not over H2 which maximizes throughput already.\n            const minConnections = connections[0].isH2() ? 1 : CONNECTIONS_PER_ORIGIN;\n            while (connections.length < minConnections) {\n                connections.push(connections[0].clone());\n            }\n            this.connectionsByOrigin.set(origin, connections);\n        }\n    }\n    findAvailableConnectionWithLargestCongestionWindow(connections) {\n        let maxConnection = null;\n        for (let i = 0; i < connections.length; i++) {\n            const connection = connections[i];\n            // Connections that are in use are never available.\n            if (this._connectionsInUse.has(connection)) {\n                continue;\n            }\n            // This connection is a match and is available! Update our max if it has a larger congestionWindow\n            const currentMax = (maxConnection?.congestionWindow) || -Infinity;\n            if (connection.congestionWindow > currentMax) {\n                maxConnection = connection;\n            }\n        }\n        return maxConnection;\n    }\n    /**\n     * This method finds an available connection to the origin specified by the network request or null\n     * if no connection was available. If returned, connection will not be available for other network\n     * records until release is called.\n     */\n    acquire(request) {\n        if (this.connectionsByRequest.has(request)) {\n            throw new Core.LanternError('Record already has a connection');\n        }\n        const origin = request.parsedURL.securityOrigin;\n        const connections = this.connectionsByOrigin.get(origin) || [];\n        const connectionToUse = this.findAvailableConnectionWithLargestCongestionWindow(connections);\n        if (!connectionToUse) {\n            return null;\n        }\n        this._connectionsInUse.add(connectionToUse);\n        this.connectionsByRequest.set(request, connectionToUse);\n        return connectionToUse;\n    }\n    /**\n     * Return the connection currently being used to fetch a request. If no connection\n     * currently being used for this request, an error will be thrown.\n     */\n    acquireActiveConnectionFromRequest(request) {\n        const activeConnection = this.connectionsByRequest.get(request);\n        if (!activeConnection) {\n            throw new Core.LanternError('Could not find an active connection for request');\n        }\n        return activeConnection;\n    }\n    release(request) {\n        const connection = this.connectionsByRequest.get(request);\n        this.connectionsByRequest.delete(request);\n        if (connection) {\n            this._connectionsInUse.delete(connection);\n        }\n    }\n}\n//# sourceMappingURL=ConnectionPool.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nconst DEVTOOLS_RTT_ADJUSTMENT_FACTOR = 3.75;\nconst DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR = 0.9;\nconst throttling = {\n    DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n    DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n    // These values align with WebPageTest's definition of \"Fast 3G\"\n    // But offer similar characteristics to roughly the 75th percentile of 4G connections.\n    mobileSlow4G: {\n        rttMs: 150,\n        throughputKbps: 1.6 * 1024,\n        requestLatencyMs: 150 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n        downloadThroughputKbps: 1.6 * 1024 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n        uploadThroughputKbps: 750 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n        cpuSlowdownMultiplier: 4,\n    },\n    // These values partially align with WebPageTest's definition of \"Regular 3G\".\n    // These values are meant to roughly align with Chrome UX report's 3G definition which are based\n    // on HTTP RTT of 300-1400ms and downlink throughput of <700kbps.\n    mobileRegular3G: {\n        rttMs: 300,\n        throughputKbps: 700,\n        requestLatencyMs: 300 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,\n        downloadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n        uploadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,\n        cpuSlowdownMultiplier: 4,\n    },\n    // Using a \"broadband\" connection type\n    // Corresponds to \"Dense 4G 25th percentile\" in https://docs.google.com/document/d/1Ft1Bnq9-t4jK5egLSOc28IL4TvR-Tt0se_1faTA4KTY/edit#heading=h.bb7nfy2x9e5v\n    desktopDense4G: {\n        rttMs: 40,\n        throughputKbps: 10 * 1024,\n        cpuSlowdownMultiplier: 1,\n        requestLatencyMs: 0, // 0 means unset\n        downloadThroughputKbps: 0,\n        uploadThroughputKbps: 0,\n    },\n};\nconst Constants = { throttling };\nexport { Constants };\n//# sourceMappingURL=Constants.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// A DNS lookup will usually take ~1-2 roundtrips of connection latency plus the extra DNS routing time.\n// Example: https://www.webpagetest.org/result/180703_3A_e33ec79747c002ed4d7bcbfc81462203/1/details/#waterfall_view_step1\n// Example: https://www.webpagetest.org/result/180707_1M_89673eb633b5d98386de95dfcf9b33d5/1/details/#waterfall_view_step1\n// DNS is highly variable though, many times it's a little more than 1, but can easily be 4-5x RTT.\n// We'll use 2 since it seems to give the most accurate results on average, but this can be tweaked.\nconst DNS_RESOLUTION_RTT_MULTIPLIER = 2;\nclass DNSCache {\n    static rttMultiplier = DNS_RESOLUTION_RTT_MULTIPLIER;\n    rtt;\n    resolvedDomainNames;\n    constructor({ rtt }) {\n        this.rtt = rtt;\n        this.resolvedDomainNames = new Map();\n    }\n    getTimeUntilResolution(request, options) {\n        const { requestedAt = 0, shouldUpdateCache = false } = options || {};\n        const domain = request.parsedURL.host;\n        const cacheEntry = this.resolvedDomainNames.get(domain);\n        let timeUntilResolved = this.rtt * DNSCache.rttMultiplier;\n        if (cacheEntry) {\n            const timeUntilCachedIsResolved = Math.max(cacheEntry.resolvedAt - requestedAt, 0);\n            timeUntilResolved = Math.min(timeUntilCachedIsResolved, timeUntilResolved);\n        }\n        const resolvedAt = requestedAt + timeUntilResolved;\n        if (shouldUpdateCache) {\n            this.updateCacheResolvedAtIfNeeded(request, resolvedAt);\n        }\n        return timeUntilResolved;\n    }\n    updateCacheResolvedAtIfNeeded(request, resolvedAt) {\n        const domain = request.parsedURL.host;\n        const cacheEntry = this.resolvedDomainNames.get(domain) || { resolvedAt };\n        cacheEntry.resolvedAt = Math.min(cacheEntry.resolvedAt, resolvedAt);\n        this.resolvedDomainNames.set(domain, cacheEntry);\n    }\n    /**\n     * Forcefully sets the DNS resolution time for a request.\n     * Useful for testing and alternate execution simulations.\n     */\n    setResolvedAt(domain, resolvedAt) {\n        this.resolvedDomainNames.set(domain, { resolvedAt });\n    }\n}\nexport { DNSCache };\n//# sourceMappingURL=DNSCache.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/**\n * @fileoverview\n *\n * This class encapsulates the type-related validation logic for moving timing information for nodes\n * through the different simulation phases. Methods here ensure that the invariants of simulation hold\n * as nodes are queued, partially simulated, and completed.\n */\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nclass SimulatorTimingMap {\n    nodeTimings;\n    constructor() {\n        this.nodeTimings = new Map();\n    }\n    getNodes() {\n        return Array.from(this.nodeTimings.keys());\n    }\n    setReadyToStart(node, values) {\n        this.nodeTimings.set(node, values);\n    }\n    setInProgress(node, values) {\n        const nodeTiming = {\n            ...this.getQueued(node),\n            startTime: values.startTime,\n            timeElapsed: 0,\n        };\n        this.nodeTimings.set(node, node.type === Graph.BaseNode.types.NETWORK ? { ...nodeTiming, timeElapsedOvershoot: 0, bytesDownloaded: 0 } :\n            nodeTiming);\n    }\n    setCompleted(node, values) {\n        const nodeTiming = {\n            ...this.getInProgress(node),\n            endTime: values.endTime,\n            connectionTiming: values.connectionTiming,\n        };\n        this.nodeTimings.set(node, nodeTiming);\n    }\n    setCpu(node, values) {\n        const nodeTiming = {\n            ...this.getCpuStarted(node),\n            timeElapsed: values.timeElapsed,\n        };\n        this.nodeTimings.set(node, nodeTiming);\n    }\n    setCpuEstimated(node, values) {\n        const nodeTiming = {\n            ...this.getCpuStarted(node),\n            estimatedTimeElapsed: values.estimatedTimeElapsed,\n        };\n        this.nodeTimings.set(node, nodeTiming);\n    }\n    setNetwork(node, values) {\n        const nodeTiming = {\n            ...this.getNetworkStarted(node),\n            timeElapsed: values.timeElapsed,\n            timeElapsedOvershoot: values.timeElapsedOvershoot,\n            bytesDownloaded: values.bytesDownloaded,\n        };\n        this.nodeTimings.set(node, nodeTiming);\n    }\n    setNetworkEstimated(node, values) {\n        const nodeTiming = {\n            ...this.getNetworkStarted(node),\n            estimatedTimeElapsed: values.estimatedTimeElapsed,\n        };\n        this.nodeTimings.set(node, nodeTiming);\n    }\n    getQueued(node) {\n        const timing = this.nodeTimings.get(node);\n        if (!timing) {\n            throw new Core.LanternError(`Node ${node.id} not yet queued`);\n        }\n        return timing;\n    }\n    getCpuStarted(node) {\n        const timing = this.nodeTimings.get(node);\n        if (!timing) {\n            throw new Core.LanternError(`Node ${node.id} not yet queued`);\n        }\n        if (!('startTime' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet started`);\n        }\n        if ('bytesDownloaded' in timing) {\n            throw new Core.LanternError(`Node ${node.id} timing not valid`);\n        }\n        return timing;\n    }\n    getNetworkStarted(node) {\n        const timing = this.nodeTimings.get(node);\n        if (!timing) {\n            throw new Core.LanternError(`Node ${node.id} not yet queued`);\n        }\n        if (!('startTime' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet started`);\n        }\n        if (!('bytesDownloaded' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} timing not valid`);\n        }\n        return timing;\n    }\n    getInProgress(node) {\n        const timing = this.nodeTimings.get(node);\n        if (!timing) {\n            throw new Core.LanternError(`Node ${node.id} not yet queued`);\n        }\n        if (!('startTime' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet started`);\n        }\n        if (!('estimatedTimeElapsed' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n        }\n        return timing;\n    }\n    getCompleted(node) {\n        const timing = this.nodeTimings.get(node);\n        if (!timing) {\n            throw new Core.LanternError(`Node ${node.id} not yet queued`);\n        }\n        if (!('startTime' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet started`);\n        }\n        if (!('estimatedTimeElapsed' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet in progress`);\n        }\n        if (!('endTime' in timing)) {\n            throw new Core.LanternError(`Node ${node.id} not yet completed`);\n        }\n        return timing;\n    }\n}\nexport { SimulatorTimingMap };\n//# sourceMappingURL=SimulationTimingMap.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport { ConnectionPool } from './ConnectionPool.js';\nimport { Constants } from './Constants.js';\nimport { DNSCache } from './DNSCache.js';\nimport { SimulatorTimingMap } from './SimulationTimingMap.js';\nimport { TCPConnection } from './TCPConnection.js';\nconst defaultThrottling = Constants.throttling.mobileSlow4G;\n// see https://cs.chromium.org/search/?q=kDefaultMaxNumDelayableRequestsPerClient&sq=package:chromium&type=cs\nconst DEFAULT_MAXIMUM_CONCURRENT_REQUESTS = 10;\n// layout tasks tend to be less CPU-bound and do not experience the same increase in duration\nconst DEFAULT_LAYOUT_TASK_MULTIPLIER = 0.5;\n// if a task takes more than 10 seconds it's usually a sign it isn't actually CPU bound and we're overestimating\nconst DEFAULT_MAXIMUM_CPU_TASK_DURATION = 10000;\nconst NodeState = {\n    NotReadyToStart: 0,\n    ReadyToStart: 1,\n    InProgress: 2,\n    Complete: 3,\n};\nconst PriorityStartTimePenalty = {\n    VeryHigh: 0,\n    High: 0.25,\n    Medium: 0.5,\n    Low: 1,\n    VeryLow: 2,\n};\nconst ALL_SIMULATION_NODE_TIMINGS = new Map();\nclass Simulator {\n    static createSimulator(settings) {\n        const { throttlingMethod, throttling, precomputedLanternData, networkAnalysis } = settings;\n        const options = {\n            additionalRttByOrigin: networkAnalysis.additionalRttByOrigin,\n            serverResponseTimeByOrigin: networkAnalysis.serverResponseTimeByOrigin,\n            observedThroughput: networkAnalysis.throughput,\n        };\n        // If we have precomputed lantern data, overwrite our observed estimates and use precomputed instead\n        // for increased stability.\n        if (precomputedLanternData) {\n            options.additionalRttByOrigin = new Map(Object.entries(precomputedLanternData.additionalRttByOrigin));\n            options.serverResponseTimeByOrigin = new Map(Object.entries(precomputedLanternData.serverResponseTimeByOrigin));\n        }\n        switch (throttlingMethod) {\n            case 'provided':\n                options.rtt = networkAnalysis.rtt;\n                options.throughput = networkAnalysis.throughput;\n                options.cpuSlowdownMultiplier = 1;\n                options.layoutTaskMultiplier = 1;\n                break;\n            case 'devtools':\n                if (throttling) {\n                    options.rtt = throttling.requestLatencyMs / Constants.throttling.DEVTOOLS_RTT_ADJUSTMENT_FACTOR;\n                    options.throughput =\n                        throttling.downloadThroughputKbps * 1024 / Constants.throttling.DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR;\n                }\n                options.cpuSlowdownMultiplier = 1;\n                options.layoutTaskMultiplier = 1;\n                break;\n            case 'simulate':\n                if (throttling) {\n                    options.rtt = throttling.rttMs;\n                    options.throughput = throttling.throughputKbps * 1024;\n                    options.cpuSlowdownMultiplier = throttling.cpuSlowdownMultiplier;\n                }\n                break;\n            default:\n                // intentionally fallback to simulator defaults\n                break;\n        }\n        return new Simulator(options);\n    }\n    options;\n    _rtt;\n    throughput;\n    maximumConcurrentRequests;\n    cpuSlowdownMultiplier;\n    layoutTaskMultiplier;\n    cachedNodeListByStartPosition;\n    nodeTimings;\n    numberInProgressByType;\n    nodes;\n    dns;\n    connectionPool;\n    constructor(options) {\n        this.options = Object.assign({\n            rtt: defaultThrottling.rttMs,\n            throughput: defaultThrottling.throughputKbps * 1024,\n            maximumConcurrentRequests: DEFAULT_MAXIMUM_CONCURRENT_REQUESTS,\n            cpuSlowdownMultiplier: defaultThrottling.cpuSlowdownMultiplier,\n            layoutTaskMultiplier: DEFAULT_LAYOUT_TASK_MULTIPLIER,\n            additionalRttByOrigin: new Map(),\n            serverResponseTimeByOrigin: new Map(),\n        }, options);\n        this._rtt = this.options.rtt;\n        this.throughput = this.options.throughput;\n        this.maximumConcurrentRequests = Math.max(Math.min(TCPConnection.maximumSaturatedConnections(this._rtt, this.throughput), this.options.maximumConcurrentRequests), 1);\n        this.cpuSlowdownMultiplier = this.options.cpuSlowdownMultiplier;\n        this.layoutTaskMultiplier = this.cpuSlowdownMultiplier * this.options.layoutTaskMultiplier;\n        this.cachedNodeListByStartPosition = [];\n        // Properties reset on every `.simulate` call but duplicated here for type checking\n        this.nodeTimings = new SimulatorTimingMap();\n        this.numberInProgressByType = new Map();\n        this.nodes = {};\n        this.dns = new DNSCache({ rtt: this._rtt });\n        // @ts-expect-error\n        this.connectionPool = null;\n        if (!Number.isFinite(this._rtt)) {\n            throw new Core.LanternError(`Invalid rtt ${this._rtt}`);\n        }\n        if (!Number.isFinite(this.throughput)) {\n            throw new Core.LanternError(`Invalid rtt ${this.throughput}`);\n        }\n    }\n    get rtt() {\n        return this._rtt;\n    }\n    initializeConnectionPool(graph) {\n        const records = [];\n        graph.getRootNode().traverse(node => {\n            if (node.type === Graph.BaseNode.types.NETWORK) {\n                records.push(node.request);\n            }\n        });\n        this.connectionPool = new ConnectionPool(records, this.options);\n    }\n    /**\n     * Initializes the various state data structures such _nodeTimings and the _node Sets by state.\n     */\n    initializeAuxiliaryData() {\n        this.nodeTimings = new SimulatorTimingMap();\n        this.numberInProgressByType = new Map();\n        this.nodes = {};\n        this.cachedNodeListByStartPosition = [];\n        // NOTE: We don't actually need *all* of these sets, but the clarity that each node progresses\n        // through the system is quite nice.\n        for (const state of Object.values(NodeState)) {\n            this.nodes[state] = new Set();\n        }\n    }\n    numberInProgress(type) {\n        return this.numberInProgressByType.get(type) || 0;\n    }\n    markNodeAsReadyToStart(node, queuedTime) {\n        const nodeStartPosition = Simulator.computeNodeStartPosition(node);\n        const firstNodeIndexWithGreaterStartPosition = this.cachedNodeListByStartPosition.findIndex(candidate => Simulator.computeNodeStartPosition(candidate) > nodeStartPosition);\n        const insertionIndex = firstNodeIndexWithGreaterStartPosition === -1 ? this.cachedNodeListByStartPosition.length :\n            firstNodeIndexWithGreaterStartPosition;\n        this.cachedNodeListByStartPosition.splice(insertionIndex, 0, node);\n        this.nodes[NodeState.ReadyToStart].add(node);\n        this.nodes[NodeState.NotReadyToStart].delete(node);\n        this.nodeTimings.setReadyToStart(node, { queuedTime });\n    }\n    markNodeAsInProgress(node, startTime) {\n        const indexOfNodeToStart = this.cachedNodeListByStartPosition.indexOf(node);\n        this.cachedNodeListByStartPosition.splice(indexOfNodeToStart, 1);\n        this.nodes[NodeState.InProgress].add(node);\n        this.nodes[NodeState.ReadyToStart].delete(node);\n        this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) + 1);\n        this.nodeTimings.setInProgress(node, { startTime });\n    }\n    markNodeAsComplete(node, endTime, connectionTiming) {\n        this.nodes[NodeState.Complete].add(node);\n        this.nodes[NodeState.InProgress].delete(node);\n        this.numberInProgressByType.set(node.type, this.numberInProgress(node.type) - 1);\n        this.nodeTimings.setCompleted(node, { endTime, connectionTiming });\n        // Try to add all its dependents to the queue\n        for (const dependent of node.getDependents()) {\n            // Skip dependent node if one of its dependencies hasn't finished yet\n            const dependencies = dependent.getDependencies();\n            if (dependencies.some(dep => !this.nodes[NodeState.Complete].has(dep))) {\n                continue;\n            }\n            // Otherwise add it to the queue\n            this.markNodeAsReadyToStart(dependent, endTime);\n        }\n    }\n    acquireConnection(request) {\n        return this.connectionPool.acquire(request);\n    }\n    getNodesSortedByStartPosition() {\n        // Make a copy so we don't skip nodes due to concurrent modification\n        return Array.from(this.cachedNodeListByStartPosition);\n    }\n    startNodeIfPossible(node, totalElapsedTime) {\n        if (node.type === Graph.BaseNode.types.CPU) {\n            // Start a CPU task if there's no other CPU task in process\n            if (this.numberInProgress(node.type) === 0) {\n                this.markNodeAsInProgress(node, totalElapsedTime);\n            }\n            return;\n        }\n        if (node.type !== Graph.BaseNode.types.NETWORK) {\n            throw new Core.LanternError('Unsupported');\n        }\n        // If a network request is connectionless, we can always start it, so skip the connection checks\n        if (!node.isConnectionless) {\n            // Start a network request if we're not at max requests and a connection is available\n            const numberOfActiveRequests = this.numberInProgress(node.type);\n            if (numberOfActiveRequests >= this.maximumConcurrentRequests) {\n                return;\n            }\n            const connection = this.acquireConnection(node.request);\n            if (!connection) {\n                return;\n            }\n        }\n        this.markNodeAsInProgress(node, totalElapsedTime);\n    }\n    /**\n     * Updates each connection in use with the available throughput based on the number of network requests\n     * currently in flight.\n     */\n    updateNetworkCapacity() {\n        const inFlight = this.numberInProgress(Graph.BaseNode.types.NETWORK);\n        if (inFlight === 0) {\n            return;\n        }\n        for (const connection of this.connectionPool.connectionsInUse()) {\n            connection.setThroughput(this.throughput / inFlight);\n        }\n    }\n    /**\n     * Estimates the number of milliseconds remaining given current condidtions before the node is complete.\n     */\n    estimateTimeRemaining(node) {\n        if (node.type === Graph.BaseNode.types.CPU) {\n            return this.estimateCPUTimeRemaining(node);\n        }\n        if (node.type === Graph.BaseNode.types.NETWORK) {\n            return this.estimateNetworkTimeRemaining(node);\n        }\n        throw new Core.LanternError('Unsupported');\n    }\n    estimateCPUTimeRemaining(cpuNode) {\n        const timingData = this.nodeTimings.getCpuStarted(cpuNode);\n        const multiplier = cpuNode.didPerformLayout() ? this.layoutTaskMultiplier : this.cpuSlowdownMultiplier;\n        const totalDuration = Math.min(Math.round(cpuNode.duration / 1000 * multiplier), DEFAULT_MAXIMUM_CPU_TASK_DURATION);\n        const estimatedTimeElapsed = totalDuration - timingData.timeElapsed;\n        this.nodeTimings.setCpuEstimated(cpuNode, { estimatedTimeElapsed });\n        return estimatedTimeElapsed;\n    }\n    estimateNetworkTimeRemaining(networkNode) {\n        const request = networkNode.request;\n        const timingData = this.nodeTimings.getNetworkStarted(networkNode);\n        let timeElapsed = 0;\n        if (networkNode.fromDiskCache) {\n            // Rough access time for seeking to location on disk and reading sequentially.\n            // 8ms per seek + 20ms/MB\n            // @see http://norvig.com/21-days.html#answers\n            const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n            timeElapsed = 8 + 20 * sizeInMb - timingData.timeElapsed;\n        }\n        else if (networkNode.isNonNetworkProtocol) {\n            // Estimates for the overhead of a data URL in Chromium and the decoding time for base64-encoded data.\n            // 2ms per request + 10ms/MB\n            // @see traces on https://dopiaza.org/tools/datauri/examples/index.php\n            const sizeInMb = (request.resourceSize || 0) / 1024 / 1024;\n            timeElapsed = 2 + 10 * sizeInMb - timingData.timeElapsed;\n        }\n        else {\n            const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n            const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n                requestedAt: timingData.startTime,\n                shouldUpdateCache: true,\n            });\n            const timeAlreadyElapsed = timingData.timeElapsed;\n            const calculation = connection.simulateDownloadUntil(request.transferSize - timingData.bytesDownloaded, { timeAlreadyElapsed, dnsResolutionTime, maximumTimeToElapse: Infinity });\n            timeElapsed = calculation.timeElapsed;\n        }\n        const estimatedTimeElapsed = timeElapsed + timingData.timeElapsedOvershoot;\n        this.nodeTimings.setNetworkEstimated(networkNode, { estimatedTimeElapsed });\n        return estimatedTimeElapsed;\n    }\n    /**\n     * Computes and returns the minimum estimated completion time of the nodes currently in progress.\n     */\n    findNextNodeCompletionTime() {\n        let minimumTime = Infinity;\n        for (const node of this.nodes[NodeState.InProgress]) {\n            minimumTime = Math.min(minimumTime, this.estimateTimeRemaining(node));\n        }\n        return minimumTime;\n    }\n    /**\n     * Given a time period, computes the progress toward completion that the node made durin that time.\n     */\n    updateProgressMadeInTimePeriod(node, timePeriodLength, totalElapsedTime) {\n        const timingData = this.nodeTimings.getInProgress(node);\n        const isFinished = timingData.estimatedTimeElapsed === timePeriodLength;\n        if (node.type === Graph.BaseNode.types.CPU || node.isConnectionless) {\n            if (isFinished) {\n                this.markNodeAsComplete(node, totalElapsedTime);\n            }\n            else {\n                timingData.timeElapsed += timePeriodLength;\n            }\n            return;\n        }\n        if (node.type !== Graph.BaseNode.types.NETWORK) {\n            throw new Core.LanternError('Unsupported');\n        }\n        if (!('bytesDownloaded' in timingData)) {\n            throw new Core.LanternError('Invalid timing data');\n        }\n        const request = node.request;\n        const connection = this.connectionPool.acquireActiveConnectionFromRequest(request);\n        const dnsResolutionTime = this.dns.getTimeUntilResolution(request, {\n            requestedAt: timingData.startTime,\n            shouldUpdateCache: true,\n        });\n        const calculation = connection.simulateDownloadUntil(request.transferSize - timingData.bytesDownloaded, {\n            dnsResolutionTime,\n            timeAlreadyElapsed: timingData.timeElapsed,\n            maximumTimeToElapse: timePeriodLength - timingData.timeElapsedOvershoot,\n        });\n        connection.setCongestionWindow(calculation.congestionWindow);\n        connection.setH2OverflowBytesDownloaded(calculation.extraBytesDownloaded);\n        if (isFinished) {\n            connection.setWarmed(true);\n            this.connectionPool.release(request);\n            this.markNodeAsComplete(node, totalElapsedTime, calculation.connectionTiming);\n        }\n        else {\n            timingData.timeElapsed += calculation.timeElapsed;\n            timingData.timeElapsedOvershoot += calculation.timeElapsed - timePeriodLength;\n            timingData.bytesDownloaded += calculation.bytesDownloaded;\n        }\n    }\n    computeFinalNodeTimings() {\n        const completeNodeTimingEntries = this.nodeTimings.getNodes().map(node => {\n            return [node, this.nodeTimings.getCompleted(node)];\n        });\n        // Most consumers will want the entries sorted by startTime, so insert them in that order\n        completeNodeTimingEntries.sort((a, b) => a[1].startTime - b[1].startTime);\n        // Trimmed version of type `Lantern.Simulation.NodeTiming`.\n        const nodeTimingEntries = completeNodeTimingEntries.map(([node, timing]) => {\n            return [\n                node,\n                {\n                    startTime: timing.startTime,\n                    endTime: timing.endTime,\n                    duration: timing.endTime - timing.startTime,\n                },\n            ];\n        });\n        return {\n            nodeTimings: new Map(nodeTimingEntries),\n            completeNodeTimings: new Map(completeNodeTimingEntries),\n        };\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Estimates the time taken to process all of the graph's nodes, returns the overall time along with\n     * each node annotated by start/end times.\n     *\n     * Simulator/connection pool are allowed to deviate from what was\n     * observed in the trace/devtoolsLog and start requests as soon as they are queued (i.e. do not\n     * wait around for a warm connection to be available if the original request was fetched on a warm\n     * connection).\n     */\n    simulate(graph, options) {\n        if (Graph.BaseNode.hasCycle(graph)) {\n            throw new Core.LanternError('Cannot simulate graph with cycle');\n        }\n        options = Object.assign({\n            label: undefined,\n        }, options);\n        // initialize the necessary data containers\n        this.dns = new DNSCache({ rtt: this._rtt });\n        this.initializeConnectionPool(graph);\n        this.initializeAuxiliaryData();\n        const nodesNotReadyToStart = this.nodes[NodeState.NotReadyToStart];\n        const nodesReadyToStart = this.nodes[NodeState.ReadyToStart];\n        const nodesInProgress = this.nodes[NodeState.InProgress];\n        const rootNode = graph.getRootNode();\n        rootNode.traverse(node => nodesNotReadyToStart.add(node));\n        let totalElapsedTime = 0;\n        let iteration = 0;\n        // root node is always ready to start\n        this.markNodeAsReadyToStart(rootNode, totalElapsedTime);\n        // loop as long as we have nodes in the queue or currently in progress\n        while (nodesReadyToStart.size || nodesInProgress.size) {\n            // move all possible queued nodes to in progress\n            for (const node of this.getNodesSortedByStartPosition()) {\n                this.startNodeIfPossible(node, totalElapsedTime);\n            }\n            if (!nodesInProgress.size) {\n                // Interplay between fromDiskCache and connectionReused can be incorrect,\n                // have to give up.\n                throw new Core.LanternError('Failed to start a node');\n            }\n            // set the available throughput for all connections based on # inflight\n            this.updateNetworkCapacity();\n            // find the time that the next node will finish\n            const minimumTime = this.findNextNodeCompletionTime();\n            totalElapsedTime += minimumTime;\n            // While this is no longer strictly necessary, it's always better than hanging\n            if (!Number.isFinite(minimumTime) || iteration > 100000) {\n                throw new Core.LanternError('Simulation failed, depth exceeded');\n            }\n            iteration++;\n            // update how far each node will progress until that point\n            for (const node of nodesInProgress) {\n                this.updateProgressMadeInTimePeriod(node, minimumTime, totalElapsedTime);\n            }\n        }\n        // `nodeTimings` are used for simulator consumers, `completeNodeTimings` kept for debugging.\n        const { nodeTimings, completeNodeTimings } = this.computeFinalNodeTimings();\n        ALL_SIMULATION_NODE_TIMINGS.set(options.label || 'unlabeled', completeNodeTimings);\n        return {\n            timeInMs: totalElapsedTime,\n            nodeTimings,\n        };\n    }\n    computeWastedMsFromWastedBytes(wastedBytes) {\n        const { throughput, observedThroughput } = this.options;\n        // https://github.com/GoogleChrome/lighthouse/pull/13323#issuecomment-962031709\n        // 0 throughput means the no (additional) throttling is expected.\n        // This is common for desktop + devtools throttling where throttling is additive and we don't want any additional.\n        const bitsPerSecond = throughput === 0 ? observedThroughput : throughput;\n        if (bitsPerSecond === 0) {\n            return 0;\n        }\n        const wastedBits = wastedBytes * 8;\n        const wastedMs = wastedBits / bitsPerSecond * 1000;\n        // This is an estimate of wasted time, so we won't be more precise than 10ms.\n        return Math.round(wastedMs / 10) * 10;\n    }\n    static get allNodeTimings() {\n        return ALL_SIMULATION_NODE_TIMINGS;\n    }\n    /**\n     * We attempt to start nodes by their observed start time using the request priority as a tie breaker.\n     * When simulating, just because a low priority image started 5ms before a high priority image doesn't mean\n     * it would have happened like that when the network was slower.\n     */\n    static computeNodeStartPosition(node) {\n        if (node.type === 'cpu') {\n            return node.startTime;\n        }\n        return node.startTime + (PriorityStartTimePenalty[node.request.priority] * 1000 * 1000 || 0);\n    }\n}\nexport { Simulator };\n//# sourceMappingURL=Simulator.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nexport const NetworkRequestTypes = {\n    XHR: 'XHR',\n    Fetch: 'Fetch',\n    EventSource: 'EventSource',\n    Script: 'Script',\n    Stylesheet: 'Stylesheet',\n    Image: 'Image',\n    Media: 'Media',\n    Font: 'Font',\n    Document: 'Document',\n    TextTrack: 'TextTrack',\n    WebSocket: 'WebSocket',\n    Other: 'Other',\n    Manifest: 'Manifest',\n    SignedExchange: 'SignedExchange',\n    Ping: 'Ping',\n    Preflight: 'Preflight',\n    CSPViolationReport: 'CSPViolationReport',\n    Prefetch: 'Prefetch',\n};\n//# sourceMappingURL=Lantern.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from './handlers/handlers.js';\nimport * as Lantern from './lantern/lantern.js';\nfunction createProcessedNavigation(parsedTrace, frameId, navigationId) {\n    const scoresByNav = parsedTrace.PageLoadMetrics.metricScoresByFrameId.get(frameId);\n    if (!scoresByNav) {\n        throw new Lantern.Core.LanternError('missing metric scores for frame');\n    }\n    const scores = scoresByNav.get(navigationId);\n    if (!scores) {\n        throw new Lantern.Core.LanternError('missing metric scores for specified navigation');\n    }\n    const getTimestampOrUndefined = (metric) => {\n        const metricScore = scores.get(metric);\n        if (!metricScore?.event) {\n            return;\n        }\n        return metricScore.event.ts;\n    };\n    const getTimestamp = (metric) => {\n        const metricScore = scores.get(metric);\n        if (!metricScore?.event) {\n            throw new Lantern.Core.LanternError(`missing metric: ${metric}`);\n        }\n        return metricScore.event.ts;\n    };\n    return {\n        timestamps: {\n            firstContentfulPaint: getTimestamp(\"FCP\" /* Handlers.ModelHandlers.PageLoadMetrics.MetricName.FCP */),\n            largestContentfulPaint: getTimestampOrUndefined(\"LCP\" /* Handlers.ModelHandlers.PageLoadMetrics.MetricName.LCP */),\n        },\n    };\n}\nfunction createParsedUrl(url) {\n    if (typeof url === 'string') {\n        url = new URL(url);\n    }\n    return {\n        scheme: url.protocol.split(':')[0],\n        // Intentional, DevTools uses different terminology\n        host: url.hostname,\n        securityOrigin: url.origin,\n    };\n}\n/**\n * Returns a map of `pid` -> `tid[]`.\n */\nfunction findWorkerThreads(trace) {\n    // TODO: WorkersHandler in Trace Engine needs to be updated to also include `pid` (only had `tid`).\n    const workerThreads = new Map();\n    const workerCreationEvents = ['ServiceWorker thread', 'DedicatedWorker thread'];\n    for (const event of trace.traceEvents) {\n        if (event.name !== 'thread_name' || !event.args.name) {\n            continue;\n        }\n        if (!workerCreationEvents.includes(event.args.name)) {\n            continue;\n        }\n        const tids = workerThreads.get(event.pid);\n        if (tids) {\n            tids.push(event.tid);\n        }\n        else {\n            workerThreads.set(event.pid, [event.tid]);\n        }\n    }\n    return workerThreads;\n}\nfunction createLanternRequest(parsedTrace, workerThreads, request) {\n    if (request.args.data.connectionId === undefined || request.args.data.connectionReused === undefined) {\n        throw new Lantern.Core.LanternError('Trace is too old');\n    }\n    let url;\n    try {\n        url = new URL(request.args.data.url);\n    }\n    catch (e) {\n        return;\n    }\n    const timing = request.args.data.timing ? {\n        // These two timings are not included in the trace.\n        workerFetchStart: -1,\n        workerRespondWithSettled: -1,\n        ...request.args.data.timing,\n    } :\n        undefined;\n    const networkRequestTime = timing ? timing.requestTime * 1000 : request.args.data.syntheticData.downloadStart / 1000;\n    let fromWorker = false;\n    const tids = workerThreads.get(request.pid);\n    if (tids?.includes(request.tid)) {\n        fromWorker = true;\n    }\n    // Trace Engine collects worker thread ids in a different manner than `workerThreads` does.\n    // AFAIK these should be equivalent, but in case they are not let's also check this for now.\n    if (parsedTrace.Workers.workerIdByThread.has(request.tid)) {\n        fromWorker = true;\n    }\n    // `initiator` in the trace does not contain the stack trace for JS-initiated\n    // requests. Instead, that is stored in the `stackTrace` property of the SyntheticNetworkRequest.\n    // There are some minor differences in the fields, accounted for here.\n    // Most importantly, there seems to be fewer frames in the trace than the equivalent\n    // events over the CDP. This results in less accuracy in determining the initiator request,\n    // which means less edges in the graph, which mean worse results.\n    // TODO: Should fix in Chromium.\n    const initiator = request.args.data.initiator ?? { type: \"other\" /* Protocol.Network.InitiatorType.Other */ };\n    if (request.args.data.stackTrace) {\n        const callFrames = request.args.data.stackTrace.map(f => {\n            return {\n                scriptId: String(f.scriptId),\n                url: f.url,\n                lineNumber: f.lineNumber - 1,\n                columnNumber: f.columnNumber - 1,\n                functionName: f.functionName,\n            };\n        });\n        initiator.stack = { callFrames };\n        // Note: there is no `parent` to set ...\n    }\n    let resourceType = request.args.data.resourceType;\n    if (request.args.data.initiator?.fetchType === 'xmlhttprequest') {\n        // @ts-expect-error yes XHR is a valid ResourceType. TypeScript const enums are so unhelpful.\n        resourceType = 'XHR';\n    }\n    else if (request.args.data.initiator?.fetchType === 'fetch') {\n        // @ts-expect-error yes Fetch is a valid ResourceType. TypeScript const enums are so unhelpful.\n        resourceType = 'Fetch';\n    }\n    // TODO: set decodedBodyLength for data urls in Trace Engine.\n    let resourceSize = request.args.data.decodedBodyLength ?? 0;\n    if (url.protocol === 'data:' && resourceSize === 0) {\n        const needle = 'base64,';\n        const index = url.pathname.indexOf(needle);\n        if (index !== -1) {\n            resourceSize = atob(url.pathname.substring(index + needle.length)).length;\n        }\n    }\n    return {\n        rawRequest: request,\n        requestId: request.args.data.requestId,\n        connectionId: request.args.data.connectionId,\n        connectionReused: request.args.data.connectionReused,\n        url: request.args.data.url,\n        protocol: request.args.data.protocol,\n        parsedURL: createParsedUrl(url),\n        documentURL: request.args.data.requestingFrameUrl,\n        rendererStartTime: request.ts / 1000,\n        networkRequestTime,\n        responseHeadersEndTime: request.args.data.syntheticData.downloadStart / 1000,\n        networkEndTime: request.args.data.syntheticData.finishTime / 1000,\n        transferSize: request.args.data.encodedDataLength,\n        resourceSize,\n        fromDiskCache: request.args.data.syntheticData.isDiskCached,\n        fromMemoryCache: request.args.data.syntheticData.isMemoryCached,\n        isLinkPreload: request.args.data.isLinkPreload,\n        finished: request.args.data.finished,\n        failed: request.args.data.failed,\n        statusCode: request.args.data.statusCode,\n        initiator,\n        timing,\n        resourceType,\n        mimeType: request.args.data.mimeType,\n        priority: request.args.data.priority,\n        frameId: request.args.data.frame,\n        fromWorker,\n        // Set later.\n        redirects: undefined,\n        redirectSource: undefined,\n        redirectDestination: undefined,\n        initiatorRequest: undefined,\n    };\n}\n/**\n * @param request The request to find the initiator of\n */\nfunction chooseInitiatorRequest(request, requestsByURL) {\n    if (request.redirectSource) {\n        return request.redirectSource;\n    }\n    const initiatorURL = Lantern.Graph.PageDependencyGraph.getNetworkInitiators(request)[0];\n    let candidates = requestsByURL.get(initiatorURL) || [];\n    // The (valid) initiator must come before the initiated request.\n    candidates = candidates.filter(c => {\n        return c.responseHeadersEndTime <= request.rendererStartTime && c.finished && !c.failed;\n    });\n    if (candidates.length > 1) {\n        // Disambiguate based on prefetch. Prefetch requests have type 'Other' and cannot\n        // initiate requests, so we drop them here.\n        const nonPrefetchCandidates = candidates.filter(cand => cand.resourceType !== Lantern.Types.NetworkRequestTypes.Other);\n        if (nonPrefetchCandidates.length) {\n            candidates = nonPrefetchCandidates;\n        }\n    }\n    if (candidates.length > 1) {\n        // Disambiguate based on frame. It's likely that the initiator comes from the same frame.\n        const sameFrameCandidates = candidates.filter(cand => cand.frameId === request.frameId);\n        if (sameFrameCandidates.length) {\n            candidates = sameFrameCandidates;\n        }\n    }\n    if (candidates.length > 1 && request.initiator.type === 'parser') {\n        // Filter to just Documents when initiator type is parser.\n        const documentCandidates = candidates.filter(cand => cand.resourceType === Lantern.Types.NetworkRequestTypes.Document);\n        if (documentCandidates.length) {\n            candidates = documentCandidates;\n        }\n    }\n    if (candidates.length > 1) {\n        // If all real loads came from successful preloads (url preloaded and\n        // loads came from the cache), filter to link rel=preload request(s).\n        const linkPreloadCandidates = candidates.filter(c => c.isLinkPreload);\n        if (linkPreloadCandidates.length) {\n            const nonPreloadCandidates = candidates.filter(c => !c.isLinkPreload);\n            const allPreloaded = nonPreloadCandidates.every(c => c.fromDiskCache || c.fromMemoryCache);\n            if (nonPreloadCandidates.length && allPreloaded) {\n                candidates = linkPreloadCandidates;\n            }\n        }\n    }\n    // Only return an initiator if the result is unambiguous.\n    return candidates.length === 1 ? candidates[0] : null;\n}\nfunction linkInitiators(lanternRequests) {\n    const requestsByURL = new Map();\n    for (const request of lanternRequests) {\n        const requests = requestsByURL.get(request.url) || [];\n        requests.push(request);\n        requestsByURL.set(request.url, requests);\n    }\n    for (const request of lanternRequests) {\n        const initiatorRequest = chooseInitiatorRequest(request, requestsByURL);\n        if (initiatorRequest) {\n            request.initiatorRequest = initiatorRequest;\n        }\n    }\n}\nfunction createNetworkRequests(trace, parsedTrace, startTime = 0, endTime = Number.POSITIVE_INFINITY) {\n    const workerThreads = findWorkerThreads(trace);\n    const lanternRequests = [];\n    for (const request of parsedTrace.NetworkRequests.byTime) {\n        if (request.ts >= startTime && request.ts < endTime) {\n            const lanternRequest = createLanternRequest(parsedTrace, workerThreads, request);\n            if (lanternRequest) {\n                lanternRequests.push(lanternRequest);\n            }\n        }\n    }\n    // Trace Engine consolidates all redirects into a single request object, but lantern needs\n    // an entry for each redirected request.\n    for (const request of [...lanternRequests]) {\n        if (!request.rawRequest) {\n            continue;\n        }\n        const redirects = request.rawRequest.args.data.redirects;\n        if (!redirects.length) {\n            continue;\n        }\n        const requestChain = [];\n        for (const redirect of redirects) {\n            const redirectedRequest = structuredClone(request);\n            redirectedRequest.networkRequestTime = redirect.ts / 1000;\n            redirectedRequest.rendererStartTime = redirectedRequest.networkRequestTime;\n            redirectedRequest.networkEndTime = (redirect.ts + redirect.dur) / 1000;\n            redirectedRequest.responseHeadersEndTime = redirectedRequest.networkEndTime;\n            redirectedRequest.timing = {\n                requestTime: redirectedRequest.networkRequestTime / 1000,\n                receiveHeadersStart: redirectedRequest.responseHeadersEndTime,\n                receiveHeadersEnd: redirectedRequest.responseHeadersEndTime,\n                proxyStart: -1,\n                proxyEnd: -1,\n                dnsStart: -1,\n                dnsEnd: -1,\n                connectStart: -1,\n                connectEnd: -1,\n                sslStart: -1,\n                sslEnd: -1,\n                sendStart: -1,\n                sendEnd: -1,\n                workerStart: -1,\n                workerReady: -1,\n                workerFetchStart: -1,\n                workerRespondWithSettled: -1,\n                pushStart: -1,\n                pushEnd: -1,\n            };\n            redirectedRequest.url = redirect.url;\n            redirectedRequest.parsedURL = createParsedUrl(redirect.url);\n            // TODO: Trace Engine is not retaining the actual status code.\n            redirectedRequest.statusCode = 302;\n            redirectedRequest.resourceType = undefined;\n            // TODO: Trace Engine is not retaining transfer size of redirected request.\n            redirectedRequest.transferSize = 400;\n            requestChain.push(redirectedRequest);\n            lanternRequests.push(redirectedRequest);\n        }\n        requestChain.push(request);\n        for (let i = 0; i < requestChain.length; i++) {\n            const request = requestChain[i];\n            if (i > 0) {\n                request.redirectSource = requestChain[i - 1];\n                request.redirects = requestChain.slice(0, i);\n            }\n            if (i !== requestChain.length - 1) {\n                request.redirectDestination = requestChain[i + 1];\n            }\n        }\n        // Apply the `:redirect` requestId convention: only redirects[0].requestId is the actual\n        // requestId, all the rest have n occurences of `:redirect` as a suffix.\n        for (let i = 1; i < requestChain.length; i++) {\n            requestChain[i].requestId = `${requestChain[i - 1].requestId}:redirect`;\n        }\n    }\n    linkInitiators(lanternRequests);\n    // This would already be sorted by rendererStartTime, if not for the redirect unwrapping done\n    // above.\n    return lanternRequests.sort((a, b) => a.rendererStartTime - b.rendererStartTime);\n}\nfunction collectMainThreadEvents(trace, parsedTrace) {\n    const Meta = parsedTrace.Meta;\n    const mainFramePids = Meta.mainFrameNavigations.length ? new Set(Meta.mainFrameNavigations.map(nav => nav.pid)) :\n        Meta.topLevelRendererIds;\n    const rendererPidToTid = new Map();\n    for (const pid of mainFramePids) {\n        const threads = Meta.threadsInProcess.get(pid) ?? [];\n        let found = false;\n        for (const [tid, thread] of threads) {\n            if (thread.args.name === 'CrRendererMain') {\n                rendererPidToTid.set(pid, tid);\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            continue;\n        }\n        // `CrRendererMain` can be missing if chrome is launched with the `--single-process` flag.\n        // In this case, page tasks will be run in the browser thread.\n        for (const [tid, thread] of threads) {\n            if (thread.args.name === 'CrBrowserMain') {\n                rendererPidToTid.set(pid, tid);\n                found = true;\n                break;\n            }\n        }\n    }\n    return trace.traceEvents.filter(e => rendererPidToTid.get(e.pid) === e.tid);\n}\nfunction createGraph(requests, trace, parsedTrace, url) {\n    const mainThreadEvents = collectMainThreadEvents(trace, parsedTrace);\n    // url defines the initial request that the Lantern graph starts at (the root node) and the\n    // main document request. These are equal if there are no redirects.\n    if (!url) {\n        url = {\n            requestedUrl: requests[0].url,\n            mainDocumentUrl: '',\n        };\n        let request = requests[0];\n        while (request.redirectDestination) {\n            request = request.redirectDestination;\n        }\n        url.mainDocumentUrl = request.url;\n    }\n    return Lantern.Graph.PageDependencyGraph.createGraph(mainThreadEvents, requests, url);\n}\nexport { createProcessedNavigation, createNetworkRequests, createGraph, };\n//# sourceMappingURL=LanternComputationData.js.map","// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport * as Insights from './insights/insights.js';\nimport * as Lantern from './lantern/lantern.js';\nimport * as LanternComputationData from './LanternComputationData.js';\nimport * as Types from './types/types.js';\nexport class TraceParseProgressEvent extends Event {\n    data;\n    static eventName = 'traceparseprogress';\n    constructor(data, init = { bubbles: true }) {\n        super(TraceParseProgressEvent.eventName, init);\n        this.data = data;\n    }\n}\nfunction calculateProgress(value, phase) {\n    // Finalize values should be [0.2...0.8]\n    if (phase === 0.8 /* ProgressPhase.FINALIZE */) {\n        return (value * (0.8 /* ProgressPhase.FINALIZE */ - 0.2 /* ProgressPhase.HANDLE_EVENT */)) + 0.2 /* ProgressPhase.HANDLE_EVENT */;\n    }\n    return value * phase;\n}\nexport class TraceProcessor extends EventTarget {\n    // We force the Meta handler to be enabled, so the TraceHandlers type here is\n    // the model handlers the user passes in and the Meta handler.\n    #traceHandlers;\n    #status = \"IDLE\" /* Status.IDLE */;\n    #modelConfiguration = Types.Configuration.defaults();\n    #data = null;\n    #insights = null;\n    static createWithAllHandlers() {\n        return new TraceProcessor(Handlers.ModelHandlers, Types.Configuration.defaults());\n    }\n    static getEnabledInsightRunners(parsedTrace) {\n        const enabledInsights = {};\n        for (const [name, insight] of Object.entries(Insights.InsightRunners)) {\n            const deps = insight.deps();\n            if (deps.some(dep => !parsedTrace[dep])) {\n                continue;\n            }\n            Object.assign(enabledInsights, { [name]: insight });\n        }\n        return enabledInsights;\n    }\n    constructor(traceHandlers, modelConfiguration) {\n        super();\n        this.#verifyHandlers(traceHandlers);\n        this.#traceHandlers = {\n            Meta: Handlers.ModelHandlers.Meta,\n            ...traceHandlers,\n        };\n        if (modelConfiguration) {\n            this.#modelConfiguration = modelConfiguration;\n        }\n        this.#passConfigToHandlers();\n    }\n    #passConfigToHandlers() {\n        for (const handler of Object.values(this.#traceHandlers)) {\n            // Bit of an odd double check, but without this TypeScript refuses to let\n            // you call the function as it thinks it might be undefined.\n            if ('handleUserConfig' in handler && handler.handleUserConfig) {\n                handler.handleUserConfig(this.#modelConfiguration);\n            }\n        }\n    }\n    /**\n     * When the user passes in a set of handlers, we want to ensure that we have all\n     * the required handlers. Handlers can depend on other handlers, so if the user\n     * passes in FooHandler which depends on BarHandler, they must also pass in\n     * BarHandler too. This method verifies that all dependencies are met, and\n     * throws if not.\n     **/\n    #verifyHandlers(providedHandlers) {\n        // Tiny optimisation: if the amount of provided handlers matches the amount\n        // of handlers in the Handlers.ModelHandlers object, that means that the\n        // user has passed in every handler we have. So therefore they cannot have\n        // missed any, and there is no need to iterate through the handlers and\n        // check the dependencies.\n        if (Object.keys(providedHandlers).length === Object.keys(Handlers.ModelHandlers).length) {\n            return;\n        }\n        const requiredHandlerKeys = new Set();\n        for (const [handlerName, handler] of Object.entries(providedHandlers)) {\n            requiredHandlerKeys.add(handlerName);\n            const deps = 'deps' in handler ? handler.deps() : [];\n            for (const depName of deps) {\n                requiredHandlerKeys.add(depName);\n            }\n        }\n        const providedHandlerKeys = new Set(Object.keys(providedHandlers));\n        // We always force the Meta handler to be enabled when creating the\n        // Processor, so if it is missing from the set the user gave us that is OK,\n        // as we will have enabled it anyway.\n        requiredHandlerKeys.delete('Meta');\n        for (const requiredKey of requiredHandlerKeys) {\n            if (!providedHandlerKeys.has(requiredKey)) {\n                throw new Error(`Required handler ${requiredKey} not provided.`);\n            }\n        }\n    }\n    reset() {\n        if (this.#status === \"PARSING\" /* Status.PARSING */) {\n            throw new Error('Trace processor can\\'t reset while parsing.');\n        }\n        const handlers = Object.values(this.#traceHandlers);\n        for (const handler of handlers) {\n            handler.reset();\n        }\n        this.#data = null;\n        this.#insights = null;\n        this.#status = \"IDLE\" /* Status.IDLE */;\n    }\n    async parse(traceEvents, options) {\n        if (this.#status !== \"IDLE\" /* Status.IDLE */) {\n            throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#status}`);\n        }\n        try {\n            this.#status = \"PARSING\" /* Status.PARSING */;\n            await this.#computeParsedTrace(traceEvents, Boolean(options.isFreshRecording));\n            if (this.#data && !options.isCPUProfile) { // We do not calculate insights for CPU Profiles.\n                this.#computeInsights(this.#data, traceEvents);\n            }\n            this.#status = \"FINISHED_PARSING\" /* Status.FINISHED_PARSING */;\n        }\n        catch (e) {\n            this.#status = \"ERRORED_WHILE_PARSING\" /* Status.ERRORED_WHILE_PARSING */;\n            throw e;\n        }\n    }\n    /**\n     * Run all the handlers and set the result to `#data`.\n     */\n    async #computeParsedTrace(traceEvents, freshRecording) {\n        /**\n         * We want to yield regularly to maintain responsiveness. If we yield too often, we're wasting idle time.\n         * We could do this by checking `performance.now()` regularly, but it's an expensive call in such a hot loop.\n         * `eventsPerChunk` is an approximated proxy metric.\n         * But how big a chunk? We're aiming for long tasks that are no smaller than 100ms and not bigger than 200ms.\n         * It's CPU dependent, so it should be calibrated on oldish hardware.\n         * Illustration of a previous change to `eventsPerChunk`: https://imgur.com/wzp8BnR\n         */\n        const eventsPerChunk = 50_000;\n        // Convert to array so that we are able to iterate all handlers multiple times.\n        const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n        // Reset.\n        for (const handler of sortedHandlers) {\n            handler.reset();\n        }\n        // Initialize.\n        for (const handler of sortedHandlers) {\n            handler.initialize?.(freshRecording);\n        }\n        // Handle each event.\n        for (let i = 0; i < traceEvents.length; ++i) {\n            // Every so often we take a break just to render.\n            if (i % eventsPerChunk === 0 && i) {\n                // Take the opportunity to provide status update events.\n                const percent = calculateProgress(i / traceEvents.length, 0.2 /* ProgressPhase.HANDLE_EVENT */);\n                this.dispatchEvent(new TraceParseProgressEvent({ percent }));\n                // TODO(paulirish): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n                await new Promise(resolve => setTimeout(resolve, 0));\n            }\n            const event = traceEvents[i];\n            for (let j = 0; j < sortedHandlers.length; ++j) {\n                sortedHandlers[j].handleEvent(event);\n            }\n        }\n        // Finalize.\n        for (const [i, handler] of sortedHandlers.entries()) {\n            if (handler.finalize) {\n                // Yield to the UI because finalize() calls can be expensive\n                // TODO(jacktfranklin): consider using `scheduler.yield()` or `scheduler.postTask(() => {}, {priority: 'user-blocking'})`\n                await new Promise(resolve => setTimeout(resolve, 0));\n                await handler.finalize();\n            }\n            const percent = calculateProgress(i / sortedHandlers.length, 0.8 /* ProgressPhase.FINALIZE */);\n            this.dispatchEvent(new TraceParseProgressEvent({ percent }));\n        }\n        // Handlers that depend on other handlers do so via .data(), which used to always\n        // return a shallow clone of its internal data structures. However, that pattern\n        // easily results in egregious amounts of allocation. Now .data() does not do any\n        // cloning, and it happens here instead so that users of the trace processor may\n        // still assume that the parsed data is theirs.\n        // See: crbug/41484172\n        const shallowClone = (value, recurse = true) => {\n            if (value instanceof Map) {\n                return new Map(value);\n            }\n            if (value instanceof Set) {\n                return new Set(value);\n            }\n            if (Array.isArray(value)) {\n                return [...value];\n            }\n            if (typeof value === 'object' && value && recurse) {\n                const obj = {};\n                for (const [key, v] of Object.entries(value)) {\n                    obj[key] = shallowClone(v, false);\n                }\n                return obj;\n            }\n            return value;\n        };\n        const parsedTrace = {};\n        for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n            const data = shallowClone(handler.data());\n            Object.assign(parsedTrace, { [name]: data });\n        }\n        this.dispatchEvent(new TraceParseProgressEvent({ percent: 1 /* ProgressPhase.CLONE */ }));\n        this.#data = parsedTrace;\n    }\n    get parsedTrace() {\n        if (this.#status !== \"FINISHED_PARSING\" /* Status.FINISHED_PARSING */) {\n            return null;\n        }\n        return this.#data;\n    }\n    get insights() {\n        if (this.#status !== \"FINISHED_PARSING\" /* Status.FINISHED_PARSING */) {\n            return null;\n        }\n        return this.#insights;\n    }\n    #createLanternContext(parsedTrace, traceEvents, frameId, navigationId) {\n        // Check for required handlers.\n        if (!parsedTrace.NetworkRequests || !parsedTrace.Workers || !parsedTrace.PageLoadMetrics) {\n            return;\n        }\n        if (!parsedTrace.NetworkRequests.byTime.length) {\n            throw new Lantern.Core.LanternError('No network requests found in trace');\n        }\n        const navStarts = parsedTrace.Meta.navigationsByFrameId.get(frameId);\n        const navStartIndex = navStarts?.findIndex(n => n.args.data?.navigationId === navigationId);\n        if (!navStarts || navStartIndex === undefined || navStartIndex === -1) {\n            throw new Lantern.Core.LanternError('Could not find navigation start');\n        }\n        const startTime = navStarts[navStartIndex].ts;\n        const endTime = navStartIndex + 1 < navStarts.length ? navStarts[navStartIndex + 1].ts : Number.POSITIVE_INFINITY;\n        const boundedTraceEvents = traceEvents.filter(e => e.ts >= startTime && e.ts < endTime);\n        // Lantern.Types.TraceEvent and Types.Events.Event represent the same\n        // object - a trace event - but one is more flexible than the other. It should be safe to cast between them.\n        const trace = {\n            traceEvents: boundedTraceEvents,\n        };\n        const requests = LanternComputationData.createNetworkRequests(trace, parsedTrace, startTime, endTime);\n        const graph = LanternComputationData.createGraph(requests, trace, parsedTrace);\n        const processedNavigation = LanternComputationData.createProcessedNavigation(parsedTrace, frameId, navigationId);\n        const networkAnalysis = Lantern.Core.NetworkAnalyzer.analyze(requests);\n        const simulator = Lantern.Simulation.Simulator.createSimulator({\n            // TODO(crbug.com/372674229): if devtools throttling was on, does this network analysis capture\n            // that? Do we need to set 'devtools' throttlingMethod?\n            networkAnalysis,\n            throttlingMethod: 'provided',\n        });\n        const computeData = { graph, simulator, processedNavigation };\n        const fcpResult = Lantern.Metrics.FirstContentfulPaint.compute(computeData);\n        const lcpResult = Lantern.Metrics.LargestContentfulPaint.compute(computeData, { fcpResult });\n        const interactiveResult = Lantern.Metrics.Interactive.compute(computeData, { lcpResult });\n        const tbtResult = Lantern.Metrics.TotalBlockingTime.compute(computeData, { fcpResult, interactiveResult });\n        const metrics = {\n            firstContentfulPaint: fcpResult,\n            interactive: interactiveResult,\n            largestContentfulPaint: lcpResult,\n            totalBlockingTime: tbtResult,\n        };\n        return { graph, simulator, metrics };\n    }\n    #computeInsightSets(insights, parsedTrace, insightRunners, context) {\n        const data = {};\n        for (const [name, insight] of Object.entries(insightRunners)) {\n            let insightResult;\n            try {\n                insightResult = insight.generateInsight(parsedTrace, context);\n            }\n            catch (err) {\n                insightResult = err;\n            }\n            Object.assign(data, { [name]: insightResult });\n        }\n        let id, urlString, navigation;\n        if (context.navigation) {\n            id = context.navigationId;\n            urlString = context.navigation.args.data?.documentLoaderURL ?? parsedTrace.Meta.mainFrameURL;\n            navigation = context.navigation;\n        }\n        else {\n            id = Types.Events.NO_NAVIGATION;\n            urlString = parsedTrace.Meta.mainFrameURL;\n        }\n        let url;\n        try {\n            url = new URL(urlString);\n        }\n        catch {\n            // We're pretty sure this only happens for our test fixture: missing-url.json.gz. Shouldn't\n            // happen for real traces.\n            return;\n        }\n        const insightSets = {\n            id,\n            url,\n            navigation,\n            frameId: context.frameId,\n            bounds: context.bounds,\n            data,\n        };\n        insights.set(insightSets.id, insightSets);\n    }\n    /**\n     * Run all the insights and set the result to `#insights`.\n     */\n    #computeInsights(parsedTrace, traceEvents) {\n        this.#insights = new Map();\n        const enabledInsightRunners = TraceProcessor.getEnabledInsightRunners(parsedTrace);\n        const navigations = parsedTrace.Meta.mainFrameNavigations.filter(navigation => navigation.args.frame && navigation.args.data?.navigationId);\n        // Check if there is a meaningful chunk of work happening prior to the first navigation.\n        // If so, we run the insights on that initial bounds.\n        // Otherwise, there are no navigations and we do a no-navigation insights pass on the entire trace.\n        if (navigations.length) {\n            const bounds = Helpers.Timing.traceWindowFromMicroSeconds(parsedTrace.Meta.traceBounds.min, navigations[0].ts);\n            // When using \"Record and reload\" option, it typically takes ~5ms. So use 50ms to be safe.\n            const threshold = Helpers.Timing.millisecondsToMicroseconds(50);\n            if (bounds.range > threshold) {\n                const context = {\n                    bounds,\n                    frameId: parsedTrace.Meta.mainFrameId,\n                };\n                this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n            }\n            // If threshold is not met, then the very beginning of the trace is ignored by the insights engine.\n        }\n        else {\n            const context = {\n                bounds: parsedTrace.Meta.traceBounds,\n                frameId: parsedTrace.Meta.mainFrameId,\n            };\n            this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n        }\n        // Now run the insights for each navigation in isolation.\n        for (const [i, navigation] of navigations.entries()) {\n            // The above filter guarantees these are present.\n            const frameId = navigation.args.frame;\n            const navigationId = navigation.args.data?.navigationId;\n            // The lantern sub-context is optional on InsightSetContext, so not setting it is OK.\n            // This is also a hedge against an error inside Lantern resulting in breaking the entire performance panel.\n            // Additionally, many trace fixtures are too old to be processed by Lantern.\n            let lantern;\n            try {\n                lantern = this.#createLanternContext(parsedTrace, traceEvents, frameId, navigationId);\n            }\n            catch (e) {\n                // Don't allow an error in constructing the Lantern graphs to break the rest of the trace processor.\n                // Log unexpected errors, but suppress anything that occurs from a trace being too old.\n                // Otherwise tests using old fixtures become way too noisy.\n                const expectedErrors = [\n                    'mainDocumentRequest not found',\n                    'missing metric scores for main frame',\n                    'missing metric: FCP',\n                    'missing metric: LCP',\n                    'No network requests found in trace',\n                    'Trace is too old',\n                ];\n                if (!(e instanceof Lantern.Core.LanternError)) {\n                    // If this wasn't a managed LanternError, the stack trace is likely needed for debugging.\n                    console.error(e);\n                }\n                else if (!expectedErrors.some(err => e.message === err)) {\n                    // To reduce noise from tests, only print errors that are not expected to occur because a trace is\n                    // too old (for which there is no single check).\n                    console.error(e.message);\n                }\n            }\n            const min = navigation.ts;\n            const max = i + 1 < navigations.length ? navigations[i + 1].ts : parsedTrace.Meta.traceBounds.max;\n            const bounds = Helpers.Timing.traceWindowFromMicroSeconds(min, max);\n            const context = {\n                bounds,\n                frameId,\n                navigation,\n                navigationId,\n                lantern,\n            };\n            this.#computeInsightSets(this.#insights, parsedTrace, enabledInsightRunners, context);\n        }\n    }\n}\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(traceHandlers) {\n    const sortedMap = new Map();\n    const visited = new Set();\n    const visitHandler = (handlerName) => {\n        if (sortedMap.has(handlerName)) {\n            return;\n        }\n        if (visited.has(handlerName)) {\n            let stackPath = '';\n            for (const handler of visited) {\n                if (stackPath || handler === handlerName) {\n                    stackPath += `${handler}->`;\n                }\n            }\n            stackPath += handlerName;\n            throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n        }\n        visited.add(handlerName);\n        const handler = traceHandlers[handlerName];\n        if (!handler) {\n            return;\n        }\n        const deps = handler.deps?.();\n        if (deps) {\n            deps.forEach(visitHandler);\n        }\n        sortedMap.set(handlerName, handler);\n    };\n    for (const handlerName of Object.keys(traceHandlers)) {\n        visitHandler(handlerName);\n    }\n    return sortedMap;\n}\n//# sourceMappingURL=Processor.js.map","// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport { TraceParseProgressEvent, TraceProcessor } from './Processor.js';\nimport * as Types from './types/types.js';\n/**\n * The Model is responsible for parsing arrays of raw trace events and storing the\n * resulting data. It can store multiple traces at once, and can return the data for\n * any of them.\n *\n * Most uses of this class should be through `createWithAllHandlers`, but\n * `createWithSubsetOfHandlers` can be used to run just some handlers.\n **/\nexport class Model extends EventTarget {\n    #traces = [];\n    #syntheticEventsManagerByTrace = [];\n    #nextNumberByDomain = new Map();\n    #recordingsAvailable = [];\n    #lastRecordingIndex = 0;\n    #processor;\n    #config = Types.Configuration.defaults();\n    static createWithAllHandlers(config) {\n        return new Model(Handlers.ModelHandlers, config);\n    }\n    /**\n     * Runs only the provided handlers.\n     *\n     * Callers must ensure they are providing all dependant handlers (although Meta is included automatically),\n     * and must know that the result of `.parsedTrace` will be limited to the handlers provided, even though\n     * the type won't reflect that.\n     */\n    static createWithSubsetOfHandlers(traceHandlers, config) {\n        return new Model(traceHandlers, config);\n    }\n    constructor(handlers, config) {\n        super();\n        if (config) {\n            this.#config = config;\n        }\n        this.#processor = new TraceProcessor(handlers, this.#config);\n    }\n    /**\n     * Parses an array of trace events into a structured object containing all the\n     * information parsed by the trace handlers.\n     * You can `await` this function to pause execution until parsing is complete,\n     * or instead rely on the `ModuleUpdateEvent` that is dispatched when the\n     * parsing is finished.\n     *\n     * Once parsed, you then have to call the `parsedTrace` method, providing an\n     * index of the trace you want to have the data for. This is because any model\n     * can store a number of traces. Each trace is given an index, which starts at 0\n     * and increments by one as a new trace is parsed.\n     *\n     * @example\n     * // Awaiting the parse method() to block until parsing complete\n     * await this.traceModel.parse(events);\n     * const data = this.traceModel.parsedTrace(0)\n     *\n     * @example\n     * // Using an event listener to be notified when tracing is complete.\n     * this.traceModel.addEventListener(Trace.ModelUpdateEvent.eventName, (event) => {\n     *   if(event.data.data === 'done') {\n     *     // trace complete\n     *     const data = this.traceModel.parsedTrace(0);\n     *   }\n     * });\n     * void this.traceModel.parse(events);\n     **/\n    async parse(traceEvents, config) {\n        const metadata = config?.metadata || {};\n        const isFreshRecording = config?.isFreshRecording || false;\n        const isCPUProfile = metadata?.dataOrigin === \"CPUProfile\" /* Types.File.DataOrigin.CPU_PROFILE */;\n        // During parsing, periodically update any listeners on each processors'\n        // progress (if they have any updates).\n        const onTraceUpdate = (event) => {\n            const { data } = event;\n            this.dispatchEvent(new ModelUpdateEvent({ type: \"PROGRESS_UPDATE\" /* ModelUpdateType.PROGRESS_UPDATE */, data }));\n        };\n        this.#processor.addEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n        // Create a parsed trace file.  It will be populated with data from the processor.\n        const file = {\n            traceEvents,\n            metadata,\n            parsedTrace: null,\n            traceInsights: null,\n        };\n        try {\n            // Wait for all outstanding promises before finishing the async execution,\n            // but perform all tasks in parallel.\n            const syntheticEventsManager = Helpers.SyntheticEvents.SyntheticEventsManager.createAndActivate(traceEvents);\n            await this.#processor.parse(traceEvents, {\n                isFreshRecording,\n                isCPUProfile,\n            });\n            this.#storeParsedFileData(file, this.#processor.parsedTrace, this.#processor.insights);\n            // We only push the file onto this.#traces here once we know it's valid\n            // and there's been no errors in the parsing.\n            this.#traces.push(file);\n            this.#syntheticEventsManagerByTrace.push(syntheticEventsManager);\n        }\n        catch (e) {\n            throw e;\n        }\n        finally {\n            // All processors have finished parsing, no more updates are expected.\n            this.#processor.removeEventListener(TraceParseProgressEvent.eventName, onTraceUpdate);\n            // Finally, update any listeners that all processors are 'done'.\n            this.dispatchEvent(new ModelUpdateEvent({ type: \"COMPLETE\" /* ModelUpdateType.COMPLETE */, data: 'done' }));\n        }\n    }\n    #storeParsedFileData(file, data, insights) {\n        file.parsedTrace = data;\n        file.traceInsights = insights;\n        this.#lastRecordingIndex++;\n        let recordingName = `Trace ${this.#lastRecordingIndex}`;\n        let origin = null;\n        if (file.parsedTrace) {\n            origin = Helpers.Trace.extractOriginFromTrace(file.parsedTrace.Meta.mainFrameURL);\n            if (origin) {\n                const nextSequenceForDomain = Platform.MapUtilities.getWithDefault(this.#nextNumberByDomain, origin, () => 1);\n                recordingName = `${origin} (${nextSequenceForDomain})`;\n                this.#nextNumberByDomain.set(origin, nextSequenceForDomain + 1);\n            }\n        }\n        this.#recordingsAvailable.push(recordingName);\n    }\n    lastTraceIndex() {\n        return this.size() - 1;\n    }\n    /**\n     * Returns the parsed trace data indexed by the order in which it was stored.\n     * If no index is given, the last stored parsed data is returned.\n     */\n    parsedTrace(index = this.#traces.length - 1) {\n        return this.#traces.at(index)?.parsedTrace ?? null;\n    }\n    traceInsights(index = this.#traces.length - 1) {\n        return this.#traces.at(index)?.traceInsights ?? null;\n    }\n    metadata(index = this.#traces.length - 1) {\n        return this.#traces.at(index)?.metadata ?? null;\n    }\n    overrideModifications(index, newModifications) {\n        if (this.#traces[index]) {\n            this.#traces[index].metadata.modifications = newModifications;\n        }\n    }\n    rawTraceEvents(index = this.#traces.length - 1) {\n        return this.#traces.at(index)?.traceEvents ?? null;\n    }\n    syntheticTraceEventsManager(index = this.#traces.length - 1) {\n        return this.#syntheticEventsManagerByTrace.at(index) ?? null;\n    }\n    size() {\n        return this.#traces.length;\n    }\n    deleteTraceByIndex(recordingIndex) {\n        this.#traces.splice(recordingIndex, 1);\n        this.#recordingsAvailable.splice(recordingIndex, 1);\n    }\n    getRecordingsAvailable() {\n        return this.#recordingsAvailable;\n    }\n    resetProcessor() {\n        this.#processor.reset();\n    }\n}\nexport class ModelUpdateEvent extends Event {\n    data;\n    static eventName = 'modelupdate';\n    constructor(data) {\n        super(ModelUpdateEvent.eventName);\n        this.data = data;\n    }\n}\nexport function isModelUpdateDataComplete(eventData) {\n    return eventData.type === \"COMPLETE\" /* ModelUpdateType.COMPLETE */;\n}\nexport function isModelUpdateDataProgress(eventData) {\n    return eventData.type === \"PROGRESS_UPDATE\" /* ModelUpdateType.PROGRESS_UPDATE */;\n}\n//# sourceMappingURL=ModelImpl.js.map"],"names":["filmStripCache","fromParsedTrace","parsedTrace","customZeroTime","frames","zeroTime","spanTime","fromCache","screenshotEvent","frame","result","Platform.MapUtilities.getWithDefault","frameClosestToTimestamp","filmStrip","searchTimestamp","closestFrameIndexBeforeTimestamp","Platform.ArrayUtilities.nearestIndexFromEnd","buildTrackDataFromExtensionEntries","extensionEntries","extensionTrackData","entryToNode","dataByTrack","entry","key","batchedData","trackData","entries","sortTraceEventsInPlace","canBuildTreesFromEvents","node","treify","NON_RENDER_BLOCKING_VALUES","isSyntheticNetworkRequestEventRenderBlocking","event","getNonResolved","Types.Events.isProfileCall","Types.Events.isSyntheticNetworkRequest","Types.Events.isDecodeImage","paintEvent","Types.Events.isDrawLazyPixelRef","Types.Events.isParseHTML","animations","animationsSyntheticEvents","handlerState","reset","handleEvent","Types.Events.isAnimation","finalize","syntheticEvents","Helpers.Trace.createMatchedSortedSyntheticEvents","data","performanceMeasureEvents","performanceMarkEvents","consoleTimings","timestampEvents","resourceTimingNames","navTimingNames","ignoredNames","userTimingComparator","a","b","originalArray","aBeginTime","bBeginTime","aDuration","bDuration","aEndTime","bEndTime","Types.Events.isPerformanceMeasure","Types.Events.isPerformanceMark","Types.Events.isConsoleTime","Types.Events.isTimeStamp","asyncEvents","e","extensionFlameChartEntries","extensionMarkers","_event","createExtensionFlameChartEntries","pairedMeasures","userTimingsData","marks","mergedRawExtensionEvents","Helpers.Trace.mergeEventsInOrder","extractExtensionEntries","Helpers.Extensions.buildTrackDataFromExtensionEntries","timings","timing","extensionPayload","extensionDataInTiming","extensionSyntheticEntry","Types.Events.ProcessID","Types.Events.ThreadID","Types.Events.isSyntheticUserTiming","Types.Extensions.isExtensionPayloadMarker","extensionMarker","Helpers.SyntheticEvents.SyntheticEventsManager","Types.Extensions.isExtensionPayloadTrackEntry","extensionTrackEntry","timingDetail","detailObj","Types.Extensions.isValidExtensionPayload","deps","paintEvents","snapshotEvents","paintToSnapshotMap","lastPaintForLayerId","currentMainFrameLayerTreeId","updateLayerEvents","relevantEvents","initialize","Types.Events.isPaint","Types.Events.isDisplayListItemListSnapshot","Types.Events.isUpdateLayer","Types.Events.isSetLayerId","metaData","metaHandlerData","Helpers.Trace.sortTraceEventsInPlace","lastUpdateLayerEventForThread","updateEvent","getThreadTypeForRendererThread","pid","thread","auctionWorkletsData","threadType","threadsInRenderer","rendererData","foundThreads","process","tid","threadsInTrace","threadsFromRenderer","allEvents","model","TimelineFrameModel","rendererHandlerData","layerTreeHandlerData","isFrameEvent","Types.Events.isBeginFrame","Types.Events.isDroppedFrame","Types.Events.isRequestMainThreadFrame","Types.Events.isBeginMainThreadFrame","Types.Events.isNeedsBeginFrameChanged","Types.Events.isCommit","Types.Events.isCompositeLayers","Types.Events.isActivateLayerTree","Types.Events.isDrawFrame","entryIsTopLevel","#frames","#frameById","#beginFrameQueue","TimelineFrameBeginFrameQueue","#lastFrame","#mainFrameCommitted","#mainFrameRequested","#lastLayerTree","#framePendingActivation","#framePendingCommit","#lastBeginFrame","#lastNeedsBeginFrame","#lastTaskBeginTime","#layerTreeId","#activeProcessId","#activeThreadId","#layerTreeData","layerTreeData","threadData","Threads.threadsInRenderer","#addTraceEvents","#handleBeginFrame","startTime","seqId","#startFrame","#handleDroppedFrame","isPartial","#handleDrawFrame","framesToVisualize","isLastFrameIdle","#commitPendingFrame","#handleActivateLayerTree","#handleRequestMainThreadFrame","#handleCommit","#handleLayerTreeSnapshot","layerTree","#handleNeedFrameChanged","needsBeginFrame","#flushFrame","TimelineFrame","Types.Timing.MicroSeconds","endTime","lastFrame","newFramesLength","events","mainFrameId","j","i","#addTraceEvent","Types.Events.isLayerTreeHostImplSnapshot","#processCompositorEvents","#addMainThreadTraceEvent","MAIN_FRAME_MARKERS","PendingFrame","snapshot","LayerPaintEvent","startTimeOffset","#event","#snapshot","rect","pictureData","triggerTime","BeginFrameInfo","isDropped","currentSeqId","framesWithinWindow","firstFrame","Platform.ArrayUtilities.lowerBound","time","eventsInProcessThread","mainGPUThreadTasks","Types.Events.isGPUTask","Helpers.Trace.addEventToProcessThread","gpuProcessId","gpuThreadId","gpuThreadsForProcess","paintImageEvents","decodeLazyPixelRefEvents","paintImageByLazyPixelRef","eventToPaintImage","Types.Events.isPaintImage","forProcess","forThread","Types.Events.isDecodeLazyPixelRef","lastPaintEvent","lastPaintImageEventOnThread","lastDecodeLazyPixelRef","lastScheduleStyleRecalcByFrame","lastInvalidationEventForFrame","lastUpdateLayoutTreeByFrame","postMessageHandlerEvents","schedulePostMessageEventByTraceId","eventToInitiatorMap","initiatorToEventsMap","requestAnimationFrameEventsById","timerInstallEventsById","requestIdleCallbackEventsById","webSocketCreateEventsById","storeInitiator","eventsForInitiator","Types.Events.isScheduleStyleRecalculation","Types.Events.isUpdateLayoutTree","scheduledStyleForFrame","Types.Events.isInvalidateLayout","invalidationInitiator","lastUpdateLayoutTreeForFrame","Helpers.Timing.eventTimingsMicroSeconds","initiatorOfUpdateLayout","Types.Events.isLayout","lastInvalidation","Types.Events.isRequestAnimationFrame","Types.Events.isFireAnimationFrame","matchingRequestEvent","Types.Events.isTimerInstall","Types.Events.isTimerFire","matchingInstall","Types.Events.isRequestIdleCallback","Types.Events.isFireIdleCallback","Types.Events.isWebSocketCreate","Types.Events.isWebSocketInfo","Types.Events.isWebSocketTransfer","matchingCreateEvent","Types.Events.isHandlePostMessage","Types.Events.isSchedulePostMessage","traceId","finalizeInitiatorRelationship","handlerEvent","matchingSchedulePostMesssageEvent","invalidationsForEvent","invalidationCountForEvent","lastRecalcStyleEvent","hasPainted","allInvalidationTrackingEvents","maxInvalidationsPerEvent","handleUserConfig","userConfig","addInvalidationToEvent","invalidation","existingInvalidations","count","Types.Events.isLayoutInvalidationTracking","recalcFrameId","Types.Events.isInvalidationTracking","Types.Events.isScheduleStyleInvalidationTracking","Types.Events.isStyleRecalcInvalidationTracking","Types.Events.isStyleInvalidatorInvalidationTracking","recalcEndTime","layoutFrame","imageByDOMNodeId","Types.Events.isLargestImagePaintCandidate","textPaintByDOMNodeId","Types.Events.isLargestTextPaintCandidate","unpairedAsyncEvents","syntheticScreenshots","Types.Events.isScreenshot","Types.Events.isPipelineReporter","pipelineReporterEvents","evt","frameSequenceId","presentationTs","snapshotEvent","cat","name","ph","syntheticEvent","MAX_CLUSTER_DURATION","Helpers.Timing.millisecondsToMicroseconds","Types.Timing.MilliSeconds","MAX_SHIFT_TIME_DELTA","layoutShiftEvents","layoutInvalidationEvents","scheduleStyleInvalidationEvents","renderFrameImplCreateChildFrameEvents","domLoadingEvents","beginRemoteFontLoadEvents","backendNodeIds","prePaintEvents","sessionMaxScore","clsWindowID","clusters","clustersByNavigationId","scoreRecords","Types.Events.isLayoutShift","Types.Events.isPrePaint","Types.Events.isRenderFrameImplCreateChildFrame","Types.Events.isDomLoading","Types.Events.isBeginRemoteFontLoad","traceWindowFromTime","updateTraceWindowMax","traceWindow","newMax","findScreenshots","timestamp","screenshots","screenshotsHandlerData","before","Helpers.Trace.findPreviousEventBeforeTimestamp","after","buildScoreRecords","traceBounds","cluster","clusterScore","collectNodes","layoutShift","layoutInvalidation","scheduleStyleInvalidation","buildLayoutShiftsClusters","navigationsByFrameId","navigations","firstShiftTime","lastShiftTime","lastShiftNavigation","clusterDurationExceeded","maxTimeDeltaSinceLastShiftExceeded","currentShiftNavigation","nav","hasNavigated","clusterStartTime","endTimeByMaxSessionDuration","endTimeByMaxShiftGap","endTimeByNavigation","previousClusterEndTime","currentCluster","navigationId","Types.Events.NO_NAVIGATION","timeFromNavigation","shift","weightedScore","windowID","clusterEndByMaxDuration","clusterEndByMaxGap","nextNavigationIndex","Platform.ArrayUtilities.nearestIndexFromBeginning","nextNavigationTime","clusterEnd","largestScore","worstShiftEvent","ts","score","lastShiftTimings","scoreClassificationForLayoutShift","state","updateCountersByProcess","Types.Events.isUpdateCounters","countersForProcess","MILLISECONDS_TO_MICROSECONDS","SECONDS_TO_MICROSECONDS","webSocketData","requestMap","requestsById","requestsByOrigin","requestsByTime","networkRequestEventByInitiatorUrl","storeTraceEventWithRequestId","requestId","value","traceEvents","target","values","firstPositiveValueInList","Types.Events.isResourceChangePriority","Types.Events.isResourceWillSendRequest","Types.Events.isResourceSendRequest","Types.Events.isResourceReceiveResponse","Types.Events.isResourceReceivedData","Types.Events.isResourceFinish","Types.Events.isResourceMarkAsCached","identifier","rendererProcessesByFrame","request","redirects","sendRequest","nextSendRequest","dur","willSendRequest","nextWillSendRequest","isPushedResource","isDiskCached","isMemoryCached","firstSendRequest","finalSendRequest","initialPriority","finalPriority","endRedirectTime","finishTime","networkDuration","processingDuration","redirectionDuration","queueingFromTraceData","queueing","Platform.NumberUtilities.clamp","stalled","sendStartTime","waiting","downloadStart","download","totalTime","dnsLookup","ssl","proxyNegotiation","requestSent","initialConnection","url","renderBlocking","encodedDataLength","decodedBodyLength","parsedUrl","isHttps","requestingFrameUrl","Helpers.Trace.activeURLForFrameAtTime","networkEvent","requests","Helpers.Network.isSyntheticNetworkRequestEventRenderBlocking","initiatorUrl","Helpers.Trace.getZeroIndexedStackTraceForEvent","initiatedEvents","initiatedEvent","finalizeWebSocketData","startEvent","endEvent","Types.Events.isWebSocketDestroy","createSyntheticWebSocketConnection","firstRecordedEvent","startTs","duration","mainEvent","Types.Events.isTracingStartedInBrowser","Types.Events.isCommitLoad","frameData","metricScoresByFrameId","allMarkerEvents","pageLoadEventsArray","selectedLCPCandidateEvents","Types.Events.eventIsPageLoadEvent","storePageLoadMetricAgainstNavigationId","navigation","frameId","getFrameIdForPageLoadEvent","rendererProcessesInFrame","Types.Events.isNavigationStart","Types.Events.isFirstContentfulPaint","fcpTime","classification","scoreClassificationForFirstContentfulPaint","storeMetricScore","Types.Events.isFirstPaint","paintTime","Types.Events.isMarkDOMContent","dclTime","metricScore","scoreClassificationForDOMContentLoaded","Types.Events.isInteractiveTime","ttiValue","tti","scoreClassificationForTimeToInteractive","tbtValue","tbt","scoreClassificationForTotalBlockingTime","Types.Events.isMarkLoad","loadTime","Types.Events.isLargestContentfulPaintCandidate","candidateIndex","lcpTime","lcp","scoreClassificationForLargestContentfulPaint","metricsByNavigation","lastLCPCandidate","lastLCPCandidateEvent","lastCandidateIndex","Platform.assertNever","metrics","getNavigationForPageLoadEvent","navigationsByNavigationId","Helpers.Trace.getNavigationForTraceEvent","fcpScoreInMicroseconds","FCP_GOOD_TIMING","Helpers.Timing.secondsToMicroseconds","Types.Timing.Seconds","FCP_MEDIUM_TIMING","scoreClassification","ttiTimeInMicroseconds","TTI_GOOD_TIMING","TTI_MEDIUM_TIMING","lcpTimeInMicroseconds","LCP_GOOD_TIMING","LCP_MEDIUM_TIMING","_dclTimeInMicroseconds","tbtTimeInMicroseconds","TBT_GOOD_TIMING","TBT_MEDIUM_TIMING","gatherFinalLCPEvents","allFinalLCPEvents","dataForAllNavigations","lcpInNavigation","pageLoadEvent","mainFrame","allEventsButLCP","Types.Events.isMarkerEvent","lastUpdateLayoutTreeEvent","selectorDataForUpdateLayoutTree","Types.Events.isSelectorStats","serverTimings","extractServerTimings","RESPONSE_START_METRIC_NAME","RESPONSE_END_METRIC_NAME","networkData","timingsInRequest","header","headerName","Platform.ServerTiming.ServerTiming","serverStart","serverEnd","serverStartInMicro","serverEndInMicro","createSyntheticServerTiming","clientStart","clientEndTime","offset","convertedServerTimings","convertedTimestamp","origin","serverTiming","beginCommitCompositorFrameEvents","parseMetaViewportEvents","LONG_INTERACTION_THRESHOLD","INP_GOOD_TIMING","INP_MEDIUM_TIMING","longestInteractionEvent","interactionEvents","interactionEventsWithNoNesting","eventTimingEndEventsById","eventTimingStartEventsForInteractions","Types.Events.isBeginCommitCompositorFrame","Types.Events.isParseMetaViewport","Types.Events.isEventTiming","Types.Events.isEventTimingEnd","Types.Events.isEventTimingStart","interactionId","pointerEventTypes","keyboardEventTypes","categoryOfInteraction","interaction","removeNestedInteractions","interactions","earliestEventForEndTimePerCategory","storeEventIfEarliestForCategoryAndEndTime","category","earliestEventForEndTime","earliestCurrentEvent","currentProcessingDuration","writeSyntheticTimespans","keptEvents","eventsByEndTime","eventA","eventB","interactionStartEvent","processingStartRelativeToTraceTime","processingEndRelativeToTraceTime","interactionEvent","scoreClassificationForInteractionToNextPaint","warningsPerEvent","eventsPerWarning","allEventsStack","jsInvokeStack","taskReflowEvents","FORCED_REFLOW_THRESHOLD","LONG_MAIN_THREAD_TASK_THRESHOLD","storeWarning","warning","existingWarnings","existingEvents","processForcedReflowWarning","Helpers.Timing.eventTimingsMilliSeconds","accomodateEventInStack","Types.Events.isJSInvocationEvent","reflowEvent","stack","pushEventToStack","nextItem","longInteractions","userInteractionsHandlerData","sessionIdEvents","workerIdByThread","workerURLById","Types.Events.isTracingSessionIdForWorker","sessionIdEvent","getInsight","insightName","insights","insightSets","insight","findRequest","context","req","findLCPRequest","lcpEvent","lcpNodeId","imagePaint","lcpUrl","lcpRequest","ACTIONABLE_FAILURE_REASONS","INVALIDATION_WINDOW","isInInvalidationWindow","targetEvent","eventEnd","getNonCompositedFailure","animationEvent","failures","beginEvent","instantEvents","failureMask","unsupportedProperties","failureReasons","reason","failure","getNonCompositedFailureRootCauses","animationEvents","shiftsByPrePaint","rootCausesByShift","allAnimationFailures","animation","nextPrePaint","getNextPrePaintEvent","shifts","rootCausesForShift","getShiftsByPrePaintEvents","layoutShifts","prePaintEvent","firstShiftIndex","nextPrePaintIndex","prePaint","getIframeRootCauses","iframeCreatedEvents","iframeEvent","domEvent","maxIframe","getFontRootCauses","networkRequests","fontRequests","generateInsight","isWithinContext","Helpers.Timing.eventIsInBounds","compositeAnimationEvents","iframeEvents","clusterKey","worstCluster","animationFailures","relatedEvents","TOO_SLOW_THRESHOLD_MS","TARGET_MS","IGNORE_THRESHOLD_IN_BYTES","getServerResponseTime","ms","Helpers.Timing.microSecondsToMilliseconds","getCompressionSavings","patterns","compressionTypes","p","originalSize","estimatedSavings","documentRequest","serverResponseTime","serverResponseTooSlow","overallSavingsMs","redirectDuration","metricSavings","fonts","display","wastedTime","wastedTimeMicro","Platform.NumberUtilities.floor","savings","f","longestByInteractionId","longest","normalizedInteractionEvents","highPercentileIndex","anyValuesNaN","v","breakdownPhases","docRequest","lcpMs","docReqTiming","firstDocByteTs","firstDocByteTiming","ttfb","renderDelay","lcpStartTs","requestStart","lcpReqEndTs","requestEnd","loadDelay","frameMetrics","navMetrics","InsightWarning","lcpTs","initiatedByMainDoc","imgPreloadedOrFoundInHTML","imageLoadingAttr","imageFetchPriorityHint","earliestDiscoveryTime","MINIMUM_WASTED_MS","getNodesAndTimingByRequestId","nodeTimings","requestIdToNode","nodeTiming","estimateSavingsWithGraphs","deferredIds","lanternContext","simulator","fcpGraph","adjustedNodeTimings","totalChildNetworkBytes","minimalFCPGraph","estimateBeforeInline","originalTransferSize","safeTransferSize","estimateAfterInline","hasImageLCP","computeSavings","renderBlockingRequests","nodesAndTimingsByRequestId","requestIdToWastedMs","deferredNodeIds","nodeAndTiming","wastedMs","firstPaintTs","priority","isBlockingScript","aggregateSelectorStats","selectorMap","SelectorTimingsKey","findTiming","selectorStatsData","selectorTimings","totalElapsedUs","totalMatchAttempts","totalMatchCount","sortByElapsedMs","sortByMatchAttempts","getChromeExtensionOrigin","makeUpChromeExtensionEntity","entityCache","extensionName","host","cachedEntity","chromeExtensionEntity","makeUpEntity","rootDomain","ThirdPartyWeb.ThirdPartyWeb","unrecognizedEntity","getSelfTimeByUrl","selfTimeByUrl","Extras.URLForEntry.getNonResolved","getSummaries","entityByRequest","byRequest","byEntity","defaultSummary","urlSummary","requestsByEntity","requestSummary","entity","entitySummary","entityRequests","getRelatedEvents","summaries","firstPartyEntity","madeUpEntityCache","firstPartyUrl","compositorEvents","viewportEvent","LanternError","UrlUtils","url1","url2","urla","urlb","INITIAL_CWD","DEFAULT_SERVER_RESPONSE_PERCENTAGE","SERVER_RESPONSE_PERCENTAGE_OF_TTFB","NetworkAnalyzer","records","grouped","item","group","median","summaryByKey","allEstimates","estimates","iteratee","connectionWasReused","groupedByOrigin","originRequests","originEstimates","info","connectionReused","connectStart","sslStart","sslEnd","connectEnd","downloadTimeAfterFirstByte","numberOfRoundTrips","roundTrips","serverResponseTimePercentage","estimatedServerResponseTime","rttByOrigin","rtt","connectionIdWasStarted","started","options","forceCoarseEstimates","originRecords","earliestReusePossible","firstRecord","coarseEstimateMultiplier","useDownloadEstimates","useSendStartEstimates","useHeadersEndEstimates","estimatesByOrigin","collectEstimates","estimator","multiplier","rttSummaryByOrigin","summary","totalBytes","timeBoundaries","boundaries","inflight","currentStart","totalDuration","boundary","minimumRtt","responseTimeSummaries","additionalRttByOrigin","serverResponseTimeByOrigin","rttForOrigin","resourceUrl","matchingRequests","BaseNode","id","Core.LanternError","rootNode","thisIndex","isDependentOnNode","currentNode","predicate","idsToIncludedClones","parent","originalNode","clonedNode","dependency","clonedDependency","clonedThisNode","callback","getNextNodes","traversalPath","queue","visited","nextNode","direction","currentPath","toVisit","depthAdded","nodesToExplore","CPUNode","parentEvent","childEvents","correctedEndTs","nodeId","urls","NON_NETWORK_SCHEMES","isNonNetworkProtocol","protocol","urlScheme","NetworkNode","networkRequest","isScript","isDocument","SCHEDULABLE_TASK_TITLE_LH","SCHEDULABLE_TASK_TITLE_ALT1","SCHEDULABLE_TASK_TITLE_ALT2","SCHEDULABLE_TASK_TITLE_ALT3","SIGNIFICANT_DUR_THRESHOLD_MS","IGNORED_MIME_TYPES_REGEX","PageDependencyGraph","scriptURLs","callFrames","nodes","idToNodeMap","urlToNodeMap","frameIdToNodeMap","urlList","mainThreadEvents","children","networkNodeOutput","directInitiatorRequest","directInitiatorNode","canDependOnInitiator","initiators","initiator","parentCandidates","redirectNode","actualNode","cpuNodes","linkableResourceTypes","addDependentNetworkRequest","cpuNode","reqId","networkNode","resourceType","addDependencyOnFrame","addDependencyOnUrl","minimumAllowableTimeSinceNetworkNodeEnd","candidates","minCandidate","minDistance","candidate","distance","timers","argsUrl","stackTraceUrls","l","installer","minimumEvtDur","foundFirstLayout","foundFirstPaint","foundFirstParse","isFirst","dependencies","dependents","dependent","lanternRequests","r","r2","debug","requestedUrl","mainDocumentUrl","rootRequest","Core.NetworkAnalyzer","mainDocumentRequest","mainDocumentNode","widthInCharacters","padRight","str","padChar","min","timePerCharacter","max","length","bar","displayName","Metric","dependencyGraph","treatNodeAsRenderBlocking","scriptUrls","Graph.BaseNode","rttMs","processedNavigation","simulationResult","extras","graph","metricName","optimisticGraph","pessimisticGraph","simulateOptions","optimisticSimulation","pessimisticSimulation","optimisticEstimate","pessimisticEstimate","coefficients","interceptMultiplier","FirstContentfulPaint","cutoffTimestamp","additionalCpuNodesToTreatAsRenderBlocking","scriptUrlToNodeMap","existing","possiblyRenderBlockingScriptUrls","definitelyNotRenderBlockingScriptUrls","renderBlockingCpuNodeIds","cpuNodeForUrl","firstLayout","firstPaint","firstParse","rbData","CRITICAL_LONG_TASK_THRESHOLD","Interactive","minimumCpuTaskDuration","isImage","lastTaskAt","minimumTime","lcpResult","metricResult","_","x","LargestContentfulPaint","isLowPriority","nodeTimesNotOffscreenImages","fcpResult","BLOCKING_TIME_THRESHOLD","calculateTbtImpactForEvent","startTimeMs","endTimeMs","topLevelEvent","threshold","clippedStart","clippedDuration","calculateSumOfBlockingTime","topLevelEvents","sumBlockingTime","TotalBlockingTime","simulation","fcpTimeInMs","interactiveTimeMs","minDurationMs","INITIAL_CONGESTION_WINDOW","TCP_SEGMENT_SIZE","TCPConnection","throughput","serverLatency","h2","availableThroughput","minimumThroughputRequiredPerRequest","bytesPerSecond","secondsPerRoundTrip","bytesPerRoundTrip","congestion","warmed","bytes","bytesToDownload","timeAlreadyElapsed","maximumTimeToElapse","dnsResolutionTime","twoWayLatency","oneWayLatency","maximumCongestionWindow","handshakeAndRequest","timeToFirstByte","timeElapsedForTTFB","maximumDownloadTimeToElapse","congestionWindow","totalBytesDownloaded","downloadTimeElapsed","bytesRemaining","bytesDownloadedInWindow","timeElapsed","extraBytesDownloaded","bytesDownloaded","connectionTiming","DEFAULT_SERVER_RESPONSE_TIME","TLS_SCHEMES","CONNECTIONS_PER_ORIGIN","ConnectionPool","recordsByOrigin","connections","additionalRtt","responseTime","isTLS","isH2","connection","minConnections","maxConnection","currentMax","connectionToUse","activeConnection","DEVTOOLS_RTT_ADJUSTMENT_FACTOR","DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR","throttling","Constants","DNS_RESOLUTION_RTT_MULTIPLIER","DNSCache","requestedAt","shouldUpdateCache","domain","cacheEntry","timeUntilResolved","timeUntilCachedIsResolved","resolvedAt","SimulatorTimingMap","defaultThrottling","DEFAULT_MAXIMUM_CONCURRENT_REQUESTS","DEFAULT_LAYOUT_TASK_MULTIPLIER","DEFAULT_MAXIMUM_CPU_TASK_DURATION","NodeState","PriorityStartTimePenalty","ALL_SIMULATION_NODE_TIMINGS","Simulator","settings","throttlingMethod","precomputedLanternData","networkAnalysis","type","queuedTime","nodeStartPosition","firstNodeIndexWithGreaterStartPosition","insertionIndex","indexOfNodeToStart","dep","totalElapsedTime","inFlight","timingData","estimatedTimeElapsed","timePeriodLength","isFinished","calculation","completeNodeTimingEntries","nodeTimingEntries","nodesNotReadyToStart","nodesReadyToStart","nodesInProgress","iteration","completeNodeTimings","wastedBytes","observedThroughput","bitsPerSecond","NetworkRequestTypes","createProcessedNavigation","scoresByNav","Lantern.Core.LanternError","scores","getTimestampOrUndefined","metric","createParsedUrl","findWorkerThreads","trace","workerThreads","workerCreationEvents","tids","createLanternRequest","networkRequestTime","fromWorker","resourceSize","needle","index","chooseInitiatorRequest","requestsByURL","initiatorURL","Lantern.Graph.PageDependencyGraph","c","nonPrefetchCandidates","cand","Lantern.Types.NetworkRequestTypes","sameFrameCandidates","documentCandidates","linkPreloadCandidates","nonPreloadCandidates","allPreloaded","linkInitiators","initiatorRequest","createNetworkRequests","lanternRequest","requestChain","redirect","redirectedRequest","collectMainThreadEvents","Meta","mainFramePids","rendererPidToTid","threads","found","createGraph","TraceParseProgressEvent","init","calculateProgress","phase","TraceProcessor","#traceHandlers","#status","#modelConfiguration","Types.Configuration.defaults","#data","#insights","Handlers.ModelHandlers","enabledInsights","Insights.InsightRunners","traceHandlers","modelConfiguration","#verifyHandlers","Handlers.ModelHandlers.Meta","#passConfigToHandlers","handler","providedHandlers","requiredHandlerKeys","handlerName","depName","providedHandlerKeys","requiredKey","handlers","#computeParsedTrace","#computeInsights","freshRecording","sortedHandlers","sortHandlers","percent","resolve","shallowClone","recurse","obj","#createLanternContext","navStarts","navStartIndex","n","LanternComputationData.createNetworkRequests","LanternComputationData.createGraph","LanternComputationData.createProcessedNavigation","Lantern.Core.NetworkAnalyzer","Lantern.Simulation.Simulator","computeData","Lantern.Metrics.FirstContentfulPaint","Lantern.Metrics.LargestContentfulPaint","interactiveResult","Lantern.Metrics.Interactive","tbtResult","Lantern.Metrics.TotalBlockingTime","#computeInsightSets","insightRunners","insightResult","err","urlString","enabledInsightRunners","bounds","Helpers.Timing.traceWindowFromMicroSeconds","lantern","expectedErrors","sortedMap","visitHandler","stackPath","Model","#traces","#syntheticEventsManagerByTrace","#nextNumberByDomain","#recordingsAvailable","#lastRecordingIndex","#processor","#config","config","metadata","isFreshRecording","isCPUProfile","onTraceUpdate","ModelUpdateEvent","file","syntheticEventsManager","#storeParsedFileData","recordingName","Helpers.Trace.extractOriginFromTrace","nextSequenceForDomain","newModifications","recordingIndex"],"mappings":"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"}