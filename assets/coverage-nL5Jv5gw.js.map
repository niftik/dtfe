{"version":3,"file":"coverage-nL5Jv5gw.js","sources":["../../panels/coverage/CoverageModel.js","../../panels/coverage/coverageListView.css.js","../../panels/coverage/CoverageListView.js","../../panels/coverage/CoverageDecorationManager.js","../../panels/coverage/coverageView.css.js","../../panels/coverage/CoverageView.js"],"sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nexport var Events;\n(function (Events) {\n    /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n    Events[\"CoverageUpdated\"] = \"CoverageUpdated\";\n    Events[\"CoverageReset\"] = \"CoverageReset\";\n    Events[\"SourceMapResolved\"] = \"SourceMapResolved\";\n    /* eslint-enable @typescript-eslint/naming-convention */\n})(Events || (Events = {}));\nconst COVERAGE_POLLING_PERIOD_MS = 200;\nconst RESOLVE_SOURCEMAP_TIMEOUT = 500;\nexport class CoverageModel extends SDK.SDKModel.SDKModel {\n    cpuProfilerModel;\n    cssModel;\n    debuggerModel;\n    coverageByURL;\n    coverageByContentProvider;\n    coverageUpdateTimes;\n    suspensionState;\n    pollTimer;\n    currentPollPromise;\n    shouldResumePollingOnResume;\n    jsBacklog;\n    cssBacklog;\n    performanceTraceRecording;\n    sourceMapManager;\n    willResolveSourceMaps;\n    processSourceMapBacklog;\n    constructor(target) {\n        super(target);\n        this.cpuProfilerModel = target.model(SDK.CPUProfilerModel.CPUProfilerModel);\n        this.cssModel = target.model(SDK.CSSModel.CSSModel);\n        this.debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n        this.sourceMapManager = this.debuggerModel?.sourceMapManager() || null;\n        this.sourceMapManager?.addEventListener(SDK.SourceMapManager.Events.SourceMapAttached, this.sourceMapAttached, this);\n        this.coverageByURL = new Map();\n        this.coverageByContentProvider = new Map();\n        // We keep track of the update times, because the other data-structures don't change if an\n        // update doesn't change the coverage. Some visualizations want to convey to the user that\n        // an update was received at a certain time, but did not result in a coverage change.\n        this.coverageUpdateTimes = new Set();\n        this.suspensionState = \"Active\" /* SuspensionState.ACTIVE */;\n        this.pollTimer = null;\n        this.currentPollPromise = null;\n        this.shouldResumePollingOnResume = false;\n        this.jsBacklog = [];\n        this.cssBacklog = [];\n        this.performanceTraceRecording = false;\n        this.willResolveSourceMaps = false;\n        this.processSourceMapBacklog = [];\n    }\n    async start(jsCoveragePerBlock) {\n        if (this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            throw Error('Cannot start CoverageModel while it is not active.');\n        }\n        const promises = [];\n        if (this.cssModel) {\n            // Note there's no JS coverage since JS won't ever return\n            // coverage twice, even after it's restarted.\n            this.clearCSS();\n            this.cssModel.addEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n            promises.push(this.cssModel.startCoverage());\n        }\n        if (this.cpuProfilerModel) {\n            promises.push(this.cpuProfilerModel.startPreciseCoverage(jsCoveragePerBlock, this.preciseCoverageDeltaUpdate.bind(this)));\n        }\n        await Promise.all(promises);\n        return Boolean(this.cssModel || this.cpuProfilerModel);\n    }\n    async sourceMapAttached(event) {\n        const script = event.data.client;\n        const sourceMap = event.data.sourceMap;\n        this.processSourceMapBacklog.push({ script, sourceMap });\n        if (!this.willResolveSourceMaps) {\n            this.willResolveSourceMaps = true;\n            setTimeout(this.resolveSourceMapsAndUpdate.bind(this), RESOLVE_SOURCEMAP_TIMEOUT);\n        }\n    }\n    async resolveSourceMapsAndUpdate() {\n        this.willResolveSourceMaps = false;\n        // reset the backlog once we start processing it\n        const currentBacklog = this.processSourceMapBacklog;\n        this.processSourceMapBacklog = [];\n        await Promise.all(currentBacklog.map(({ script, sourceMap }) => this.resolveSourceMap(script, sourceMap)));\n        this.dispatchEventToListeners(Events.SourceMapResolved);\n    }\n    async resolveSourceMap(script, sourceMap) {\n        const url = script.sourceURL;\n        const urlCoverage = this.coverageByURL.get(url);\n        if (!urlCoverage) {\n            // The urlCoverage has not been created yet, so no need to update it.\n            return;\n        }\n        // If the urlCoverage is there, but no sourceURLCoverageInfo have been added,\n        // it means the source map is attached after the URLCoverage is created.\n        // So now we need to create the sourceURLCoverageInfo and add it to the urlCoverage.\n        if (urlCoverage.sourcesURLCoverageInfo.size === 0) {\n            const generatedContent = TextUtils.ContentData.ContentData.contentDataOrEmpty(await script.requestContentData());\n            const [sourceSizeMap, sourceSegments] = this.calculateSizeForSources(sourceMap, generatedContent.textObj, script.contentLength);\n            urlCoverage.setSourceSegments(sourceSegments);\n            for (const sourceURL of sourceMap.sourceURLs()) {\n                this.addCoverageForSource(sourceURL, sourceSizeMap.get(sourceURL) || 0, urlCoverage.type(), urlCoverage);\n            }\n        }\n    }\n    async preciseCoverageDeltaUpdate(timestamp, occasion, coverageData) {\n        this.coverageUpdateTimes.add(timestamp);\n        const result = await this.backlogOrProcessJSCoverage(coverageData, timestamp);\n        if (result.length) {\n            this.dispatchEventToListeners(Events.CoverageUpdated, result);\n        }\n    }\n    async stop() {\n        await this.stopPolling();\n        const promises = [];\n        if (this.cpuProfilerModel) {\n            promises.push(this.cpuProfilerModel.stopPreciseCoverage());\n        }\n        if (this.cssModel) {\n            promises.push(this.cssModel.stopCoverage());\n            this.cssModel.removeEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n        }\n        await Promise.all(promises);\n    }\n    reset() {\n        this.coverageByURL = new Map();\n        this.coverageByContentProvider = new Map();\n        this.coverageUpdateTimes = new Set();\n        this.dispatchEventToListeners(Events.CoverageReset);\n    }\n    async startPolling() {\n        if (this.currentPollPromise || this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            return;\n        }\n        await this.pollLoop();\n    }\n    async pollLoop() {\n        this.clearTimer();\n        this.currentPollPromise = this.pollAndCallback();\n        await this.currentPollPromise;\n        if (this.suspensionState === \"Active\" /* SuspensionState.ACTIVE */ || this.performanceTraceRecording) {\n            this.pollTimer = window.setTimeout(() => this.pollLoop(), COVERAGE_POLLING_PERIOD_MS);\n        }\n    }\n    async stopPolling() {\n        this.clearTimer();\n        await this.currentPollPromise;\n        this.currentPollPromise = null;\n        // Do one last poll to get the final data.\n        await this.pollAndCallback();\n    }\n    async pollAndCallback() {\n        if (this.suspensionState === \"Suspended\" /* SuspensionState.SUSPENDED */ && !this.performanceTraceRecording) {\n            return;\n        }\n        const updates = await this.takeAllCoverage();\n        // This conditional should never trigger, as all intended ways to stop\n        // polling are awaiting the `_currentPollPromise` before suspending.\n        console.assert(this.suspensionState !== \"Suspended\" /* SuspensionState.SUSPENDED */ || Boolean(this.performanceTraceRecording), 'CoverageModel was suspended while polling.');\n        if (updates.length) {\n            this.dispatchEventToListeners(Events.CoverageUpdated, updates);\n        }\n    }\n    clearTimer() {\n        if (this.pollTimer) {\n            clearTimeout(this.pollTimer);\n            this.pollTimer = null;\n        }\n    }\n    /**\n     * Stops polling as preparation for suspension. This function is idempotent\n     * due because it changes the state to suspending.\n     */\n    async preSuspendModel(reason) {\n        if (this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            return;\n        }\n        this.suspensionState = \"Suspending\" /* SuspensionState.SUSPENDING */;\n        if (reason === 'performance-timeline') {\n            this.performanceTraceRecording = true;\n            // Keep polling to the backlog if a performance trace is recorded.\n            return;\n        }\n        if (this.currentPollPromise) {\n            await this.stopPolling();\n            this.shouldResumePollingOnResume = true;\n        }\n    }\n    async suspendModel(_reason) {\n        this.suspensionState = \"Suspended\" /* SuspensionState.SUSPENDED */;\n    }\n    async resumeModel() {\n    }\n    /**\n     * Restarts polling after suspension. Note that the function is idempotent\n     * because starting polling is idempotent.\n     */\n    async postResumeModel() {\n        this.suspensionState = \"Active\" /* SuspensionState.ACTIVE */;\n        this.performanceTraceRecording = false;\n        if (this.shouldResumePollingOnResume) {\n            this.shouldResumePollingOnResume = false;\n            await this.startPolling();\n        }\n    }\n    entries() {\n        return Array.from(this.coverageByURL.values());\n    }\n    getCoverageForUrl(url) {\n        return this.coverageByURL.get(url) || null;\n    }\n    usageForRange(contentProvider, startOffset, endOffset) {\n        const coverageInfo = this.coverageByContentProvider.get(contentProvider);\n        return coverageInfo && coverageInfo.usageForRange(startOffset, endOffset);\n    }\n    clearCSS() {\n        for (const entry of this.coverageByContentProvider.values()) {\n            if (entry.type() !== 1 /* CoverageType.CSS */) {\n                continue;\n            }\n            const contentProvider = entry.getContentProvider();\n            this.coverageByContentProvider.delete(contentProvider);\n            const urlEntry = this.coverageByURL.get(entry.url());\n            if (!urlEntry) {\n                continue;\n            }\n            const key = `${contentProvider.startLine}:${contentProvider.startColumn}`;\n            urlEntry.removeCoverageEntry(key, entry);\n            if (urlEntry.numberOfEntries() === 0) {\n                this.coverageByURL.delete(entry.url());\n            }\n        }\n        if (this.cssModel) {\n            for (const styleSheetHeader of this.cssModel.getAllStyleSheetHeaders()) {\n                this.addStyleSheetToCSSCoverage(styleSheetHeader);\n            }\n        }\n    }\n    async takeAllCoverage() {\n        const [updatesCSS, updatesJS] = await Promise.all([this.takeCSSCoverage(), this.takeJSCoverage()]);\n        return [...updatesCSS, ...updatesJS];\n    }\n    async takeJSCoverage() {\n        if (!this.cpuProfilerModel) {\n            return [];\n        }\n        const { coverage, timestamp } = await this.cpuProfilerModel.takePreciseCoverage();\n        this.coverageUpdateTimes.add(timestamp);\n        return this.backlogOrProcessJSCoverage(coverage, timestamp);\n    }\n    getCoverageUpdateTimes() {\n        return this.coverageUpdateTimes;\n    }\n    async backlogOrProcessJSCoverage(freshRawCoverageData, freshTimestamp) {\n        if (freshRawCoverageData.length > 0) {\n            this.jsBacklog.push({ rawCoverageData: freshRawCoverageData, stamp: freshTimestamp });\n        }\n        if (this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            return [];\n        }\n        const ascendingByTimestamp = (x, y) => x.stamp - y.stamp;\n        const results = [];\n        for (const { rawCoverageData, stamp } of this.jsBacklog.sort(ascendingByTimestamp)) {\n            results.push(await this.processJSCoverage(rawCoverageData, stamp));\n        }\n        this.jsBacklog = [];\n        return results.flat();\n    }\n    async processJSBacklog() {\n        void this.backlogOrProcessJSCoverage([], 0);\n    }\n    async processJSCoverage(scriptsCoverage, stamp) {\n        if (!this.debuggerModel) {\n            return [];\n        }\n        const updatedEntries = [];\n        for (const entry of scriptsCoverage) {\n            const script = this.debuggerModel.scriptForId(entry.scriptId);\n            if (!script) {\n                continue;\n            }\n            const ranges = [];\n            let type = 2 /* CoverageType.JAVA_SCRIPT */;\n            for (const func of entry.functions) {\n                // Do not coerce undefined to false, i.e. only consider blockLevel to be false\n                // if back-end explicitly provides blockLevel field, otherwise presume blockLevel\n                // coverage is not available. Also, ignore non-block level functions that weren't\n                // ever called.\n                if (func.isBlockCoverage === false && !(func.ranges.length === 1 && !func.ranges[0].count)) {\n                    type |= 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */;\n                }\n                for (const range of func.ranges) {\n                    ranges.push(range);\n                }\n            }\n            const subentry = await this.addCoverage(script, script.contentLength, script.lineOffset, script.columnOffset, ranges, type, stamp);\n            if (subentry) {\n                updatedEntries.push(...subentry);\n            }\n        }\n        return updatedEntries;\n    }\n    handleStyleSheetAdded(event) {\n        this.addStyleSheetToCSSCoverage(event.data);\n    }\n    async takeCSSCoverage() {\n        // Don't poll if we have no model, or are suspended.\n        if (!this.cssModel || this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            return [];\n        }\n        const { coverage, timestamp } = await this.cssModel.takeCoverageDelta();\n        this.coverageUpdateTimes.add(timestamp);\n        return this.backlogOrProcessCSSCoverage(coverage, timestamp);\n    }\n    async backlogOrProcessCSSCoverage(freshRawCoverageData, freshTimestamp) {\n        if (freshRawCoverageData.length > 0) {\n            this.cssBacklog.push({ rawCoverageData: freshRawCoverageData, stamp: freshTimestamp });\n        }\n        if (this.suspensionState !== \"Active\" /* SuspensionState.ACTIVE */) {\n            return [];\n        }\n        const ascendingByTimestamp = (x, y) => x.stamp - y.stamp;\n        const results = [];\n        for (const { rawCoverageData, stamp } of this.cssBacklog.sort(ascendingByTimestamp)) {\n            results.push(await this.processCSSCoverage(rawCoverageData, stamp));\n        }\n        this.cssBacklog = [];\n        return results.flat();\n    }\n    async processCSSCoverage(ruleUsageList, stamp) {\n        if (!this.cssModel) {\n            return [];\n        }\n        const updatedEntries = [];\n        const rulesByStyleSheet = new Map();\n        for (const rule of ruleUsageList) {\n            const styleSheetHeader = this.cssModel.styleSheetHeaderForId(rule.styleSheetId);\n            if (!styleSheetHeader) {\n                continue;\n            }\n            let ranges = rulesByStyleSheet.get(styleSheetHeader);\n            if (!ranges) {\n                ranges = [];\n                rulesByStyleSheet.set(styleSheetHeader, ranges);\n            }\n            ranges.push({ startOffset: rule.startOffset, endOffset: rule.endOffset, count: Number(rule.used) });\n        }\n        for (const entry of rulesByStyleSheet) {\n            const styleSheetHeader = entry[0];\n            const ranges = entry[1];\n            const subentry = await this.addCoverage(styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, ranges, 1 /* CoverageType.CSS */, stamp);\n            if (subentry) {\n                updatedEntries.push(...subentry);\n            }\n        }\n        return updatedEntries;\n    }\n    static convertToDisjointSegments(ranges, stamp) {\n        ranges.sort((a, b) => a.startOffset - b.startOffset);\n        const result = [];\n        const stack = [];\n        for (const entry of ranges) {\n            let top = stack[stack.length - 1];\n            while (top && top.endOffset <= entry.startOffset) {\n                append(top.endOffset, top.count);\n                stack.pop();\n                top = stack[stack.length - 1];\n            }\n            append(entry.startOffset, top ? top.count : 0);\n            stack.push(entry);\n        }\n        for (let top = stack.pop(); top; top = stack.pop()) {\n            append(top.endOffset, top.count);\n        }\n        function append(end, count) {\n            const last = result[result.length - 1];\n            if (last) {\n                if (last.end === end) {\n                    return;\n                }\n                if (last.count === count) {\n                    last.end = end;\n                    return;\n                }\n            }\n            result.push({ end, count, stamp });\n        }\n        return result;\n    }\n    addStyleSheetToCSSCoverage(styleSheetHeader) {\n        void this.addCoverage(styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, [], 1 /* CoverageType.CSS */, Date.now());\n    }\n    calculateSizeForSources(sourceMap, text, contentLength) {\n        // Map shows the size of source files contributed to the size in the generated file. For example:\n        // Map(3) {url1 => 593, url2 => 232, url3 => 52}\n        // This means in there are 593 bytes in the generated file are contributed by url1, and so on.\n        const sourceSizeMap = new Map();\n        // Continuous segments shows that which source file contribute to the generated file segment. For example:\n        // [{end: 84, sourceUrl: ''}, {end: 593, sourceUrl: url1}, {end: 781, sourceUrl: url2}, {end: 833, sourceUrl: url3}, {end: 881, sourceUrl: url1}]\n        // This means that the first 84 bytes in the generated file are not contributed by any source file, the next 593 bytes are contributed by url1, and so on.\n        const sourceSegments = [];\n        const calculateSize = function (startLine, startCol, endLine, endCol) {\n            if (startLine === endLine) {\n                return endCol - startCol;\n            }\n            if (text) {\n                // If we hit the line break, we need to use offset to calculate size\n                const startOffset = text.offsetFromPosition(startLine, startCol);\n                const endOffset = text.offsetFromPosition(endLine, endCol);\n                return endOffset - startOffset;\n            }\n            // If for some reason we don't have the text, we can only use col number to calculate size\n            return endCol;\n        };\n        const mappings = sourceMap.mappings();\n        if (mappings.length === 0) {\n            return [sourceSizeMap, sourceSegments];\n        }\n        // calculate the segment before the first entry\n        let lastEntry = mappings[0];\n        let totalSegmentSize = 0;\n        if (text) {\n            totalSegmentSize += text.offsetFromPosition(lastEntry.lineNumber, lastEntry.columnNumber);\n        }\n        else {\n            totalSegmentSize += calculateSize(0, 0, lastEntry.lineNumber, lastEntry.columnNumber);\n        }\n        sourceSegments.push({ end: totalSegmentSize, sourceUrl: '' });\n        for (let i = 0; i < mappings.length; i++) {\n            const curEntry = mappings[i];\n            const entryRange = sourceMap.findEntryRanges(curEntry.lineNumber, curEntry.columnNumber);\n            if (entryRange) {\n                // calculate the size\n                const range = entryRange.range;\n                const sourceURL = entryRange.sourceURL;\n                const oldSize = sourceSizeMap.get(sourceURL) || 0;\n                let size = 0;\n                if (i === mappings.length - 1) {\n                    const startOffset = text.offsetFromPosition(range.startLine, range.startColumn);\n                    size = contentLength - startOffset;\n                }\n                else {\n                    size = calculateSize(range.startLine, range.startColumn, range.endLine, range.endColumn);\n                }\n                sourceSizeMap.set(sourceURL, oldSize + size);\n            }\n            // calculate the segment\n            const segmentSize = calculateSize(lastEntry.lineNumber, lastEntry.columnNumber, curEntry.lineNumber, curEntry.columnNumber);\n            totalSegmentSize += segmentSize;\n            if (curEntry.sourceURL !== lastEntry.sourceURL) {\n                if (text) {\n                    const endOffsetForLastEntry = text.offsetFromPosition(curEntry.lineNumber, curEntry.columnNumber);\n                    sourceSegments.push({ end: endOffsetForLastEntry, sourceUrl: lastEntry.sourceURL || '' });\n                }\n                else {\n                    sourceSegments.push({ end: totalSegmentSize, sourceUrl: lastEntry.sourceURL || '' });\n                }\n            }\n            lastEntry = curEntry;\n            // add the last segment if we are at the last entry\n            if (i === mappings.length - 1) {\n                sourceSegments.push({ end: contentLength, sourceUrl: curEntry.sourceURL || '' });\n            }\n        }\n        return [sourceSizeMap, sourceSegments];\n    }\n    async addCoverage(contentProvider, contentLength, startLine, startColumn, ranges, type, stamp) {\n        const coverageInfoArray = [];\n        const url = contentProvider.contentURL();\n        if (!url) {\n            return null;\n        }\n        let urlCoverage = this.coverageByURL.get(url);\n        let isNewUrlCoverage = false;\n        if (!urlCoverage) {\n            isNewUrlCoverage = true;\n            urlCoverage = new URLCoverageInfo(url);\n            this.coverageByURL.set(url, urlCoverage);\n            // If the script has source map, we need to create the sourceURLCoverageInfo for each source file.\n            const sourceMap = await this.sourceMapManager?.sourceMapForClientPromise(contentProvider);\n            if (sourceMap) {\n                const generatedContent = TextUtils.ContentData.ContentData.contentDataOrEmpty(await contentProvider.requestContentData());\n                const [sourceSizeMap, sourceSegments] = this.calculateSizeForSources(sourceMap, generatedContent.textObj, contentLength);\n                urlCoverage.setSourceSegments(sourceSegments);\n                for (const sourceURL of sourceMap.sourceURLs()) {\n                    const subentry = this.addCoverageForSource(sourceURL, sourceSizeMap.get(sourceURL) || 0, type, urlCoverage);\n                    if (subentry) {\n                        coverageInfoArray.push(subentry);\n                    }\n                }\n            }\n        }\n        const coverageInfo = urlCoverage.ensureEntry(contentProvider, contentLength, startLine, startColumn, type);\n        this.coverageByContentProvider.set(contentProvider, coverageInfo);\n        const segments = CoverageModel.convertToDisjointSegments(ranges, stamp);\n        const last = segments[segments.length - 1];\n        if (last && last.end < contentLength) {\n            segments.push({ end: contentLength, stamp, count: 0 });\n        }\n        const usedSizeDelta = coverageInfo.mergeCoverage(segments);\n        if (!isNewUrlCoverage && usedSizeDelta === 0) {\n            return null;\n        }\n        urlCoverage.addToSizes(usedSizeDelta, 0);\n        // go through the sources that have size changes.\n        for (const [sourceUrl, sizeDelta] of coverageInfo.sourceDeltaMap) {\n            const sourceURLCoverageInfo = urlCoverage.sourcesURLCoverageInfo.get(sourceUrl);\n            if (sourceURLCoverageInfo) {\n                sourceURLCoverageInfo.addToSizes(sizeDelta, 0);\n                sourceURLCoverageInfo.lastSourceUsedRange = coverageInfo.sourceUsedRangeMap.get(sourceUrl) || [];\n            }\n        }\n        coverageInfoArray.push(coverageInfo);\n        return coverageInfoArray;\n    }\n    addCoverageForSource(url, size, type, generatedUrlCoverage) {\n        const uiSourceCode = Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(url);\n        const contentProvider = uiSourceCode;\n        const urlCoverage = new SourceURLCoverageInfo(url, generatedUrlCoverage);\n        const coverageInfo = urlCoverage.ensureEntry(contentProvider, size, 0, 0, type);\n        generatedUrlCoverage.sourcesURLCoverageInfo.set(url, urlCoverage);\n        return coverageInfo;\n    }\n    async exportReport(fos) {\n        const result = [];\n        const coverageByUrlKeys = Array.from(this.coverageByURL.keys()).sort();\n        for (const urlInfoKey of coverageByUrlKeys) {\n            const urlInfo = this.coverageByURL.get(urlInfoKey);\n            if (!urlInfo) {\n                continue;\n            }\n            const url = urlInfo.url();\n            if (url.startsWith('extensions::') || Common.ParsedURL.schemeIs(url, 'chrome-extension:')) {\n                continue;\n            }\n            result.push(...await urlInfo.entriesForExport());\n        }\n        await fos.write(JSON.stringify(result, undefined, 2));\n        void fos.close();\n    }\n}\nSDK.SDKModel.SDKModel.register(CoverageModel, { capabilities: 0 /* SDK.Target.Capability.NONE */, autostart: false });\nfunction locationCompare(a, b) {\n    const [aLine, aPos] = a.split(':');\n    const [bLine, bPos] = b.split(':');\n    return Number.parseInt(aLine, 10) - Number.parseInt(bLine, 10) ||\n        Number.parseInt(aPos, 10) - Number.parseInt(bPos, 10);\n}\nexport class URLCoverageInfo extends Common.ObjectWrapper.ObjectWrapper {\n    urlInternal;\n    coverageInfoByLocation;\n    sizeInternal;\n    usedSizeInternal;\n    typeInternal;\n    isContentScriptInternal;\n    sourcesURLCoverageInfo = new Map();\n    sourceSegments;\n    constructor(url) {\n        super();\n        this.urlInternal = url;\n        this.coverageInfoByLocation = new Map();\n        this.sizeInternal = 0;\n        this.usedSizeInternal = 0;\n        this.isContentScriptInternal = false;\n    }\n    url() {\n        return this.urlInternal;\n    }\n    type() {\n        return this.typeInternal;\n    }\n    size() {\n        return this.sizeInternal;\n    }\n    usedSize() {\n        return this.usedSizeInternal;\n    }\n    unusedSize() {\n        return this.sizeInternal - this.usedSizeInternal;\n    }\n    usedPercentage() {\n        // Per convention, empty files are reported as 100 % uncovered\n        if (this.sizeInternal === 0) {\n            return 0;\n        }\n        if (!this.unusedSize() || !this.size()) {\n            return 0;\n        }\n        return this.usedSize() / this.size();\n    }\n    unusedPercentage() {\n        // Per convention, empty files are reported as 100 % uncovered\n        if (this.sizeInternal === 0) {\n            return 100;\n        }\n        return this.unusedSize() / this.size();\n    }\n    isContentScript() {\n        return this.isContentScriptInternal;\n    }\n    entries() {\n        return this.coverageInfoByLocation.values();\n    }\n    numberOfEntries() {\n        return this.coverageInfoByLocation.size;\n    }\n    removeCoverageEntry(key, entry) {\n        if (!this.coverageInfoByLocation.delete(key)) {\n            return;\n        }\n        this.addToSizes(-entry.getUsedSize(), -entry.getSize());\n    }\n    addToSizes(usedSize, size) {\n        this.usedSizeInternal += usedSize;\n        this.sizeInternal += size;\n        if (usedSize !== 0 || size !== 0) {\n            this.dispatchEventToListeners(URLCoverageInfo.Events.SizesChanged);\n        }\n    }\n    setSourceSegments(segments) {\n        this.sourceSegments = segments;\n    }\n    ensureEntry(contentProvider, contentLength, lineOffset, columnOffset, type) {\n        const key = `${lineOffset}:${columnOffset}`;\n        let entry = this.coverageInfoByLocation.get(key);\n        if ((type & 2 /* CoverageType.JAVA_SCRIPT */) && !this.coverageInfoByLocation.size &&\n            contentProvider instanceof SDK.Script.Script) {\n            this.isContentScriptInternal = contentProvider.isContentScript();\n        }\n        this.typeInternal |= type;\n        if (entry) {\n            entry.addCoverageType(type);\n            return entry;\n        }\n        if ((type & 2 /* CoverageType.JAVA_SCRIPT */) && !this.coverageInfoByLocation.size &&\n            contentProvider instanceof SDK.Script.Script) {\n            this.isContentScriptInternal = contentProvider.isContentScript();\n        }\n        entry = new CoverageInfo(contentProvider, contentLength, lineOffset, columnOffset, type, this);\n        this.coverageInfoByLocation.set(key, entry);\n        this.addToSizes(0, contentLength);\n        return entry;\n    }\n    async getFullText() {\n        // For .html resources, multiple scripts share URL, but have different offsets.\n        let useFullText = false;\n        const url = this.url();\n        for (const info of this.coverageInfoByLocation.values()) {\n            const { lineOffset, columnOffset } = info.getOffsets();\n            if (lineOffset || columnOffset) {\n                useFullText = Boolean(url);\n                break;\n            }\n        }\n        if (!useFullText) {\n            return null;\n        }\n        const resource = SDK.ResourceTreeModel.ResourceTreeModel.resourceForURL(url);\n        if (!resource) {\n            return null;\n        }\n        const content = TextUtils.ContentData.ContentData.contentDataOrEmpty(await resource.requestContentData());\n        return content.textObj;\n    }\n    entriesForExportBasedOnFullText(fullText) {\n        const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n        const entry = { url: this.url(), ranges: [], text: fullText.value() };\n        for (const infoKey of coverageByLocationKeys) {\n            const info = this.coverageInfoByLocation.get(infoKey);\n            if (!info) {\n                continue;\n            }\n            const { lineOffset, columnOffset } = info.getOffsets();\n            const offset = fullText ? fullText.offsetFromPosition(lineOffset, columnOffset) : 0;\n            entry.ranges.push(...info.rangesForExport(offset));\n        }\n        return entry;\n    }\n    async entriesForExportBasedOnContent() {\n        const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n        const result = [];\n        for (const infoKey of coverageByLocationKeys) {\n            const info = this.coverageInfoByLocation.get(infoKey);\n            if (!info) {\n                continue;\n            }\n            const entry = {\n                url: this.url(),\n                ranges: info.rangesForExport(),\n                text: TextUtils.ContentData.ContentData.textOr(await info.getContentProvider().requestContentData(), null),\n            };\n            result.push(entry);\n        }\n        return result;\n    }\n    async entriesForExport() {\n        const fullText = await this.getFullText();\n        // We have full text for this resource, resolve the offsets using the text line endings.\n        if (fullText) {\n            return [await this.entriesForExportBasedOnFullText(fullText)];\n        }\n        // Fall back to the per-script operation.\n        return this.entriesForExportBasedOnContent();\n    }\n}\nexport class SourceURLCoverageInfo extends URLCoverageInfo {\n    generatedURLCoverageInfo;\n    lastSourceUsedRange = [];\n    constructor(sourceUrl, generatedUrlCoverage) {\n        super(sourceUrl);\n        this.generatedURLCoverageInfo = generatedUrlCoverage;\n    }\n}\n(function (URLCoverageInfo) {\n    let Events;\n    (function (Events) {\n        /* eslint-disable @typescript-eslint/naming-convention -- Used by web_tests. */\n        Events[\"SizesChanged\"] = \"SizesChanged\";\n        /* eslint-enable @typescript-eslint/naming-convention */\n    })(Events = URLCoverageInfo.Events || (URLCoverageInfo.Events = {}));\n})(URLCoverageInfo || (URLCoverageInfo = {}));\nexport const mergeSegments = (segmentsA, segmentsB) => {\n    const result = [];\n    let indexA = 0;\n    let indexB = 0;\n    while (indexA < segmentsA.length && indexB < segmentsB.length) {\n        const a = segmentsA[indexA];\n        const b = segmentsB[indexB];\n        const count = (a.count || 0) + (b.count || 0);\n        const end = Math.min(a.end, b.end);\n        const last = result[result.length - 1];\n        const stamp = Math.min(a.stamp, b.stamp);\n        if (!last || last.count !== count || last.stamp !== stamp) {\n            result.push({ end, count, stamp });\n        }\n        else {\n            last.end = end;\n        }\n        if (a.end <= b.end) {\n            indexA++;\n        }\n        if (a.end >= b.end) {\n            indexB++;\n        }\n    }\n    for (; indexA < segmentsA.length; indexA++) {\n        result.push(segmentsA[indexA]);\n    }\n    for (; indexB < segmentsB.length; indexB++) {\n        result.push(segmentsB[indexB]);\n    }\n    return result;\n};\nexport class CoverageInfo {\n    contentProvider;\n    size;\n    usedSize;\n    statsByTimestamp;\n    lineOffset;\n    columnOffset;\n    coverageType;\n    segments;\n    generatedUrlCoverageInfo;\n    sourceUsedSizeMap = new Map();\n    sourceDeltaMap = new Map();\n    sourceUsedRangeMap = new Map();\n    constructor(contentProvider, size, lineOffset, columnOffset, type, generatedUrlCoverageInfo) {\n        this.contentProvider = contentProvider;\n        this.size = size;\n        this.usedSize = 0;\n        this.statsByTimestamp = new Map();\n        this.lineOffset = lineOffset;\n        this.columnOffset = columnOffset;\n        this.coverageType = type;\n        this.generatedUrlCoverageInfo = generatedUrlCoverageInfo;\n        this.segments = [];\n    }\n    getContentProvider() {\n        return this.contentProvider;\n    }\n    url() {\n        return this.contentProvider.contentURL();\n    }\n    type() {\n        return this.coverageType;\n    }\n    addCoverageType(type) {\n        this.coverageType |= type;\n    }\n    getOffsets() {\n        return { lineOffset: this.lineOffset, columnOffset: this.columnOffset };\n    }\n    /**\n     * Returns the delta by which usedSize increased.\n     */\n    mergeCoverage(segments) {\n        const oldUsedSize = this.usedSize;\n        this.segments = mergeSegments(this.segments, segments);\n        this.updateStats();\n        if (this.generatedUrlCoverageInfo.sourceSegments && this.generatedUrlCoverageInfo.sourceSegments.length > 0) {\n            this.updateSourceCoverage();\n        }\n        return this.usedSize - oldUsedSize;\n    }\n    usedByTimestamp() {\n        return this.statsByTimestamp;\n    }\n    getSize() {\n        return this.size;\n    }\n    getUsedSize() {\n        return this.usedSize;\n    }\n    usageForRange(start, end) {\n        let index = Platform.ArrayUtilities.upperBound(this.segments, start, (position, segment) => position - segment.end);\n        for (; index < this.segments.length && this.segments[index].end < end; ++index) {\n            if (this.segments[index].count) {\n                return true;\n            }\n        }\n        return index < this.segments.length && Boolean(this.segments[index].count);\n    }\n    updateStats() {\n        this.statsByTimestamp = new Map();\n        this.usedSize = 0;\n        let last = 0;\n        for (const segment of this.segments) {\n            let previousCount = this.statsByTimestamp.get(segment.stamp);\n            if (previousCount === undefined) {\n                previousCount = 0;\n            }\n            if (segment.count) {\n                const used = segment.end - last;\n                this.usedSize += used;\n                this.statsByTimestamp.set(segment.stamp, previousCount + used);\n            }\n            last = segment.end;\n        }\n    }\n    updateSourceCoverage() {\n        const sourceCoverage = new Map();\n        this.sourceDeltaMap = new Map();\n        this.sourceUsedRangeMap = new Map();\n        const ranges = this.generatedUrlCoverageInfo.sourceSegments || [];\n        let segmentStart = 0;\n        let lastFoundRange = 0;\n        for (const segment of this.segments) {\n            const segmentEnd = segment.end;\n            if (segment.count) {\n                for (let i = lastFoundRange; i < ranges.length; i++) {\n                    // Calculate the start point of the current range.\n                    // If it's the first range, the start point is 0,\n                    // otherwise, it's one more than the end point of the previous range.\n                    const rangeStart = i === 0 ? 0 : ranges[i - 1].end + 1;\n                    const rangeEnd = ranges[i].end;\n                    // Calculate the start and end points of the overlap between the current segment and range\n                    const overlapStart = Math.max(segmentStart, rangeStart);\n                    const overlapEnd = Math.min(segmentEnd, rangeEnd);\n                    // If there's an overlap (start point is less than or equal to end point)\n                    if (overlapStart <= overlapEnd) {\n                        const overlapSize = overlapEnd - overlapStart + 1;\n                        const overlapRange = { start: overlapStart, end: overlapEnd };\n                        if (!sourceCoverage.has(ranges[i].sourceUrl)) {\n                            sourceCoverage.set(ranges[i].sourceUrl, overlapSize);\n                        }\n                        else {\n                            sourceCoverage.set(ranges[i].sourceUrl, sourceCoverage.get(ranges[i].sourceUrl) + overlapSize);\n                        }\n                        if (!this.sourceUsedRangeMap.has(ranges[i].sourceUrl)) {\n                            this.sourceUsedRangeMap.set(ranges[i].sourceUrl, [overlapRange]);\n                        }\n                        else {\n                            this.sourceUsedRangeMap.get(ranges[i].sourceUrl)?.push(overlapRange);\n                        }\n                        // The next overlap will start at or after the end of the current range\n                        lastFoundRange = i;\n                    }\n                    // The segment end is before the end of the current range, so we can stop looking for overlaps\n                    if (segmentEnd < rangeEnd) {\n                        break;\n                    }\n                }\n            }\n            segmentStart = segmentEnd + 1;\n        }\n        for (const [url, size] of sourceCoverage) {\n            const oldSize = this.sourceUsedSizeMap.get(url) || 0;\n            if (oldSize !== size) {\n                this.sourceUsedSizeMap.set(url, size); // update the map tracking the old used size\n                this.sourceDeltaMap.set(url, size - oldSize); // update the map tracking the delta\n            }\n        }\n    }\n    rangesForExport(offset = 0) {\n        const ranges = [];\n        let start = 0;\n        for (const segment of this.segments) {\n            if (segment.count) {\n                const last = ranges.length > 0 ? ranges[ranges.length - 1] : null;\n                if (last && last.end === start + offset) {\n                    // We can extend the last segment.\n                    last.end = segment.end + offset;\n                }\n                else {\n                    // There was a gap, add a new segment.\n                    ranges.push({ start: start + offset, end: segment.end + offset });\n                }\n            }\n            start = segment.end;\n        }\n        return ranges;\n    }\n}\n//# sourceMappingURL=CoverageModel.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(\n`/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.data-grid {\n  border: none;\n}\n\n.data-grid td .url-outer {\n  width: 100%;\n  display: inline-flex;\n  justify-content: flex-start;\n}\n\n.data-grid td .url-outer .filter-highlight {\n  font-weight: bold;\n}\n\n.data-grid td .url-prefix {\n  overflow-x: hidden;\n  text-overflow: ellipsis;\n}\n\n.data-grid td .url-suffix {\n  flex: none;\n}\n\n.data-grid td .bar {\n  display: inline-block;\n  height: 8px;\n  border: 1px solid transparent;\n}\n\n.data-grid td .bar-unused-size {\n  background-color: var(--app-color-coverage-unused);\n}\n\n.data-grid td .bar-used-size {\n  background-color: var(--app-color-coverage-used);\n}\n\n.data-grid td .percent-value {\n  width: 7ex;\n  display: inline-block;\n  color: var(--sys-color-on-surface-subtle);\n}\n\n@media (forced-colors: active) {\n  .data-grid td .bar-container {\n    forced-color-adjust: none;\n  }\n\n  .data-grid td .bar-unused-size {\n    background-color: ButtonText;\n  }\n\n  .data-grid td .bar-used-size {\n    background-color: ButtonFace;\n  }\n\n  .data-grid td .bar {\n    border-color: ButtonText;\n  }\n\n  .data-grid .selected td .bar {\n    border-top-color: HighlightText;\n    border-bottom-color: HighlightText;\n  }\n\n  .data-grid .selected td .bar:last-child {\n    border-right-color: HighlightText;\n  }\n\n  .data-grid .selected td .bar:first-child {\n    border-left-color: HighlightText;\n  }\n\n  .data-grid:focus tr.selected span.percent-value {\n    color: HighlightText;\n  }\n}\n\n/*# sourceURL=coverageListView.css */\n`);\n\nexport default styles;\n","// Copyright (c) 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nimport * as DataGrid from '../../ui/legacy/components/data_grid/data_grid.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport coverageListViewStyles from './coverageListView.css.js';\nimport { SourceURLCoverageInfo, } from './CoverageModel.js';\nconst UIStrings = {\n    /**\n     *@description Text that appears on a button for the css resource type filter.\n     */\n    css: 'CSS',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    jsPerFunction: 'JS (per function)',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    jsPerBlock: 'JS (per block)',\n    /**\n     *@description Text for web URLs\n     */\n    url: 'URL',\n    /**\n     *@description Text that refers to some types\n     */\n    type: 'Type',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    totalBytes: 'Total Bytes',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    unusedBytes: 'Unused Bytes',\n    /**\n     *@description Text in the Coverage List View of the Coverage Tab\n     */\n    usageVisualization: 'Usage Visualization',\n    /**\n     *@description Data grid name for Coverage data grids\n     */\n    codeCoverage: 'Code Coverage',\n    /**\n     *@description Cell title in Coverage List View of the Coverage tab. The coverage tool tells\n     *developers which functions (logical groups of lines of code) were actually run/executed. If a\n     *function does get run, then it is marked in the UI to indicate that it was covered.\n     */\n    jsCoverageWithPerFunction: 'JS coverage with per function granularity: Once a function was executed, the whole function is marked as covered.',\n    /**\n     *@description Cell title in Coverage List View of the Coverage tab. The coverage tool tells\n     *developers which blocks (logical groups of lines of code, smaller than a function) were actually\n     *run/executed. If a block does get run, then it is marked in the UI to indicate that it was\n     *covered.\n     */\n    jsCoverageWithPerBlock: 'JS coverage with per block granularity: Once a block of JavaScript was executed, that block is marked as covered.',\n    /**\n     *@description Accessible text for the value in bytes in memory allocation or coverage view.\n     */\n    sBytes: '{n, plural, =1 {# byte} other {# bytes}}',\n    /**\n     *@description Accessible text for the unused bytes column in the coverage tool that describes the total unused bytes and percentage of the file unused.\n     *@example {88%} percentage\n     */\n    sBytesS: '{n, plural, =1 {# byte, {percentage}} other {# bytes, {percentage}}}',\n    /**\n     *@description Tooltip text for the bar in the coverage list view of the coverage tool that illustrates the relation between used and unused bytes.\n     *@example {1000} PH1\n     *@example {12.34} PH2\n     */\n    sBytesSBelongToFunctionsThatHave: '{PH1} bytes ({PH2}) belong to functions that have not (yet) been executed.',\n    /**\n     *@description Tooltip text for the bar in the coverage list view of the coverage tool that illustrates the relation between used and unused bytes.\n     *@example {1000} PH1\n     *@example {12.34} PH2\n     */\n    sBytesSBelongToBlocksOf: '{PH1} bytes ({PH2}) belong to blocks of JavaScript that have not (yet) been executed.',\n    /**\n     *@description Message in Coverage View of the Coverage tab\n     *@example {1000} PH1\n     *@example {12.34} PH2\n     */\n    sBytesSBelongToFunctionsThatHaveExecuted: '{PH1} bytes ({PH2}) belong to functions that have executed at least once.',\n    /**\n     *@description Message in Coverage View of the Coverage tab\n     *@example {1000} PH1\n     *@example {12.34} PH2\n     */\n    sBytesSBelongToBlocksOfJavascript: '{PH1} bytes ({PH2}) belong to blocks of JavaScript that have executed at least once.',\n    /**\n     *@description Accessible text for the visualization column of coverage tool. Contains percentage of unused bytes to used bytes.\n     *@example {12.3} PH1\n     *@example {12.3} PH2\n     */\n    sOfFileUnusedSOfFileUsed: '{PH1} % of file unused, {PH2} % of file used',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/coverage/CoverageListView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport function coverageTypeToString(type) {\n    const types = [];\n    if (type & 1 /* CoverageType.CSS */) {\n        types.push(i18nString(UIStrings.css));\n    }\n    if (type & 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */) {\n        types.push(i18nString(UIStrings.jsPerFunction));\n    }\n    else if (type & 2 /* CoverageType.JAVA_SCRIPT */) {\n        types.push(i18nString(UIStrings.jsPerBlock));\n    }\n    return types.join('+');\n}\nexport class CoverageListView extends UI.Widget.VBox {\n    nodeForCoverageInfo;\n    isVisibleFilter;\n    highlightRegExp;\n    dataGrid;\n    constructor(isVisibleFilter) {\n        super(true);\n        this.nodeForCoverageInfo = new Map();\n        this.isVisibleFilter = isVisibleFilter;\n        this.highlightRegExp = null;\n        const columns = [\n            {\n                id: 'url',\n                title: i18nString(UIStrings.url),\n                width: '250px',\n                weight: 3,\n                fixedWidth: false,\n                sortable: true,\n                disclosure: true,\n            },\n            { id: 'type', title: i18nString(UIStrings.type), width: '45px', weight: 1, fixedWidth: true, sortable: true },\n            {\n                id: 'size',\n                title: i18nString(UIStrings.totalBytes),\n                width: '60px',\n                fixedWidth: true,\n                sortable: true,\n                align: \"right\" /* DataGrid.DataGrid.Align.RIGHT */,\n                weight: 1,\n            },\n            {\n                id: 'unused-size',\n                title: i18nString(UIStrings.unusedBytes),\n                width: '100px',\n                fixedWidth: true,\n                sortable: true,\n                align: \"right\" /* DataGrid.DataGrid.Align.RIGHT */,\n                sort: DataGrid.DataGrid.Order.Descending,\n                weight: 1,\n            },\n            {\n                id: 'bars',\n                title: i18nString(UIStrings.usageVisualization),\n                width: '250px',\n                fixedWidth: false,\n                sortable: true,\n                weight: 1,\n            },\n        ];\n        this.dataGrid = new DataGrid.SortableDataGrid.SortableDataGrid({\n            displayName: i18nString(UIStrings.codeCoverage),\n            columns,\n            editCallback: undefined,\n            refreshCallback: undefined,\n            deleteCallback: undefined,\n        });\n        this.dataGrid.setResizeMethod(\"last\" /* DataGrid.DataGrid.ResizeMethod.LAST */);\n        this.dataGrid.setStriped(true);\n        this.dataGrid.element.classList.add('flex-auto');\n        this.dataGrid.addEventListener(\"OpenedNode\" /* DataGrid.DataGrid.Events.OPENED_NODE */, this.onOpenedNode, this);\n        this.dataGrid.addEventListener(\"SortingChanged\" /* DataGrid.DataGrid.Events.SORTING_CHANGED */, this.sortingChanged, this);\n        const dataGridWidget = this.dataGrid.asWidget();\n        dataGridWidget.show(this.contentElement);\n        this.setDefaultFocusedChild(dataGridWidget);\n    }\n    update(coverageInfo) {\n        let hadUpdates = false;\n        const maxSize = coverageInfo.reduce((acc, entry) => Math.max(acc, entry.size()), 0);\n        const rootNode = this.dataGrid.rootNode();\n        for (const entry of coverageInfo) {\n            let node = this.nodeForCoverageInfo.get(entry);\n            if (node) {\n                if (this.isVisibleFilter(node.coverageInfo)) {\n                    hadUpdates = node.refreshIfNeeded(maxSize) || hadUpdates;\n                    if (entry.sourcesURLCoverageInfo.size > 0) {\n                        this.updateSourceNodes(entry.sourcesURLCoverageInfo, maxSize, node);\n                    }\n                }\n                continue;\n            }\n            node = new GridNode(entry, maxSize);\n            this.nodeForCoverageInfo.set(entry, node);\n            if (this.isVisibleFilter(node.coverageInfo)) {\n                rootNode.appendChild(node);\n                if (entry.sourcesURLCoverageInfo.size > 0) {\n                    void this.createSourceNodes(entry.sourcesURLCoverageInfo, maxSize, node);\n                }\n                hadUpdates = true;\n            }\n        }\n        if (hadUpdates) {\n            this.sortingChanged();\n        }\n    }\n    updateSourceNodes(sourcesURLCoverageInfo, maxSize, node) {\n        let shouldCreateSourceNodes = false;\n        for (const coverageInfo of sourcesURLCoverageInfo.values()) {\n            const sourceNode = this.nodeForCoverageInfo.get(coverageInfo);\n            if (sourceNode) {\n                sourceNode.refreshIfNeeded(maxSize);\n            }\n            else {\n                shouldCreateSourceNodes = true;\n                break;\n            }\n        }\n        if (shouldCreateSourceNodes) {\n            void this.createSourceNodes(sourcesURLCoverageInfo, maxSize, node);\n        }\n    }\n    async createSourceNodes(sourcesURLCoverageInfo, maxSize, node) {\n        for (const coverageInfo of sourcesURLCoverageInfo.values()) {\n            const sourceNode = new GridNode(coverageInfo, maxSize);\n            node.appendChild(sourceNode);\n            this.nodeForCoverageInfo.set(coverageInfo, sourceNode);\n        }\n    }\n    reset() {\n        this.nodeForCoverageInfo.clear();\n        this.dataGrid.rootNode().removeChildren();\n    }\n    updateFilterAndHighlight(highlightRegExp) {\n        this.highlightRegExp = highlightRegExp;\n        let hadTreeUpdates = false;\n        for (const node of this.nodeForCoverageInfo.values()) {\n            const shouldBeVisible = this.isVisibleFilter(node.coverageInfo);\n            const isVisible = Boolean(node.parent);\n            if (shouldBeVisible) {\n                node.setHighlight(this.highlightRegExp);\n            }\n            if (shouldBeVisible === isVisible) {\n                continue;\n            }\n            hadTreeUpdates = true;\n            if (!shouldBeVisible) {\n                node.remove();\n            }\n            else {\n                this.appendNodeByType(node);\n            }\n        }\n        if (hadTreeUpdates) {\n            this.sortingChanged();\n        }\n    }\n    appendNodeByType(node) {\n        if (node.coverageInfo instanceof SourceURLCoverageInfo) {\n            const parentNode = this.nodeForCoverageInfo.get(node.coverageInfo.generatedURLCoverageInfo);\n            parentNode?.appendChild(node);\n        }\n        else {\n            this.dataGrid.rootNode().appendChild(node);\n        }\n    }\n    selectByUrl(url) {\n        for (const [info, node] of this.nodeForCoverageInfo.entries()) {\n            if (info.url() === url) {\n                node.revealAndSelect();\n                break;\n            }\n        }\n    }\n    onOpenedNode() {\n        void this.revealSourceForSelectedNode();\n    }\n    async revealSourceForSelectedNode() {\n        const node = this.dataGrid.selectedNode;\n        if (!node) {\n            return;\n        }\n        const coverageInfo = node.coverageInfo;\n        const sourceCode = Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(coverageInfo.url());\n        if (!sourceCode) {\n            return;\n        }\n        if (this.dataGrid.selectedNode !== node) {\n            return;\n        }\n        void Common.Revealer.reveal(sourceCode);\n    }\n    sortingChanged() {\n        const columnId = this.dataGrid.sortColumnId();\n        if (!columnId) {\n            return;\n        }\n        const sortFunction = GridNode.sortFunctionForColumn(columnId);\n        if (!sortFunction) {\n            return;\n        }\n        this.dataGrid.sortNodes(sortFunction, !this.dataGrid.isSortOrderAscending());\n    }\n    wasShown() {\n        super.wasShown();\n        this.registerCSSFiles([coverageListViewStyles]);\n    }\n}\nlet percentageFormatter = null;\nfunction getPercentageFormatter() {\n    if (!percentageFormatter) {\n        percentageFormatter = new Intl.NumberFormat(i18n.DevToolsLocale.DevToolsLocale.instance().locale, {\n            style: 'percent',\n            maximumFractionDigits: 1,\n        });\n    }\n    return percentageFormatter;\n}\nlet bytesFormatter = null;\nfunction getBytesFormatter() {\n    if (!bytesFormatter) {\n        bytesFormatter = new Intl.NumberFormat(i18n.DevToolsLocale.DevToolsLocale.instance().locale);\n    }\n    return bytesFormatter;\n}\nexport class GridNode extends DataGrid.SortableDataGrid.SortableDataGridNode {\n    coverageInfo;\n    lastUsedSize;\n    url;\n    maxSize;\n    highlightRegExp;\n    constructor(coverageInfo, maxSize) {\n        super();\n        this.coverageInfo = coverageInfo;\n        this.url = coverageInfo.url();\n        this.maxSize = maxSize;\n        this.highlightRegExp = null;\n    }\n    setHighlight(highlightRegExp) {\n        if (this.highlightRegExp === highlightRegExp) {\n            return;\n        }\n        this.highlightRegExp = highlightRegExp;\n        this.refresh();\n    }\n    refreshIfNeeded(maxSize) {\n        if (this.lastUsedSize === this.coverageInfo.usedSize() && maxSize === this.maxSize) {\n            return false;\n        }\n        this.lastUsedSize = this.coverageInfo.usedSize();\n        this.maxSize = maxSize;\n        this.refresh();\n        return true;\n    }\n    createCell(columnId) {\n        const cell = this.createTD(columnId);\n        switch (columnId) {\n            case 'url': {\n                UI.Tooltip.Tooltip.install(cell, this.url);\n                const outer = cell.createChild('div', 'url-outer');\n                const prefix = outer.createChild('div', 'url-prefix');\n                const suffix = outer.createChild('div', 'url-suffix');\n                const splitURL = /^(.*)(\\/[^/]*)$/.exec(this.url);\n                prefix.textContent = splitURL ? splitURL[1] : this.url;\n                suffix.textContent = splitURL ? splitURL[2] : '';\n                if (this.highlightRegExp) {\n                    this.highlight(outer, this.url);\n                }\n                this.setCellAccessibleName(this.url, cell, columnId);\n                break;\n            }\n            case 'type': {\n                cell.textContent = coverageTypeToString(this.coverageInfo.type());\n                if (this.coverageInfo.type() & 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */) {\n                    UI.Tooltip.Tooltip.install(cell, i18nString(UIStrings.jsCoverageWithPerFunction));\n                }\n                else if (this.coverageInfo.type() & 2 /* CoverageType.JAVA_SCRIPT */) {\n                    UI.Tooltip.Tooltip.install(cell, i18nString(UIStrings.jsCoverageWithPerBlock));\n                }\n                break;\n            }\n            case 'size': {\n                const size = this.coverageInfo.size() || 0;\n                const sizeSpan = cell.createChild('span');\n                const sizeFormatted = getBytesFormatter().format(size);\n                sizeSpan.textContent = sizeFormatted;\n                const sizeAccessibleName = i18nString(UIStrings.sBytes, { n: size });\n                this.setCellAccessibleName(sizeAccessibleName, cell, columnId);\n                break;\n            }\n            case 'unused-size': {\n                const unusedSize = this.coverageInfo.unusedSize() || 0;\n                const unusedSizeSpan = cell.createChild('span');\n                const unusedPercentsSpan = cell.createChild('span', 'percent-value');\n                const unusedSizeFormatted = getBytesFormatter().format(unusedSize);\n                unusedSizeSpan.textContent = unusedSizeFormatted;\n                const unusedPercentFormatted = getPercentageFormatter().format(this.coverageInfo.unusedPercentage());\n                unusedPercentsSpan.textContent = unusedPercentFormatted;\n                const unusedAccessibleName = i18nString(UIStrings.sBytesS, { n: unusedSize, percentage: unusedPercentFormatted });\n                this.setCellAccessibleName(unusedAccessibleName, cell, columnId);\n                break;\n            }\n            case 'bars': {\n                const barContainer = cell.createChild('div', 'bar-container');\n                const unusedPercent = getPercentageFormatter().format(this.coverageInfo.unusedPercentage());\n                const usedPercent = getPercentageFormatter().format(this.coverageInfo.usedPercentage());\n                if (this.coverageInfo.unusedSize() > 0) {\n                    const unusedSizeBar = barContainer.createChild('div', 'bar bar-unused-size');\n                    unusedSizeBar.style.width = ((this.coverageInfo.unusedSize() / this.maxSize) * 100 || 0) + '%';\n                    if (this.coverageInfo.type() & 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */) {\n                        UI.Tooltip.Tooltip.install(unusedSizeBar, i18nString(UIStrings.sBytesSBelongToFunctionsThatHave, { PH1: this.coverageInfo.unusedSize(), PH2: unusedPercent }));\n                    }\n                    else if (this.coverageInfo.type() & 2 /* CoverageType.JAVA_SCRIPT */) {\n                        UI.Tooltip.Tooltip.install(unusedSizeBar, i18nString(UIStrings.sBytesSBelongToBlocksOf, { PH1: this.coverageInfo.unusedSize(), PH2: unusedPercent }));\n                    }\n                }\n                if (this.coverageInfo.usedSize() > 0) {\n                    const usedSizeBar = barContainer.createChild('div', 'bar bar-used-size');\n                    usedSizeBar.style.width = ((this.coverageInfo.usedSize() / this.maxSize) * 100 || 0) + '%';\n                    if (this.coverageInfo.type() & 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */) {\n                        UI.Tooltip.Tooltip.install(usedSizeBar, i18nString(UIStrings.sBytesSBelongToFunctionsThatHaveExecuted, { PH1: this.coverageInfo.usedSize(), PH2: usedPercent }));\n                    }\n                    else if (this.coverageInfo.type() & 2 /* CoverageType.JAVA_SCRIPT */) {\n                        UI.Tooltip.Tooltip.install(usedSizeBar, i18nString(UIStrings.sBytesSBelongToBlocksOfJavascript, { PH1: this.coverageInfo.usedSize(), PH2: usedPercent }));\n                    }\n                }\n                this.setCellAccessibleName(i18nString(UIStrings.sOfFileUnusedSOfFileUsed, { PH1: unusedPercent, PH2: usedPercent }), cell, columnId);\n            }\n        }\n        return cell;\n    }\n    highlight(element, textContent) {\n        if (!this.highlightRegExp) {\n            return;\n        }\n        const matches = this.highlightRegExp.exec(textContent);\n        if (!matches || !matches.length) {\n            return;\n        }\n        const range = new TextUtils.TextRange.SourceRange(matches.index, matches[0].length);\n        UI.UIUtils.highlightRangesWithStyleClass(element, [range], 'filter-highlight');\n    }\n    static sortFunctionForColumn(columnId) {\n        const compareURL = (a, b) => a.url.localeCompare(b.url);\n        switch (columnId) {\n            case 'url':\n                return compareURL;\n            case 'type':\n                return (a, b) => {\n                    const typeA = coverageTypeToString(a.coverageInfo.type());\n                    const typeB = coverageTypeToString(b.coverageInfo.type());\n                    return typeA.localeCompare(typeB) || compareURL(a, b);\n                };\n            case 'size':\n                return (a, b) => a.coverageInfo.size() - b.coverageInfo.size() || compareURL(a, b);\n            case 'bars':\n            case 'unused-size':\n                return (a, b) => a.coverageInfo.unusedSize() - b.coverageInfo.unusedSize() || compareURL(a, b);\n            default:\n                console.assert(false, 'Unknown sort field: ' + columnId);\n                return null;\n        }\n    }\n}\n//# sourceMappingURL=CoverageListView.js.map","// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nexport const decoratorType = 'coverage';\nexport class CoverageDecorationManager {\n    coverageModel;\n    textByProvider;\n    uiSourceCodeByContentProvider;\n    #workspace;\n    #debuggerBinding;\n    #cssBinding;\n    constructor(coverageModel, workspace, debuggerBinding, cssBinding) {\n        this.coverageModel = coverageModel;\n        this.#workspace = workspace;\n        this.#debuggerBinding = debuggerBinding;\n        this.#cssBinding = cssBinding;\n        this.textByProvider = new Map();\n        this.uiSourceCodeByContentProvider = new Platform.MapUtilities.Multimap();\n        for (const uiSourceCode of this.#workspace.uiSourceCodes()) {\n            uiSourceCode.setDecorationData(decoratorType, this);\n        }\n        this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.onUISourceCodeAdded, this);\n    }\n    reset() {\n        for (const uiSourceCode of this.#workspace.uiSourceCodes()) {\n            uiSourceCode.setDecorationData(decoratorType, undefined);\n        }\n    }\n    dispose() {\n        this.reset();\n        this.#workspace.removeEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.onUISourceCodeAdded, this);\n    }\n    update(updatedEntries) {\n        for (const entry of updatedEntries) {\n            for (const uiSourceCode of this.uiSourceCodeByContentProvider.get(entry.getContentProvider())) {\n                uiSourceCode.setDecorationData(decoratorType, this);\n            }\n        }\n    }\n    /**\n     * Returns the coverage per line of the provided uiSourceCode. The resulting array has the same length\n     * as the provided `lines` array.\n     *\n     * @param uiSourceCode The UISourceCode for which to get the coverage info.\n     * @param lineMappings The caller might have applied formatting to the UISourceCode. Each entry\n     *                     in this array represents one line and the range specifies where it's found in\n     *                     the original content.\n     */\n    async usageByLine(uiSourceCode, lineMappings) {\n        const result = [];\n        await this.updateTexts(uiSourceCode, lineMappings);\n        for (const { startLine, startColumn, endLine, endColumn } of lineMappings) {\n            const startLocationsPromise = this.rawLocationsForSourceLocation(uiSourceCode, startLine, startColumn);\n            const endLocationsPromise = this.rawLocationsForSourceLocation(uiSourceCode, endLine, endColumn);\n            const [startLocations, endLocations] = await Promise.all([startLocationsPromise, endLocationsPromise]);\n            let used = undefined;\n            for (let startIndex = 0, endIndex = 0; startIndex < startLocations.length; ++startIndex) {\n                const start = startLocations[startIndex];\n                while (endIndex < endLocations.length &&\n                    CoverageDecorationManager.compareLocations(start, endLocations[endIndex]) >= 0) {\n                    ++endIndex;\n                }\n                if (endIndex >= endLocations.length || endLocations[endIndex].id !== start.id) {\n                    continue;\n                }\n                const end = endLocations[endIndex++];\n                const text = this.textByProvider.get(end.contentProvider);\n                if (!text) {\n                    continue;\n                }\n                const textValue = text.value();\n                let startOffset = Math.min(text.offsetFromPosition(start.line, start.column), textValue.length - 1);\n                let endOffset = Math.min(text.offsetFromPosition(end.line, end.column), textValue.length - 1);\n                while (startOffset <= endOffset && /\\s/.test(textValue[startOffset])) {\n                    ++startOffset;\n                }\n                while (startOffset <= endOffset && /\\s/.test(textValue[endOffset])) {\n                    --endOffset;\n                }\n                if (startOffset <= endOffset) {\n                    used = this.coverageModel.usageForRange(end.contentProvider, startOffset, endOffset);\n                }\n                if (used) {\n                    break;\n                }\n            }\n            result.push(used);\n        }\n        return result;\n    }\n    async updateTexts(uiSourceCode, lineMappings) {\n        const promises = [];\n        for (const range of lineMappings) {\n            for (const entry of await this.rawLocationsForSourceLocation(uiSourceCode, range.startLine, 0)) {\n                if (this.textByProvider.has(entry.contentProvider)) {\n                    continue;\n                }\n                this.textByProvider.set(entry.contentProvider, null);\n                this.uiSourceCodeByContentProvider.set(entry.contentProvider, uiSourceCode);\n                promises.push(this.updateTextForProvider(entry.contentProvider));\n            }\n        }\n        await Promise.all(promises);\n    }\n    async updateTextForProvider(contentProvider) {\n        const contentData = TextUtils.ContentData.ContentData.contentDataOrEmpty(await contentProvider.requestContentData());\n        this.textByProvider.set(contentProvider, contentData.textObj);\n    }\n    async rawLocationsForSourceLocation(uiSourceCode, line, column) {\n        const result = [];\n        const contentType = uiSourceCode.contentType();\n        if (contentType.hasScripts()) {\n            let locations = await this.#debuggerBinding.uiLocationToRawLocations(uiSourceCode, line, column);\n            locations = locations.filter(location => Boolean(location.script()));\n            for (const location of locations) {\n                const script = location.script();\n                if (!script) {\n                    continue;\n                }\n                if (script.isInlineScript() && contentType.isDocument()) {\n                    location.lineNumber -= script.lineOffset;\n                    if (!location.lineNumber) {\n                        location.columnNumber -= script.columnOffset;\n                    }\n                }\n                result.push({\n                    id: `js:${location.scriptId}`,\n                    contentProvider: script,\n                    line: location.lineNumber,\n                    column: location.columnNumber,\n                });\n            }\n        }\n        if (contentType.isStyleSheet() || contentType.isDocument()) {\n            const rawStyleLocations = this.#cssBinding.uiLocationToRawLocations(new Workspace.UISourceCode.UILocation(uiSourceCode, line, column));\n            for (const location of rawStyleLocations) {\n                const header = location.header();\n                if (!header) {\n                    continue;\n                }\n                if (header.isInline && contentType.isDocument()) {\n                    location.lineNumber -= header.startLine;\n                    if (!location.lineNumber) {\n                        location.columnNumber -= header.startColumn;\n                    }\n                }\n                result.push({\n                    id: `css:${location.styleSheetId}`,\n                    contentProvider: header,\n                    line: location.lineNumber,\n                    column: location.columnNumber,\n                });\n            }\n        }\n        return result.sort(CoverageDecorationManager.compareLocations);\n    }\n    static compareLocations(a, b) {\n        return a.id.localeCompare(b.id) || a.line - b.line || a.column - b.column;\n    }\n    onUISourceCodeAdded(event) {\n        const uiSourceCode = event.data;\n        uiSourceCode.setDecorationData(decoratorType, this);\n    }\n}\n//# sourceMappingURL=CoverageDecorationManager.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(\n`/*\n * Copyright (c) 2016 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  overflow: hidden;\n}\n\n.coverage-toolbar-container {\n  display: flex;\n  border-bottom: 1px solid var(--sys-color-divider);\n  flex: 0 0 auto;\n}\n\n.coverage-toolbar {\n  display: inline-block;\n  width: 100%;\n}\n\n.coverage-toolbar-summary {\n  background-color: var(--sys-color-cdt-base-container);\n  border-top: 1px solid var(--sys-color-divider);\n  padding-left: 5px;\n  flex: 0 0 19px;\n  display: flex;\n  padding-right: 5px;\n}\n\n.coverage-toolbar-summary .coverage-message {\n  padding-top: 2px;\n  padding-left: 1ex;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n\n.coverage-results {\n  overflow-y: auto;\n  display: flex;\n  flex: auto;\n}\n\n.landing-page,\n.bfcache-page,\n.prerender-page {\n  justify-content: center;\n  align-items: center;\n  padding: 20px;\n}\n\n.landing-page .message,\n.bfcache-page .message,\n.prerender-page .message {\n  white-space: pre-line;\n  text-align: center;\n}\n\n/*# sourceURL=coverageView.css */\n`);\n\nexport default styles;\n","// Copyright (c) 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as VisualLogging from '../../ui/visual_logging/visual_logging.js';\nimport { CoverageDecorationManager } from './CoverageDecorationManager.js';\nimport { CoverageListView } from './CoverageListView.js';\nimport { CoverageModel, Events } from './CoverageModel.js';\nimport coverageViewStyles from './coverageView.css.js';\nconst UIStrings = {\n    /**\n     *@description Tooltip in Coverage List View of the Coverage tab for selecting JavaScript coverage mode\n     */\n    chooseCoverageGranularityPer: 'Choose coverage granularity: Per function has low overhead, per block has significant overhead.',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    perFunction: 'Per function',\n    /**\n     *@description Text in Coverage List View of the Coverage tab\n     */\n    perBlock: 'Per block',\n    /**\n     *@description Text in Coverage View of the Coverage tab\n     */\n    filterByUrl: 'Filter by URL',\n    /**\n     *@description Label for the type filter in the Converage Panel\n     */\n    filterCoverageByType: 'Filter coverage by type',\n    /**\n     *@description Text for everything\n     */\n    all: 'All',\n    /**\n     *@description Text that appears on a button for the css resource type filter.\n     */\n    css: 'CSS',\n    /**\n     *@description Text in Timeline Tree View of the Performance panel\n     */\n    javascript: 'JavaScript',\n    /**\n     *@description Tooltip text that appears on the setting when hovering over it in Coverage View of the Coverage tab\n     */\n    includeExtensionContentScripts: 'Include extension content scripts',\n    /**\n     *@description Title for a type of source files\n     */\n    contentScripts: 'Content scripts',\n    /**\n     *@description Message in Coverage View of the Coverage tab\n     *@example {record button icon} PH1\n     */\n    clickTheReloadButtonSToReloadAnd: 'Click the reload button {PH1} to reload and start capturing coverage.',\n    /**\n     *@description Message in Coverage View of the Coverage tab\n     *@example {record button icon} PH1\n     */\n    clickTheRecordButtonSToStart: 'Click the record button {PH1} to start capturing coverage.',\n    /**\n     *@description Message in the Coverage View explaining that DevTools could not capture coverage.\n     */\n    bfcacheNoCapture: 'Could not capture coverage info because the page was served from the back/forward cache.',\n    /**\n     *@description  Message in the Coverage View explaining that DevTools could not capture coverage.\n     */\n    activationNoCapture: 'Could not capture coverage info because the page was prerendered in the background.',\n    /**\n     *@description  Message in the Coverage View prompting the user to reload the page.\n     *@example {reload button icon} PH1\n     */\n    reloadPrompt: 'Click the reload button {PH1} to reload and get coverage.',\n    /**\n     *@description Footer message in Coverage View of the Coverage tab\n     *@example {300k used, 600k unused} PH1\n     *@example {500k used, 800k unused} PH2\n     */\n    filteredSTotalS: 'Filtered: {PH1}  Total: {PH2}',\n    /**\n     *@description Footer message in Coverage View of the Coverage tab\n     *@example {1.5 MB} PH1\n     *@example {2.1 MB} PH2\n     *@example {71%} PH3\n     *@example {29%} PH4\n     */\n    sOfSSUsedSoFarSUnused: '{PH1} of {PH2} ({PH3}%) used so far, {PH4} unused.',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/coverage/CoverageView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nlet coverageViewInstance;\nexport class CoverageView extends UI.Widget.VBox {\n    model;\n    decorationManager;\n    coverageTypeComboBox;\n    coverageTypeComboBoxSetting;\n    toggleRecordAction;\n    toggleRecordButton;\n    inlineReloadButton;\n    startWithReloadButton;\n    clearAction;\n    exportAction;\n    textFilterRegExp;\n    filterInput;\n    typeFilterValue;\n    filterByTypeComboBox;\n    showContentScriptsSetting;\n    contentScriptsCheckbox;\n    coverageResultsElement;\n    landingPage;\n    bfcacheReloadPromptPage;\n    activationReloadPromptPage;\n    listView;\n    statusToolbarElement;\n    statusMessageElement;\n    constructor() {\n        super(true);\n        this.element.setAttribute('jslog', `${VisualLogging.panel('coverage').track({ resize: true })}`);\n        this.model = null;\n        this.decorationManager = null;\n        const toolbarContainer = this.contentElement.createChild('div', 'coverage-toolbar-container');\n        toolbarContainer.setAttribute('jslog', `${VisualLogging.toolbar()}`);\n        const toolbar = new UI.Toolbar.Toolbar('coverage-toolbar', toolbarContainer);\n        toolbar.makeWrappable(true);\n        this.coverageTypeComboBox = new UI.Toolbar.ToolbarComboBox(this.onCoverageTypeComboBoxSelectionChanged.bind(this), i18nString(UIStrings.chooseCoverageGranularityPer), undefined, 'coverage-type');\n        const coverageTypes = [\n            {\n                label: i18nString(UIStrings.perFunction),\n                value: 2 /* CoverageType.JAVA_SCRIPT */ | 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */,\n            },\n            {\n                label: i18nString(UIStrings.perBlock),\n                value: 2 /* CoverageType.JAVA_SCRIPT */,\n            },\n        ];\n        for (const type of coverageTypes) {\n            this.coverageTypeComboBox.addOption(this.coverageTypeComboBox.createOption(type.label, `${type.value}`));\n        }\n        this.coverageTypeComboBoxSetting =\n            Common.Settings.Settings.instance().createSetting('coverage-view-coverage-type', 0);\n        this.coverageTypeComboBox.setSelectedIndex(this.coverageTypeComboBoxSetting.get());\n        this.coverageTypeComboBox.setEnabled(true);\n        toolbar.appendToolbarItem(this.coverageTypeComboBox);\n        this.toggleRecordAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.toggle-recording');\n        this.toggleRecordButton = UI.Toolbar.Toolbar.createActionButton(this.toggleRecordAction);\n        toolbar.appendToolbarItem(this.toggleRecordButton);\n        const mainTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n        const mainTargetSupportsRecordOnReload = mainTarget && mainTarget.model(SDK.ResourceTreeModel.ResourceTreeModel);\n        this.inlineReloadButton = null;\n        if (mainTargetSupportsRecordOnReload) {\n            this.startWithReloadButton = UI.Toolbar.Toolbar.createActionButtonForId('coverage.start-with-reload');\n            toolbar.appendToolbarItem(this.startWithReloadButton);\n            this.toggleRecordButton.setEnabled(false);\n            this.toggleRecordButton.setVisible(false);\n        }\n        this.clearAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.clear');\n        this.clearAction.setEnabled(false);\n        toolbar.appendToolbarItem(UI.Toolbar.Toolbar.createActionButton(this.clearAction));\n        toolbar.appendSeparator();\n        this.exportAction = UI.ActionRegistry.ActionRegistry.instance().getAction('coverage.export');\n        this.exportAction.setEnabled(false);\n        toolbar.appendToolbarItem(UI.Toolbar.Toolbar.createActionButton(this.exportAction));\n        this.textFilterRegExp = null;\n        toolbar.appendSeparator();\n        this.filterInput = new UI.Toolbar.ToolbarFilter(i18nString(UIStrings.filterByUrl), 0.4, 1);\n        this.filterInput.setEnabled(false);\n        this.filterInput.addEventListener(\"TextChanged\" /* UI.Toolbar.ToolbarInput.Event.TEXT_CHANGED */, this.onFilterChanged, this);\n        toolbar.appendToolbarItem(this.filterInput);\n        toolbar.appendSeparator();\n        this.typeFilterValue = null;\n        this.filterByTypeComboBox = new UI.Toolbar.ToolbarComboBox(this.onFilterByTypeChanged.bind(this), i18nString(UIStrings.filterCoverageByType), undefined, 'coverage-by-type');\n        const options = [\n            {\n                label: i18nString(UIStrings.all),\n                value: '',\n            },\n            {\n                label: i18nString(UIStrings.css),\n                value: 1 /* CoverageType.CSS */,\n            },\n            {\n                label: i18nString(UIStrings.javascript),\n                value: 2 /* CoverageType.JAVA_SCRIPT */ | 4 /* CoverageType.JAVA_SCRIPT_PER_FUNCTION */,\n            },\n        ];\n        for (const option of options) {\n            this.filterByTypeComboBox.addOption(this.filterByTypeComboBox.createOption(option.label, `${option.value}`));\n        }\n        this.filterByTypeComboBox.setSelectedIndex(0);\n        this.filterByTypeComboBox.setEnabled(false);\n        toolbar.appendToolbarItem(this.filterByTypeComboBox);\n        toolbar.appendSeparator();\n        this.showContentScriptsSetting = Common.Settings.Settings.instance().createSetting('show-content-scripts', false);\n        this.showContentScriptsSetting.addChangeListener(this.onFilterChanged, this);\n        this.contentScriptsCheckbox = new UI.Toolbar.ToolbarSettingCheckbox(this.showContentScriptsSetting, i18nString(UIStrings.includeExtensionContentScripts), i18nString(UIStrings.contentScripts));\n        this.contentScriptsCheckbox.setEnabled(false);\n        toolbar.appendToolbarItem(this.contentScriptsCheckbox);\n        this.coverageResultsElement = this.contentElement.createChild('div', 'coverage-results');\n        this.landingPage = this.buildLandingPage();\n        this.bfcacheReloadPromptPage = this.buildReloadPromptPage(i18nString(UIStrings.bfcacheNoCapture), 'bfcache-page');\n        this.activationReloadPromptPage =\n            this.buildReloadPromptPage(i18nString(UIStrings.activationNoCapture), 'prerender-page');\n        this.listView = new CoverageListView(this.isVisible.bind(this, false));\n        this.statusToolbarElement = this.contentElement.createChild('div', 'coverage-toolbar-summary');\n        this.statusMessageElement = this.statusToolbarElement.createChild('div', 'coverage-message');\n        this.landingPage.show(this.coverageResultsElement);\n    }\n    static instance() {\n        if (!coverageViewInstance) {\n            coverageViewInstance = new CoverageView();\n        }\n        return coverageViewInstance;\n    }\n    static removeInstance() {\n        coverageViewInstance = undefined;\n    }\n    buildLandingPage() {\n        const widget = new UI.Widget.VBox();\n        let message;\n        if (this.startWithReloadButton) {\n            this.inlineReloadButton =\n                UI.UIUtils.createInlineButton(UI.Toolbar.Toolbar.createActionButtonForId('coverage.start-with-reload'));\n            message = i18n.i18n.getFormatLocalizedString(str_, UIStrings.clickTheReloadButtonSToReloadAnd, { PH1: this.inlineReloadButton });\n        }\n        else {\n            const recordButton = UI.UIUtils.createInlineButton(UI.Toolbar.Toolbar.createActionButton(this.toggleRecordAction));\n            message = i18n.i18n.getFormatLocalizedString(str_, UIStrings.clickTheRecordButtonSToStart, { PH1: recordButton });\n        }\n        message.classList.add('message');\n        widget.contentElement.appendChild(message);\n        widget.element.classList.add('landing-page');\n        return widget;\n    }\n    buildReloadPromptPage(message, className) {\n        const widget = new UI.Widget.VBox();\n        const reasonDiv = document.createElement('div');\n        reasonDiv.classList.add('message');\n        reasonDiv.textContent = message;\n        widget.contentElement.appendChild(reasonDiv);\n        this.inlineReloadButton =\n            UI.UIUtils.createInlineButton(UI.Toolbar.Toolbar.createActionButtonForId('inspector-main.reload'));\n        const messageElement = i18n.i18n.getFormatLocalizedString(str_, UIStrings.reloadPrompt, { PH1: this.inlineReloadButton });\n        messageElement.classList.add('message');\n        widget.contentElement.appendChild(messageElement);\n        widget.element.classList.add(className);\n        return widget;\n    }\n    clear() {\n        if (this.model) {\n            this.model.reset();\n        }\n        this.reset();\n    }\n    reset() {\n        if (this.decorationManager) {\n            this.decorationManager.dispose();\n            this.decorationManager = null;\n        }\n        this.listView.reset();\n        this.listView.detach();\n        this.landingPage.show(this.coverageResultsElement);\n        this.statusMessageElement.textContent = '';\n        this.filterInput.setEnabled(false);\n        this.filterByTypeComboBox.setEnabled(false);\n        this.contentScriptsCheckbox.setEnabled(false);\n        this.exportAction.setEnabled(false);\n    }\n    toggleRecording() {\n        const enable = !this.toggleRecordAction.toggled();\n        if (enable) {\n            void this.startRecording({ reload: false, jsCoveragePerBlock: this.isBlockCoverageSelected() });\n        }\n        else {\n            void this.stopRecording();\n        }\n    }\n    isBlockCoverageSelected() {\n        const option = this.coverageTypeComboBox.selectedOption();\n        const coverageType = Number(option ? option.value : Number.NaN);\n        // Check that Coverage.CoverageType.JavaScriptPerFunction is not present.\n        return coverageType === 2 /* CoverageType.JAVA_SCRIPT */;\n    }\n    selectCoverageType(jsCoveragePerBlock) {\n        const selectedIndex = jsCoveragePerBlock ? 1 : 0;\n        this.coverageTypeComboBox.setSelectedIndex(selectedIndex);\n    }\n    onCoverageTypeComboBoxSelectionChanged() {\n        this.coverageTypeComboBoxSetting.set(this.coverageTypeComboBox.selectedIndex());\n    }\n    async ensureRecordingStarted() {\n        const enabled = this.toggleRecordAction.toggled();\n        if (enabled) {\n            await this.stopRecording();\n        }\n        await this.startRecording({ reload: false, jsCoveragePerBlock: false });\n    }\n    async startRecording(options) {\n        let hadFocus, reloadButtonFocused;\n        if ((this.startWithReloadButton && this.startWithReloadButton.element.hasFocus()) ||\n            (this.inlineReloadButton && this.inlineReloadButton.hasFocus())) {\n            reloadButtonFocused = true;\n        }\n        else if (this.hasFocus()) {\n            hadFocus = true;\n        }\n        this.reset();\n        const mainTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n        if (!mainTarget) {\n            return;\n        }\n        const { reload, jsCoveragePerBlock } = { reload: false, jsCoveragePerBlock: false, ...options };\n        if (!this.model || reload) {\n            this.model = mainTarget.model(CoverageModel);\n        }\n        if (!this.model) {\n            return;\n        }\n        Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageStarted);\n        if (jsCoveragePerBlock) {\n            Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageStartedPerBlock);\n        }\n        const success = await this.model.start(Boolean(jsCoveragePerBlock));\n        if (!success) {\n            return;\n        }\n        this.selectCoverageType(Boolean(jsCoveragePerBlock));\n        this.model.addEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n        this.model.addEventListener(Events.SourceMapResolved, this.updateListView, this);\n        const resourceTreeModel = mainTarget.model(SDK.ResourceTreeModel.ResourceTreeModel);\n        SDK.TargetManager.TargetManager.instance().addModelListener(SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.PrimaryPageChanged, this.onPrimaryPageChanged, this);\n        this.decorationManager = new CoverageDecorationManager(this.model, Workspace.Workspace.WorkspaceImpl.instance(), Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance(), Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance());\n        this.toggleRecordAction.setToggled(true);\n        this.clearAction.setEnabled(false);\n        if (this.startWithReloadButton) {\n            this.startWithReloadButton.setEnabled(false);\n            this.startWithReloadButton.setVisible(false);\n            this.toggleRecordButton.setEnabled(true);\n            this.toggleRecordButton.setVisible(true);\n            if (reloadButtonFocused) {\n                this.toggleRecordButton.focus();\n            }\n        }\n        this.coverageTypeComboBox.setEnabled(false);\n        this.filterInput.setEnabled(true);\n        this.filterByTypeComboBox.setEnabled(true);\n        this.contentScriptsCheckbox.setEnabled(true);\n        if (this.landingPage.isShowing()) {\n            this.landingPage.detach();\n        }\n        this.listView.show(this.coverageResultsElement);\n        if (hadFocus && !reloadButtonFocused) {\n            this.listView.focus();\n        }\n        if (reload && resourceTreeModel) {\n            resourceTreeModel.reloadPage();\n        }\n        else {\n            void this.model.startPolling();\n        }\n    }\n    onCoverageDataReceived(event) {\n        const data = event.data;\n        this.updateViews(data);\n    }\n    updateListView() {\n        this.listView.update(this.model && this.model.entries() || []);\n    }\n    async stopRecording() {\n        SDK.TargetManager.TargetManager.instance().removeModelListener(SDK.ResourceTreeModel.ResourceTreeModel, SDK.ResourceTreeModel.Events.PrimaryPageChanged, this.onPrimaryPageChanged, this);\n        if (this.hasFocus()) {\n            this.listView.focus();\n        }\n        // Stopping the model triggers one last poll to get the final data.\n        if (this.model) {\n            await this.model.stop();\n            this.model.removeEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n        }\n        this.toggleRecordAction.setToggled(false);\n        this.coverageTypeComboBox.setEnabled(true);\n        if (this.startWithReloadButton) {\n            this.startWithReloadButton.setEnabled(true);\n            this.startWithReloadButton.setVisible(true);\n            this.toggleRecordButton.setEnabled(false);\n            this.toggleRecordButton.setVisible(false);\n        }\n        this.clearAction.setEnabled(true);\n    }\n    processBacklog() {\n        this.model && void this.model.processJSBacklog();\n    }\n    async onPrimaryPageChanged(event) {\n        const frame = event.data.frame;\n        const coverageModel = frame.resourceTreeModel().target().model(CoverageModel);\n        if (!coverageModel) {\n            return;\n        }\n        // If the primary page target has changed (due to MPArch activation), switch to new CoverageModel.\n        if (this.model !== coverageModel) {\n            if (this.model) {\n                await this.model.stop();\n                this.model.removeEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n            }\n            this.model = coverageModel;\n            const success = await this.model.start(this.isBlockCoverageSelected());\n            if (!success) {\n                return;\n            }\n            this.model.addEventListener(Events.CoverageUpdated, this.onCoverageDataReceived, this);\n            this.decorationManager = new CoverageDecorationManager(this.model, Workspace.Workspace.WorkspaceImpl.instance(), Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance(), Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance());\n        }\n        if (this.bfcacheReloadPromptPage.isShowing()) {\n            this.bfcacheReloadPromptPage.detach();\n            this.listView.show(this.coverageResultsElement);\n        }\n        if (this.activationReloadPromptPage.isShowing()) {\n            this.activationReloadPromptPage.detach();\n            this.listView.show(this.coverageResultsElement);\n        }\n        if (frame.backForwardCacheDetails.restoredFromCache) {\n            this.listView.detach();\n            this.bfcacheReloadPromptPage.show(this.coverageResultsElement);\n        }\n        if (event.data.type === \"Activation\" /* SDK.ResourceTreeModel.PrimaryPageChangeType.ACTIVATION */) {\n            this.listView.detach();\n            this.activationReloadPromptPage.show(this.coverageResultsElement);\n        }\n        this.model.reset();\n        this.decorationManager && this.decorationManager.reset();\n        this.listView.reset();\n        void this.model.startPolling();\n    }\n    updateViews(updatedEntries) {\n        this.updateStats();\n        this.listView.update(this.model && this.model.entries() || []);\n        this.exportAction.setEnabled(this.model !== null && this.model.entries().length > 0);\n        this.decorationManager && this.decorationManager.update(updatedEntries);\n    }\n    updateStats() {\n        const all = { total: 0, unused: 0 };\n        const filtered = { total: 0, unused: 0 };\n        const filterApplied = this.textFilterRegExp !== null;\n        if (this.model) {\n            for (const info of this.model.entries()) {\n                all.total += info.size();\n                all.unused += info.unusedSize();\n                if (this.isVisible(false, info)) {\n                    if (this.textFilterRegExp?.test(info.url())) {\n                        filtered.total += info.size();\n                        filtered.unused += info.unusedSize();\n                    }\n                    else {\n                        // If it doesn't match the filter, calculate the stats from visible children if there are any\n                        for (const childInfo of info.sourcesURLCoverageInfo.values()) {\n                            if (this.isVisible(false, childInfo)) {\n                                filtered.total += childInfo.size();\n                                filtered.unused += childInfo.unusedSize();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.statusMessageElement.textContent = filterApplied ?\n            i18nString(UIStrings.filteredSTotalS, { PH1: formatStat(filtered), PH2: formatStat(all) }) :\n            formatStat(all);\n        function formatStat({ total, unused }) {\n            const used = total - unused;\n            const percentUsed = total ? Math.round(100 * used / total) : 0;\n            return i18nString(UIStrings.sOfSSUsedSoFarSUnused, {\n                PH1: Platform.NumberUtilities.bytesToString(used),\n                PH2: Platform.NumberUtilities.bytesToString(total),\n                PH3: percentUsed,\n                PH4: Platform.NumberUtilities.bytesToString(unused),\n            });\n        }\n    }\n    onFilterChanged() {\n        if (!this.listView) {\n            return;\n        }\n        const text = this.filterInput.value();\n        this.textFilterRegExp = text ? Platform.StringUtilities.createPlainTextSearchRegex(text, 'i') : null;\n        this.listView.updateFilterAndHighlight(this.textFilterRegExp);\n        this.updateStats();\n    }\n    onFilterByTypeChanged() {\n        if (!this.listView) {\n            return;\n        }\n        Host.userMetrics.actionTaken(Host.UserMetrics.Action.CoverageReportFiltered);\n        const option = this.filterByTypeComboBox.selectedOption();\n        const type = option && option.value;\n        this.typeFilterValue = parseInt(type || '', 10) || null;\n        this.listView.updateFilterAndHighlight(this.textFilterRegExp);\n        this.updateStats();\n    }\n    isVisible(ignoreTextFilter, coverageInfo) {\n        const url = coverageInfo.url();\n        if (url.startsWith(CoverageView.EXTENSION_BINDINGS_URL_PREFIX)) {\n            return false;\n        }\n        if (coverageInfo.isContentScript() && !this.showContentScriptsSetting.get()) {\n            return false;\n        }\n        if (this.typeFilterValue && !(coverageInfo.type() & this.typeFilterValue)) {\n            return false;\n        }\n        // If it's a parent, check if any children are visible\n        if (coverageInfo.sourcesURLCoverageInfo.size > 0) {\n            for (const sourceURLCoverageInfo of coverageInfo.sourcesURLCoverageInfo.values()) {\n                if (this.isVisible(ignoreTextFilter, sourceURLCoverageInfo)) {\n                    return true;\n                }\n            }\n        }\n        return ignoreTextFilter || !this.textFilterRegExp || this.textFilterRegExp.test(url);\n    }\n    async exportReport() {\n        const fos = new Bindings.FileUtils.FileOutputStream();\n        const fileName = `Coverage-${Platform.DateUtilities.toISO8601Compact(new Date())}.json`;\n        const accepted = await fos.open(fileName);\n        if (!accepted) {\n            return;\n        }\n        this.model && await this.model.exportReport(fos);\n    }\n    selectCoverageItemByUrl(url) {\n        this.listView.selectByUrl(url);\n    }\n    static EXTENSION_BINDINGS_URL_PREFIX = 'extensions::';\n    wasShown() {\n        UI.Context.Context.instance().setFlavor(CoverageView, this);\n        super.wasShown();\n        this.registerCSSFiles([coverageViewStyles]);\n    }\n    willHide() {\n        super.willHide();\n        UI.Context.Context.instance().setFlavor(CoverageView, null);\n    }\n}\nexport class ActionDelegate {\n    handleAction(_context, actionId) {\n        const coverageViewId = 'coverage';\n        void UI.ViewManager.ViewManager.instance()\n            .showView(coverageViewId, /** userGesture= */ false, /** omitFocus= */ true)\n            .then(() => {\n            const view = UI.ViewManager.ViewManager.instance().view(coverageViewId);\n            return view && view.widget();\n        })\n            .then(widget => this.innerHandleAction(widget, actionId));\n        return true;\n    }\n    innerHandleAction(coverageView, actionId) {\n        switch (actionId) {\n            case 'coverage.toggle-recording':\n                coverageView.toggleRecording();\n                break;\n            case 'coverage.start-with-reload':\n                void coverageView.startRecording({ reload: true, jsCoveragePerBlock: coverageView.isBlockCoverageSelected() });\n                break;\n            case 'coverage.clear':\n                coverageView.clear();\n                break;\n            case 'coverage.export':\n                void coverageView.exportReport();\n                break;\n            default:\n                console.assert(false, `Unknown action: ${actionId}`);\n        }\n    }\n}\n//# sourceMappingURL=CoverageView.js.map"],"names":["Events","COVERAGE_POLLING_PERIOD_MS","RESOLVE_SOURCEMAP_TIMEOUT","CoverageModel","SDK.SDKModel.SDKModel","target","SDK.CPUProfilerModel.CPUProfilerModel","SDK.CSSModel.CSSModel","SDK.DebuggerModel.DebuggerModel","SDK.SourceMapManager.Events","jsCoveragePerBlock","promises","SDK.CSSModel.Events","event","script","sourceMap","currentBacklog","url","urlCoverage","generatedContent","TextUtils.ContentData.ContentData","sourceSizeMap","sourceSegments","sourceURL","timestamp","occasion","coverageData","result","updates","reason","_reason","contentProvider","startOffset","endOffset","coverageInfo","entry","urlEntry","key","styleSheetHeader","updatesCSS","updatesJS","coverage","freshRawCoverageData","freshTimestamp","ascendingByTimestamp","x","y","results","rawCoverageData","stamp","scriptsCoverage","updatedEntries","ranges","type","func","range","subentry","ruleUsageList","rulesByStyleSheet","rule","a","b","stack","top","append","end","count","last","text","contentLength","calculateSize","startLine","startCol","endLine","endCol","mappings","lastEntry","totalSegmentSize","i","curEntry","entryRange","oldSize","size","segmentSize","endOffsetForLastEntry","startColumn","coverageInfoArray","isNewUrlCoverage","URLCoverageInfo","segments","usedSizeDelta","sourceUrl","sizeDelta","sourceURLCoverageInfo","generatedUrlCoverage","Workspace.Workspace.WorkspaceImpl","SourceURLCoverageInfo","fos","coverageByUrlKeys","urlInfoKey","urlInfo","Common.ParsedURL.schemeIs","locationCompare","aLine","aPos","bLine","bPos","Common.ObjectWrapper.ObjectWrapper","usedSize","lineOffset","columnOffset","SDK.Script.Script","CoverageInfo","useFullText","info","resource","SDK.ResourceTreeModel.ResourceTreeModel","fullText","coverageByLocationKeys","infoKey","offset","mergeSegments","segmentsA","segmentsB","indexA","indexB","generatedUrlCoverageInfo","oldUsedSize","start","index","Platform.ArrayUtilities.upperBound","position","segment","previousCount","used","sourceCoverage","segmentStart","lastFoundRange","segmentEnd","rangeStart","rangeEnd","overlapStart","overlapEnd","overlapSize","overlapRange","styles","UIStrings","str_","i18n.i18n.registerUIStrings","i18nString","i18n.i18n.getLocalizedString","coverageTypeToString","types","CoverageListView","UI.Widget.VBox","isVisibleFilter","columns","DataGrid.DataGrid.Order","DataGrid.SortableDataGrid.SortableDataGrid","dataGridWidget","hadUpdates","maxSize","acc","rootNode","node","GridNode","sourcesURLCoverageInfo","shouldCreateSourceNodes","sourceNode","highlightRegExp","hadTreeUpdates","shouldBeVisible","isVisible","sourceCode","Common.Revealer.reveal","columnId","sortFunction","coverageListViewStyles","percentageFormatter","getPercentageFormatter","i18n.DevToolsLocale.DevToolsLocale","bytesFormatter","getBytesFormatter","DataGrid.SortableDataGrid.SortableDataGridNode","cell","UI.Tooltip.Tooltip","outer","prefix","suffix","splitURL","sizeSpan","sizeFormatted","sizeAccessibleName","unusedSize","unusedSizeSpan","unusedPercentsSpan","unusedSizeFormatted","unusedPercentFormatted","unusedAccessibleName","barContainer","unusedPercent","usedPercent","unusedSizeBar","usedSizeBar","element","textContent","matches","TextUtils.TextRange.SourceRange","UI.UIUtils.highlightRangesWithStyleClass","compareURL","typeA","typeB","decoratorType","CoverageDecorationManager","#workspace","#debuggerBinding","#cssBinding","coverageModel","workspace","debuggerBinding","cssBinding","Platform.MapUtilities.Multimap","uiSourceCode","Workspace.Workspace.Events","lineMappings","endColumn","startLocationsPromise","endLocationsPromise","startLocations","endLocations","startIndex","endIndex","textValue","contentData","line","column","contentType","locations","location","rawStyleLocations","Workspace.UISourceCode.UILocation","header","coverageViewInstance","CoverageView","VisualLogging.panel","toolbarContainer","VisualLogging.toolbar","toolbar","UI.Toolbar.Toolbar","UI.Toolbar.ToolbarComboBox","coverageTypes","Common.Settings.Settings","UI.ActionRegistry.ActionRegistry","mainTarget","SDK.TargetManager.TargetManager","mainTargetSupportsRecordOnReload","UI.Toolbar.ToolbarFilter","options","option","UI.Toolbar.ToolbarSettingCheckbox","widget","message","UI.UIUtils.createInlineButton","i18n.i18n.getFormatLocalizedString","recordButton","className","reasonDiv","messageElement","selectedIndex","hadFocus","reloadButtonFocused","reload","Host.userMetrics","Host.UserMetrics.Action","resourceTreeModel","SDK.ResourceTreeModel.Events","Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding","Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding","data","frame","all","filtered","filterApplied","childInfo","formatStat","total","unused","percentUsed","Platform.NumberUtilities.bytesToString","Platform.StringUtilities.createPlainTextSearchRegex","ignoreTextFilter","Bindings.FileUtils.FileOutputStream","fileName","Platform.DateUtilities.toISO8601Compact","UI.Context.Context","coverageViewStyles","ActionDelegate","_context","actionId","coverageViewId","UI.ViewManager.ViewManager","view","coverageView"],"mappings":"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"}