{"version":3,"file":"DataGridController-DdQqp2ti.js","sources":["../../ui/components/data_grid/dataGrid.css.js","../../ui/components/data_grid/DataGridEvents.js","../../ui/components/data_grid/DataGridContextMenuUtils.js","../../ui/components/data_grid/DataGridRenderers.js","../../ui/components/data_grid/DataGridUtils.js","../../ui/components/data_grid/DataGrid.js","../../ui/components/data_grid/dataGridController.css.js","../../ui/components/data_grid/DataGridController.js"],"sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(\n`/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  height: 100%;\n  display: block;\n  position: relative;\n}\n\n/* Ensure that vertically we don't overflow */\n.wrapping-container {\n  overflow-y: auto;\n  /* Use max-height instead of height to ensure that the\n    table does not use more space than necessary. */\n  height: 100%;\n}\n\n.wrapping-container:not(.show-scrollbar)::-webkit-scrollbar {\n  display: none;\n}\n\ntable {\n  border-spacing: 0;\n  width: 100%;\n  height: 100%;\n  /* To make sure that we properly hide overflowing text\n    when horizontal space is too narrow. */\n  table-layout: fixed;\n}\n\ntr {\n  outline: none;\n}\n\nthead tr {\n  height: 27px;\n}\n\ntbody tr {\n  background-color: var(--override-data-grid-row-background-color, --sys-color-surface);\n}\n\ntbody tr:nth-child(odd) {\n  background-color: var(--sys-color-surface1);\n}\n\ntbody tr:hover:not(.selected) {\n  background-color: var(--sys-color-state-hover-on-subtle);\n}\n\ntbody tr.selected {\n  background-color: var(--sys-color-neutral-container);\n}\n\ntbody tr.selected:focus-within {\n  background-color: var(--sys-color-tonal-container);\n}\n\n.wrapping-container.striped tr:nth-child(odd):not(.selected):not(.padding-row):not(:hover) {\n  background-color: var(--sys-color-surface1);\n}\n\ntd,\nth {\n  box-sizing: border-box;\n  padding: 1px 4px;\n  border-left: 1px solid var(--sys-color-divider);\n  color: var(--sys-color-on-surface);\n  height: var(--table-row-height);\n  user-select: text;\n  /* Ensure that text properly cuts off if horizontal space is too narrow */\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\nth {\n  font-weight: normal;\n  text-align: left;\n  border-bottom: 1px solid var(--sys-color-divider);\n  position: sticky;\n  top: 0;\n  z-index: 2;\n  background-color: var(--sys-color-surface1);\n}\n\ntd:focus,\nth:focus {\n  outline: var(--sys-color-primary) auto 1px;\n}\n\nth:hover.sortable {\n  background-color: var(--sys-color-surface2);\n}\n\n.cell-resize-handle {\n  top: 0;\n  height: 100%;\n  z-index: 3;\n  width: 20px;\n  cursor: col-resize;\n  position: absolute;\n}\n\n/* There is no divider before the first cell */\ntd.firstVisibleColumn,\nth.firstVisibleColumn {\n  border-left-width: 0;\n}\n\n.hidden {\n  display: none;\n}\n\n.filler-row td {\n  /* By making the filler row cells 100% they take up any extra height,\n  * leaving the cells with content to be the regular height, and the\n  * final filler row to be as high as it needs to be to fill the empty\n  * space.\n  */\n  height: 100%;\n  pointer-events: none;\n  padding: 0;\n}\n\n.filler-row.empty-table td {\n  /* If the table is empty and we have no renderable rows, the filler row cell\n   * needs to have some form of padding to make it have some height, else it\n   * stays at a height of 0px and doesn't fill the table. With this padding set,\n   * it will then have some height & expand the row it's in to 100% high as\n   * desired. */\n  padding: 1px;\n}\n\ntbody tr.selected:focus-within td {\n  border-left-color: var(--sys-color-divider-on-tonal-container);\n}\n\n/* Leave space for the sort indicator */\n[aria-sort=\"ascending\"],\n[aria-sort=\"descending\"] {\n  padding-right: 20px;\n}\n\n[aria-sort=\"descending\"]::after {\n  content: \"\";\n  width: 0;\n  border-left: 0.4em solid transparent;\n  border-right: 0.4em solid transparent;\n  border-top: 0.4em solid var(--sys-color-token-subtle);\n  position: absolute;\n  right: 0.5em;\n  top: 0.85em;\n}\n\n[aria-sort=\"ascending\"]::after {\n  content: \"\";\n  width: 0;\n  border-bottom: 0.4em solid var(--sys-color-token-subtle);\n  border-left: 0.4em solid transparent;\n  border-right: 0.4em solid transparent;\n  position: absolute;\n  right: 0.5em;\n  top: 0.7em;\n}\n\n@media (forced-colors: active) {\n  th.sortable {\n    outline: Highlight auto 1px;\n  }\n\n  th:hover.sortable {\n    background-color: Highlight;\n  }\n\n  [aria-sort=\"ascending\"]::after {\n    forced-color-adjust: none;\n    border-bottom: 0.4em solid buttonText;\n  }\n\n  [aria-sort=\"descending\"]::after {\n    forced-color-adjust: none;\n    border-top: 0.4em solid buttonText;\n  }\n}\n\n/*# sourceURL=dataGrid.css */\n`);\n\nexport default styles;\n","export class ColumnHeaderClickEvent extends Event {\n    static eventName = 'columnheaderclick';\n    data;\n    constructor(column, columnIndex) {\n        super(ColumnHeaderClickEvent.eventName);\n        this.data = {\n            column,\n            columnIndex,\n        };\n    }\n}\nexport class ContextMenuColumnSortClickEvent extends Event {\n    static eventName = 'contextmenucolumnsortclick';\n    data;\n    constructor(column) {\n        super(ContextMenuColumnSortClickEvent.eventName);\n        this.data = {\n            column,\n        };\n    }\n}\nexport class ContextMenuHeaderResetClickEvent extends Event {\n    static eventName = 'contextmenuheaderresetclick';\n    constructor() {\n        super(ContextMenuHeaderResetClickEvent.eventName);\n    }\n}\nexport class NewUserFilterTextEvent extends Event {\n    static eventName = 'newuserfiltertext';\n    data;\n    constructor(filterText) {\n        super(NewUserFilterTextEvent.eventName, {\n            composed: true,\n        });\n        this.data = {\n            filterText,\n        };\n    }\n}\nexport class BodyCellFocusedEvent extends Event {\n    static eventName = 'cellfocused';\n    /**\n     * Although the DataGrid cares only about the focused cell, and has no concept\n     * of a focused row, many components that render a data grid want to know what\n     * row is active, so on the cell focused event we also send the row that the\n     * cell is part of.\n     */\n    data;\n    constructor(cell, row) {\n        super(BodyCellFocusedEvent.eventName, {\n            composed: true,\n        });\n        this.data = {\n            cell,\n            row,\n        };\n    }\n}\nexport class RowMouseEnterEvent extends Event {\n    static eventName = 'rowmouseenter';\n    data;\n    constructor(row) {\n        super(RowMouseEnterEvent.eventName, {\n            composed: true,\n        });\n        this.data = {\n            row,\n        };\n    }\n}\nexport class RowMouseLeaveEvent extends Event {\n    static eventName = 'rowmouseleave';\n    data;\n    constructor(row) {\n        super(RowMouseLeaveEvent.eventName, {\n            composed: true,\n        });\n        this.data = {\n            row,\n        };\n    }\n}\n//# sourceMappingURL=DataGridEvents.js.map","import { ContextMenuColumnSortClickEvent } from './DataGridEvents.js';\nfunction toggleColumnVisibility(dataGrid, column) {\n    const newVisibility = !column.visible;\n    const newColumns = dataGrid.data.columns.map(col => {\n        if (col === column) {\n            col.visible = newVisibility;\n        }\n        return col;\n    });\n    dataGrid.data = {\n        ...dataGrid.data,\n        columns: newColumns,\n    };\n}\n/**\n * This adds a checkbox to the context menu for each column in the datagrid that\n * is hideable. Columns that are visible will have a tick next to them, and\n * hidden ones will not. Upon clicking by the user the selected column's\n * visibility will be toggled.\n */\nexport function addColumnVisibilityCheckboxes(dataGrid, contextMenu) {\n    const { columns } = dataGrid.data;\n    for (const column of columns) {\n        if (!column.hideable) {\n            continue;\n        }\n        /**\n         * Append checkboxes for each column that is hideable; these will show\n         * with checkboxes if the column is visible and allow the user to click in\n         * the context menu to toggle an individual column's visibility.\n         */\n        contextMenu.defaultSection().appendCheckboxItem(column.title, () => {\n            toggleColumnVisibility(dataGrid, column);\n        }, { checked: column.visible, jslogContext: column.id });\n    }\n}\n/**\n * This adds an entry to the context menu for each column in the data grid that\n * is considered sortable, so the user can click on the context menu item to\n * change the data grid's sorting.\n *\n * This is also achieved by clicking on the column headers in the grid directly,\n * but we also support doing so via the context menu items.\n */\nexport function addSortableColumnItems(dataGrid, contextMenu) {\n    const sortableColumns = dataGrid.data.columns.filter(col => col.sortable === true);\n    if (sortableColumns.length > 0) {\n        for (const column of sortableColumns) {\n            contextMenu.defaultSection().appendItem(column.title, () => {\n                dataGrid.dispatchEvent(new ContextMenuColumnSortClickEvent(column));\n            }, { jslogContext: column.id });\n        }\n    }\n}\n//# sourceMappingURL=DataGridContextMenuUtils.js.map","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\nconst { html } = LitHtml;\nexport const primitiveRenderer = (value) => {\n    return html `${value}`;\n};\nexport const codeBlockRenderer = (value) => {\n    if (!value) {\n        return LitHtml.nothing;\n    }\n    const stringValue = String(value);\n    return html `<code>${stringValue}</code>`;\n};\nexport const iconRenderer = (icon) => {\n    if (!icon) {\n        return LitHtml.nothing;\n    }\n    return html `<div style=\"display: flex; justify-content: center;\">${icon}</div>`;\n};\n//# sourceMappingURL=DataGridRenderers.js.map","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as IconButton from '../../../ui/components/icon_button/icon_button.js';\nimport * as DataGridRenderers from './DataGridRenderers.js';\nexport function getStringifiedCellValues(cells) {\n    return JSON\n        .stringify(cells.map(cell => {\n        if (cell.value instanceof IconButton.Icon.Icon) {\n            return null;\n        }\n        return cell.value;\n    }))\n        .toLowerCase();\n}\nexport function getRowEntryForColumnId(row, id) {\n    const rowEntry = row.cells.find(r => r.columnId === id);\n    if (rowEntry === undefined) {\n        throw new Error(`Found a row that was missing an entry for column ${id}.`);\n    }\n    return rowEntry;\n}\nexport function renderCellValue(cell) {\n    if (cell.renderer) {\n        return cell.renderer(cell.value);\n    }\n    return DataGridRenderers.primitiveRenderer(cell.value);\n}\n/**\n * When the user passes in columns we want to know how wide each one should be.\n * We don't work in exact percentages, or pixel values, because it's then\n * unclear what to do in the event that one column is hidden. How do we\n * distribute up the extra space?\n *\n * Instead, each column has a weighting, which is its width proportionate to the\n * total weighting of all columns. For example:\n *\n * -> two columns both with widthWeighting: 1, will be 50% each, because the\n * total weight = 2, and each column is 1\n *\n * -> if you have two columns, the first width a weight of 2, and the second\n * with a weight of 1, the first will take up 66% and the other 33%.\n *\n * This way, when you are calculating the %, it's easy to do because if a\n * particular column becomes hidden, you ignore it / give it a weighting of 0,\n * and the space is evenly distributed amongst the remaining visible columns.\n *\n * @param allColumns\n * @param columnId\n */\nexport function calculateColumnWidthPercentageFromWeighting(allColumns, columnId) {\n    const totalWeights = allColumns.filter(c => c.visible).reduce((sumOfWeights, col) => sumOfWeights + col.widthWeighting, 0);\n    const matchingColumn = allColumns.find(c => c.id === columnId);\n    if (!matchingColumn) {\n        throw new Error(`Could not find column with ID ${columnId}`);\n    }\n    if (matchingColumn.widthWeighting < 1) {\n        throw new Error(`Error with column ${columnId}: width weightings must be >= 1.`);\n    }\n    if (!matchingColumn.visible) {\n        return 0;\n    }\n    return Math.round((matchingColumn.widthWeighting / totalWeights) * 100);\n}\nexport function handleArrowKeyNavigation(options) {\n    const { key, currentFocusedCell, columns, rows } = options;\n    const [selectedColIndex, selectedRowIndex] = currentFocusedCell;\n    switch (key) {\n        case \"ArrowLeft\" /* Platform.KeyboardUtilities.ArrowKey.LEFT */: {\n            const firstVisibleColumnIndex = columns.findIndex(c => c.visible);\n            if (selectedColIndex === firstVisibleColumnIndex) {\n                // User is as far left as they can go, so don't move them.\n                return [selectedColIndex, selectedRowIndex];\n            }\n            // Set the next index to first be the column we are already on, and then\n            // iterate back through all columns to our left, breaking the loop if we\n            // find one that's not hidden. If we don't find one, we'll stay where we\n            // are.\n            let nextColIndex = selectedColIndex;\n            for (let i = nextColIndex - 1; i >= 0; i--) {\n                const col = columns[i];\n                if (col.visible) {\n                    nextColIndex = i;\n                    break;\n                }\n            }\n            return [nextColIndex, selectedRowIndex];\n        }\n        case \"ArrowRight\" /* Platform.KeyboardUtilities.ArrowKey.RIGHT */: {\n            // Set the next index to first be the column we are already on, and then\n            // iterate through all columns to our right, breaking the loop if we\n            // find one that's not hidden. If we don't find one, we'll stay where we\n            // are.\n            let nextColIndex = selectedColIndex;\n            for (let i = nextColIndex + 1; i < columns.length; i++) {\n                const col = columns[i];\n                if (col.visible) {\n                    nextColIndex = i;\n                    break;\n                }\n            }\n            return [nextColIndex, selectedRowIndex];\n        }\n        case \"ArrowUp\" /* Platform.KeyboardUtilities.ArrowKey.UP */: {\n            const columnsSortable = columns.some(col => col.sortable === true);\n            const minRowIndex = columnsSortable ? 0 : 1;\n            if (selectedRowIndex === minRowIndex) {\n                // If any columns are sortable the user can navigate into the column\n                // header row, else they cannot. So if they are on the highest row they\n                // can be, just return the current cell as they cannot move up.\n                return [selectedColIndex, selectedRowIndex];\n            }\n            let rowIndexToMoveTo = selectedRowIndex;\n            for (let i = selectedRowIndex - 1; i >= minRowIndex; i--) {\n                // This means we got past all the body rows and therefore the user needs\n                // to go into the column row.\n                if (i === 0) {\n                    rowIndexToMoveTo = 0;\n                    break;\n                }\n                const matchingRow = rows[i - 1];\n                if (!matchingRow.hidden) {\n                    rowIndexToMoveTo = i;\n                    break;\n                }\n            }\n            return [selectedColIndex, rowIndexToMoveTo];\n        }\n        case \"ArrowDown\" /* Platform.KeyboardUtilities.ArrowKey.DOWN */: {\n            if (selectedRowIndex === 0) {\n                // The user is on the column header. So find the first visible body row and take them there!\n                const firstVisibleBodyRowIndex = rows.findIndex(row => !row.hidden);\n                if (firstVisibleBodyRowIndex > -1) {\n                    return [selectedColIndex, firstVisibleBodyRowIndex + 1];\n                }\n                // If we didn't find a single visible row, leave the user where they are.\n                return [selectedColIndex, selectedRowIndex];\n            }\n            let rowIndexToMoveTo = selectedRowIndex;\n            // Work down from our starting position to find the next visible row to move to.\n            for (let i = rowIndexToMoveTo + 1; i < rows.length + 1; i++) {\n                const matchingRow = rows[i - 1];\n                if (!matchingRow.hidden) {\n                    rowIndexToMoveTo = i;\n                    break;\n                }\n            }\n            return [selectedColIndex, rowIndexToMoveTo];\n        }\n        default:\n            return Platform.assertNever(key, `Unknown arrow key: ${key}`);\n    }\n}\nexport const calculateFirstFocusableCell = (options) => {\n    const { columns, rows } = options;\n    const someColumnsSortable = columns.some(col => col.sortable === true);\n    const focusableRowIndex = someColumnsSortable ? 0 : rows.findIndex(row => !row.hidden) + 1;\n    const focusableColIndex = columns.findIndex(col => col.visible);\n    return [focusableColIndex, focusableRowIndex];\n};\nexport const getCellTitleFromCellContent = (text) => text.length < 25 ? text : text.substr(0, 20) + '\\u2026';\n//# sourceMappingURL=DataGridUtils.js.map","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Host from '../../../core/host/host.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as UI from '../../legacy/legacy.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as VisualLogging from '../../visual_logging/visual_logging.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\nimport dataGridStyles from './dataGrid.css.js';\nimport { BodyCellFocusedEvent, ColumnHeaderClickEvent, ContextMenuHeaderResetClickEvent, RowMouseEnterEvent, RowMouseLeaveEvent, } from './DataGridEvents.js';\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\nimport { addColumnVisibilityCheckboxes, addSortableColumnItems } from './DataGridContextMenuUtils.js';\nimport { calculateColumnWidthPercentageFromWeighting, calculateFirstFocusableCell, getCellTitleFromCellContent, getRowEntryForColumnId, handleArrowKeyNavigation, renderCellValue, } from './DataGridUtils.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nconst { html, Directives: { ifDefined, classMap, styleMap, repeat } } = LitHtml;\nconst UIStrings = {\n    /**\n     *@description A context menu item in the Data Grid of a data grid\n     */\n    sortBy: 'Sort By',\n    /**\n     *@description A context menu item in data grids to reset the columns to their default weight\n     */\n    resetColumns: 'Reset Columns',\n    /**\n     *@description A context menu item in data grids to list header options.\n     */\n    headerOptions: 'Header Options',\n    /**\n     *@description Text for screen reader to announce when focusing on a sortable column in data grid.\n     *@example {ascending} PH1\n     */\n    enterToSort: 'Column sort state: {PH1}. Press enter to apply sorting filter',\n    /**\n     *@description The current sort state of a column in data grid\n     */\n    sortAsc: 'ascending',\n    /**\n     *@description The current sort state of a column in data grid\n     */\n    sortDesc: 'descending',\n    /**\n     *@description The current sort state of a column in data grid\n     */\n    sortNone: 'none',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst KEYS_TREATED_AS_CLICKS = new Set([' ', 'Enter']);\nconst ROW_HEIGHT_PIXELS = 20;\nexport class DataGrid extends HTMLElement {\n    #shadow = this.attachShadow({ mode: 'open' });\n    #columns = [];\n    #rows = [];\n    #sortState = null;\n    #isRendering = false;\n    #userScrollState = \"NOT_SCROLLED\" /* UserScrollState.NOT_SCROLLED */;\n    #contextMenus = undefined;\n    #label = undefined;\n    #paddingRowsCount = 10;\n    #showScrollbar = false;\n    #striped = false;\n    #autoScrollToBottom = true;\n    #currentResize = null;\n    // Because we only render a subset of rows, we need a way to look up the\n    // actual row index from the original dataset. We could use this.rows[index]\n    // but that's O(n) and will slow as the dataset grows. A weakmap makes the\n    // lookup constant.\n    #rowIndexMap = new WeakMap();\n    #resizeObserver = new ResizeObserver(() => {\n        void this.#alignScrollHandlers();\n    });\n    // Thie have to be bound as they are put onto the global document, not onto\n    // this element, so LitHtml does not bind them for us.\n    #boundOnResizePointerMove = this.#onResizePointerMove.bind(this);\n    /**\n     * Following guidance from\n     * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html, we\n     * allow a single cell inside the table to be focusable, such that when a user\n     * tabs in they select that cell. IMPORTANT: if the data-grid has sortable\n     * columns, the user has to be able to navigate to the headers to toggle the\n     * sort. [0,0] is considered the first cell INCLUDING the column header\n     * Therefore if a user is on the first header cell, the position is considered [0, 0],\n     * and if a user is on the first body cell, the position is considered [0, 1].\n     *\n     * We set the selectable cell to the first tbody value by default, but then on the\n     * first render if any of the columns are sortable we'll set the active cell\n     * to [0, 0].\n     */\n    #cellToFocusIfUserTabsIn = [0, 1];\n    #cellUserHasFocused = null;\n    #hasRenderedAtLeastOnce = false;\n    #userHasFocusInDataGrid = false;\n    #scheduleRender = false;\n    connectedCallback() {\n        this.#shadow.adoptedStyleSheets = [dataGridStyles];\n        this.style.setProperty('--table-row-height', `${ROW_HEIGHT_PIXELS}px`);\n        void this.#render();\n    }\n    get data() {\n        return {\n            columns: this.#columns,\n            rows: this.#rows,\n            activeSort: this.#sortState,\n            contextMenus: this.#contextMenus,\n            autoScrollToBottom: this.#autoScrollToBottom,\n            label: this.#label,\n            paddingRowsCount: this.#paddingRowsCount,\n            showScrollbar: this.#showScrollbar,\n            striped: this.#striped,\n        };\n    }\n    set data(data) {\n        this.#columns = data.columns;\n        this.#rows = data.rows;\n        this.#rows.forEach((row, index) => {\n            this.#rowIndexMap.set(row, index);\n        });\n        this.#sortState = data.activeSort;\n        this.#contextMenus = data.contextMenus;\n        this.#label = data.label;\n        this.#showScrollbar = data.showScrollbar;\n        this.#striped = data.striped;\n        if (typeof data.autoScrollToBottom === 'boolean') {\n            this.#autoScrollToBottom = data.autoScrollToBottom;\n        }\n        /**\n         * On first render, now we have data, we can figure out which cell is the\n         * focusable cell for the table.\n         *\n         * If any columns are sortable, we pick [0, 0], which is the first cell of\n         * the columns row. However, if any columns are hidden, we adjust\n         * accordingly. e.g., if the first column is hidden, we'll set the starting\n         * index as [1, 0].\n         *\n         * If the columns aren't sortable, we pick the first visible body row as the\n         * index.\n         *\n         * We only do this on the first render; otherwise if we re-render and the\n         * user has focused a cell, this logic will reset it.\n         */\n        if (!this.#hasRenderedAtLeastOnce) {\n            this.#cellToFocusIfUserTabsIn = calculateFirstFocusableCell({ columns: this.#columns, rows: this.#rows });\n        }\n        if (data.paddingRowsCount !== undefined) {\n            this.#paddingRowsCount = data.paddingRowsCount;\n        }\n        if (this.#hasRenderedAtLeastOnce && this.#userHasCellFocused()) {\n            const [selectedColIndex, selectedRowIndex] = this.#tabbableCell();\n            const columnOutOfBounds = selectedColIndex > this.#columns.length;\n            const rowOutOfBounds = selectedRowIndex > this.#rows.length;\n            /** If the row or column was removed, so the user is out of bounds, we\n             * move them to the last focusable cell, which should be close to where\n             * they were. */\n            if (columnOutOfBounds || rowOutOfBounds) {\n                this.#cellUserHasFocused = [\n                    columnOutOfBounds ? this.#columns.length : selectedColIndex,\n                    rowOutOfBounds ? this.#rows.length : selectedRowIndex,\n                ];\n            }\n        }\n        void this.#render();\n    }\n    #shouldAutoScrollToBottom() {\n        if (!this.#autoScrollToBottom) {\n            return false;\n        }\n        /**\n         * If the user's last scroll took them to the bottom, then we assume they\n         * want to automatically scroll.\n         */\n        if (this.#userScrollState === \"SCROLLED_TO_BOTTOM\" /* UserScrollState.SCROLLED_TO_BOTTOM */) {\n            return true;\n        }\n        /**\n         * If the user does not have focus in the data grid (e.g. they haven't\n         * selected a cell), we automatically scroll, as long as the user hasn't\n         * manually scrolled the data-grid to somewhere that isn't the bottom.\n         */\n        if (!this.#userHasFocusInDataGrid && this.#userScrollState !== \"MANUAL_SCROLL_NOT_BOTTOM\" /* UserScrollState.MANUAL_SCROLL_NOT_BOTTOM */) {\n            return true;\n        }\n        /**\n         * Else, the user has focused a cell, or their last scroll action took them\n         * not to the bottom, so we assume that they don't want to be auto-scrolled.\n         */\n        return false;\n    }\n    #scrollToBottomIfRequired() {\n        if (this.#hasRenderedAtLeastOnce === false || !this.#shouldAutoScrollToBottom()) {\n            return;\n        }\n        const wrapper = this.#shadow.querySelector('.wrapping-container');\n        if (!wrapper) {\n            return;\n        }\n        void coordinator.scroll(() => {\n            const scrollHeight = wrapper.scrollHeight;\n            wrapper.scrollTo(0, scrollHeight);\n        });\n    }\n    #engageResizeObserver() {\n        if (!this.#hasRenderedAtLeastOnce) {\n            this.#resizeObserver.observe(this.#shadow.host);\n        }\n    }\n    #userHasCellFocused() {\n        return this.#cellUserHasFocused !== null;\n    }\n    #getTableElementForCellUserHasFocused() {\n        if (!this.#cellUserHasFocused) {\n            return null;\n        }\n        const [columnIndex, rowIndex] = this.#cellUserHasFocused;\n        const cell = this.#shadow.querySelector(`[data-row-index=\"${rowIndex}\"][data-col-index=\"${columnIndex}\"]`);\n        return cell;\n    }\n    #focusTableCellInDOM(cell) {\n        cell.focus();\n    }\n    #focusCellIfRequired([newColumnIndex, newRowIndex]) {\n        this.#userHasFocusInDataGrid = true;\n        if (this.#cellUserHasFocused && this.#cellUserHasFocused[0] === newColumnIndex &&\n            this.#cellUserHasFocused[1] === newRowIndex) {\n            // The cell is already active and focused so we don't need to do anything.\n            return;\n        }\n        this.#cellUserHasFocused = [newColumnIndex, newRowIndex];\n        void this.#render();\n        const tableCell = this.#getTableElementForCellUserHasFocused();\n        if (!tableCell) {\n            // Return in case the cell is out of bounds and we do nothing\n            return;\n        }\n        /* The cell may already be focused if the user clicked into it, but we also\n         * add arrow key support, so in the case where we're programatically moving the\n         * focus, ensure we actually focus the cell.\n         */\n        this.#focusTableCellInDOM(tableCell);\n        // If it's a sortable column header, screen reader announce the information for sorting\n        if (newRowIndex === 0 && this.#columns[newColumnIndex].sortable) {\n            const localizedSortState = this.#getLocalizedSortState(this.#columns[newColumnIndex]);\n            UI.ARIAUtils.alert(i18nString(UIStrings.enterToSort, { PH1: localizedSortState || '' }));\n        }\n    }\n    #getLocalizedSortState(col) {\n        const currentSortLabel = this.#ariaSortForHeader(col);\n        switch (currentSortLabel) {\n            case 'ascending':\n                return UIStrings.sortAsc;\n            case 'descending':\n                return UIStrings.sortDesc;\n            case 'none':\n                return UIStrings.sortNone;\n        }\n        return undefined;\n    }\n    #onTableKeyDown(event) {\n        const key = event.key;\n        if (!this.#cellUserHasFocused) {\n            return;\n        }\n        if (KEYS_TREATED_AS_CLICKS.has(key)) {\n            const [focusedColumnIndex, focusedRowIndex] = this.#cellUserHasFocused;\n            const activeColumn = this.#columns[focusedColumnIndex];\n            if (focusedRowIndex === 0 && activeColumn && activeColumn.sortable) {\n                this.#onColumnHeaderClick(activeColumn, focusedColumnIndex);\n            }\n        }\n        if (!Platform.KeyboardUtilities.keyIsArrowKey(key)) {\n            return;\n        }\n        const nextFocusedCell = handleArrowKeyNavigation({\n            key,\n            currentFocusedCell: this.#cellUserHasFocused,\n            columns: this.#columns,\n            rows: this.#rows,\n        });\n        event.preventDefault();\n        this.#focusCellIfRequired(nextFocusedCell);\n    }\n    #onColumnHeaderClick(col, index) {\n        this.dispatchEvent(new ColumnHeaderClickEvent(col, index));\n    }\n    /**\n     * Applies the aria-sort label to a column's th.\n     * Guidance on values of attribute taken from\n     * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html.\n     */\n    #ariaSortForHeader(col) {\n        if (col.sortable && (!this.#sortState || this.#sortState.columnId !== col.id)) {\n            // Column is sortable but is not currently sorted\n            return 'none';\n        }\n        if (this.#sortState && this.#sortState.columnId === col.id) {\n            return this.#sortState.direction === \"ASC\" /* SortDirection.ASC */ ? 'ascending' : 'descending';\n        }\n        // Column is not sortable, so don't apply any label\n        return undefined;\n    }\n    #renderEmptyFillerRow(numberOfVisibleRows) {\n        const emptyCells = this.#columns.map((col, colIndex) => {\n            if (!col.visible) {\n                return LitHtml.nothing;\n            }\n            const emptyCellClasses = LitHtml.Directives.classMap({\n                firstVisibleColumn: colIndex === 0,\n            });\n            return html `<td aria-hidden=\"true\" class=${emptyCellClasses} data-filler-row-column-index=${colIndex}></td>`;\n        });\n        const emptyRowClasses = LitHtml.Directives.classMap({\n            'filler-row': true,\n            'padding-row': true,\n            'empty-table': numberOfVisibleRows === 0,\n        });\n        return html `<tr aria-hidden=\"true\" class=${emptyRowClasses}>${emptyCells}</tr>`;\n    }\n    #cleanUpAfterResizeColumnComplete() {\n        if (!this.#currentResize) {\n            return;\n        }\n        this.#currentResize.documentForCursorChange.body.style.cursor = this.#currentResize.cursorToRestore;\n        this.#currentResize = null;\n        // Realign the scroll handlers now the table columns have been resized.\n        void this.#alignScrollHandlers();\n    }\n    #onResizePointerDown(event) {\n        if (event.buttons !== 1 || (Host.Platform.isMac() && event.ctrlKey)) {\n            // Ensure we only react to a left click drag mouse down event.\n            // On Mac we ignore Ctrl-click which can be used to bring up context menus, etc.\n            return;\n        }\n        event.preventDefault();\n        const resizerElement = event.target;\n        if (!resizerElement) {\n            return;\n        }\n        const leftColumnIndex = resizerElement.dataset.columnIndex;\n        if (!leftColumnIndex) {\n            return;\n        }\n        const leftColumnIndexAsNumber = globalThis.parseInt(leftColumnIndex, 10);\n        /* To find the cell to the right we can't just go +1 as it might be hidden,\n         * so find the next index that is visible.\n         */\n        const rightColumnIndexAsNumber = this.#columns.findIndex((column, index) => {\n            return index > leftColumnIndexAsNumber && column.visible === true;\n        });\n        const leftCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${leftColumnIndexAsNumber}\"]`);\n        const rightCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${rightColumnIndexAsNumber}\"]`);\n        if (!leftCell || !rightCell) {\n            return;\n        }\n        // We query for the <col> elements as they are the elements that we put the actual width on.\n        const leftCellCol = this.#shadow.querySelector(`col[data-col-column-index=\"${leftColumnIndexAsNumber}\"]`);\n        const rightCellCol = this.#shadow.querySelector(`col[data-col-column-index=\"${rightColumnIndexAsNumber}\"]`);\n        if (!leftCellCol || !rightCellCol) {\n            return;\n        }\n        const targetDocumentForCursorChange = event.target.ownerDocument;\n        if (!targetDocumentForCursorChange) {\n            return;\n        }\n        // We now store values that we'll make use of in the mousemouse event to calculate how much to resize the table by.\n        this.#currentResize = {\n            leftCellCol,\n            rightCellCol,\n            leftCellColInitialPercentageWidth: globalThis.parseInt(leftCellCol.style.width, 10),\n            rightCellColInitialPercentageWidth: globalThis.parseInt(rightCellCol.style.width, 10),\n            initialLeftCellWidth: leftCell.clientWidth,\n            initialRightCellWidth: rightCell.clientWidth,\n            initialMouseX: event.x,\n            documentForCursorChange: targetDocumentForCursorChange,\n            cursorToRestore: resizerElement.style.cursor,\n        };\n        targetDocumentForCursorChange.body.style.cursor = 'col-resize';\n        resizerElement.setPointerCapture(event.pointerId);\n        resizerElement.addEventListener('pointermove', this.#boundOnResizePointerMove);\n    }\n    #onResizePointerMove(event) {\n        event.preventDefault();\n        if (!this.#currentResize) {\n            return;\n        }\n        const MIN_CELL_WIDTH_PERCENTAGE = 10;\n        const MAX_CELL_WIDTH_PERCENTAGE = (this.#currentResize.leftCellColInitialPercentageWidth +\n            this.#currentResize.rightCellColInitialPercentageWidth) -\n            MIN_CELL_WIDTH_PERCENTAGE;\n        const deltaOfMouseMove = event.x - this.#currentResize.initialMouseX;\n        const absoluteDelta = Math.abs(deltaOfMouseMove);\n        const percentageDelta = (absoluteDelta / (this.#currentResize.initialLeftCellWidth + this.#currentResize.initialRightCellWidth)) * 100;\n        let newLeftColumnPercentage;\n        let newRightColumnPercentage;\n        if (deltaOfMouseMove > 0) {\n            /**\n             * A positive delta means the user moved their mouse to the right, so we\n             * want to make the right column smaller, and the left column larger.\n             */\n            newLeftColumnPercentage = Platform.NumberUtilities.clamp(this.#currentResize.leftCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE, MAX_CELL_WIDTH_PERCENTAGE);\n            newRightColumnPercentage = Platform.NumberUtilities.clamp(this.#currentResize.rightCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE, MAX_CELL_WIDTH_PERCENTAGE);\n        }\n        else if (deltaOfMouseMove < 0) {\n            /**\n             * Negative delta means the user moved their mouse to the left, which\n             * means we want to make the right column larger, and the left column\n             * smaller.\n             */\n            newLeftColumnPercentage = Platform.NumberUtilities.clamp(this.#currentResize.leftCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE, MAX_CELL_WIDTH_PERCENTAGE);\n            newRightColumnPercentage = Platform.NumberUtilities.clamp(this.#currentResize.rightCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE, MAX_CELL_WIDTH_PERCENTAGE);\n        }\n        if (!newLeftColumnPercentage || !newRightColumnPercentage) {\n            // The delta was 0, so nothing to do.\n            return;\n        }\n        // We limit the values to two decimal places to not work with huge decimals.\n        // It also prevents stuttering if the user barely moves the mouse, as the\n        // browser won't try to move the column by 0.0000001% or similar.\n        this.#currentResize.leftCellCol.style.width = newLeftColumnPercentage.toFixed(2) + '%';\n        this.#currentResize.rightCellCol.style.width = newRightColumnPercentage.toFixed(2) + '%';\n    }\n    #onResizePointerUp(event) {\n        event.preventDefault();\n        const resizer = event.target;\n        if (!resizer) {\n            return;\n        }\n        resizer.releasePointerCapture(event.pointerId);\n        resizer.removeEventListener('pointermove', this.#boundOnResizePointerMove);\n        this.#cleanUpAfterResizeColumnComplete();\n    }\n    #renderResizeForCell(column, position) {\n        /**\n         * A resizer for a column is placed at the far right of the _previous column\n         * cell_. So when we get called with [1, 0] that means this dragger is\n         * resizing column 1, but the dragger itself is located within column 0. We\n         * need the column to the left because when you resize a column you're not\n         * only resizing it but also the column to its left.\n         */\n        const [columnIndex] = position;\n        const lastVisibleColumnIndex = this.#getIndexOfLastVisibleColumn();\n        // If we are in the very last column, there is no column to the right to resize, so don't render a resizer.\n        if (columnIndex === lastVisibleColumnIndex || !column.visible) {\n            return LitHtml.nothing;\n        }\n        return html `<span class=\"cell-resize-handle\"\n     @pointerdown=${this.#onResizePointerDown}\n     @pointerup=${this.#onResizePointerUp}\n     data-column-index=${columnIndex}\n    ></span>`;\n    }\n    #getIndexOfLastVisibleColumn() {\n        let index = this.#columns.length - 1;\n        for (; index > -1; index--) {\n            const col = this.#columns[index];\n            if (col.visible) {\n                break;\n            }\n        }\n        return index;\n    }\n    /**\n     * This function is called when the user right clicks on the header row of the\n     * data grid.\n     */\n    #onHeaderContextMenu(event) {\n        if (event.button !== 2 && event.button !== -1) {\n            // -1 = right click invoked by keyboard, for example 'Shift + F10'.\n            // 2 = secondary button = right click. We only show context menus if the\n            // user has right clicked.\n            return;\n        }\n        const menu = new UI.ContextMenu.ContextMenu(event);\n        addColumnVisibilityCheckboxes(this, menu);\n        const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy), false, 'sort-by');\n        addSortableColumnItems(this, sortMenu);\n        menu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n            this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n        }, { jslogContext: 'reset-columns' });\n        if (this.#contextMenus && this.#contextMenus.headerRow) {\n            // Let the user append things to the menu\n            this.#contextMenus.headerRow(menu, this.#columns);\n        }\n        void menu.show();\n    }\n    #onBodyRowContextMenu(event) {\n        if (event.button !== 2 && event.button !== -1) {\n            // -1 = right click invoked by keyboard, for example 'Shift + F10'.\n            // 2 = secondary button = right click. We only show context menus if the\n            // user has right clicked.\n            return;\n        }\n        /**\n         * We now make sure that the event came from an HTML element with a\n         * data-row-index attribute, else we bail.\n         */\n        if (!event.target || !(event.target instanceof HTMLElement)) {\n            return;\n        }\n        const rowIndexAttribute = event.target.dataset.rowIndex;\n        if (!rowIndexAttribute) {\n            return;\n        }\n        const rowIndex = parseInt(rowIndexAttribute, 10);\n        // rowIndex - 1 here because in the UI the 0th row is the column headers.\n        const rowThatWasClicked = this.#rows[rowIndex - 1];\n        const menu = new UI.ContextMenu.ContextMenu(event);\n        const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy), false, 'sort-by');\n        addSortableColumnItems(this, sortMenu);\n        const headerOptionsMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions), false, 'header-options');\n        addColumnVisibilityCheckboxes(this, headerOptionsMenu);\n        headerOptionsMenu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n            this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n        }, { jslogContext: 'reset-columns' });\n        if (this.#contextMenus && this.#contextMenus.bodyRow) {\n            this.#contextMenus.bodyRow(menu, this.#columns, rowThatWasClicked, this.#rows);\n        }\n        void menu.show();\n    }\n    #onScroll(event) {\n        const wrapper = event.target;\n        if (!wrapper) {\n            return;\n        }\n        // Need to Math.round because on high res screens we can end up with decimal\n        // point numbers for scroll positions.\n        const userIsAtBottom = Math.round(wrapper.scrollTop + wrapper.clientHeight) === Math.round(wrapper.scrollHeight);\n        this.#userScrollState =\n            userIsAtBottom ? \"SCROLLED_TO_BOTTOM\" /* UserScrollState.SCROLLED_TO_BOTTOM */ : \"MANUAL_SCROLL_NOT_BOTTOM\" /* UserScrollState.MANUAL_SCROLL_NOT_BOTTOM */;\n        void this.#render();\n    }\n    #alignScrollHandlers() {\n        return coordinator.read(() => {\n            const columnHeaders = this.#shadow.querySelectorAll('th:not(.hidden)');\n            const handlers = this.#shadow.querySelectorAll('.cell-resize-handle');\n            const table = this.#shadow.querySelector('table');\n            if (!table) {\n                return;\n            }\n            columnHeaders.forEach(async (header, index) => {\n                const columnWidth = header.clientWidth;\n                const columnLeftOffset = header.offsetLeft;\n                if (handlers[index]) {\n                    const handlerWidth = handlers[index].clientWidth;\n                    void coordinator.write(() => {\n                        /**\n                         * Render the resizer at the far right of the column; we subtract\n                         * its width so it sits on the inner edge of the column.\n                         */\n                        handlers[index].style.left = `${columnLeftOffset + columnWidth - handlerWidth}px`;\n                    });\n                }\n            });\n        });\n    }\n    /**\n     * Calculates the index of the first row we want to render, and the last row we want to render.\n     * Pads in each direction by PADDING_ROWS_COUNT so we render some rows that are off scren.\n     */\n    #calculateTopAndBottomRowIndexes() {\n        return coordinator.read(() => {\n            const wrapper = this.#shadow.querySelector('.wrapping-container');\n            // On first render we don't have a wrapper, so we can't get at its\n            // scroll/height values. So we default to the inner height of the window as\n            // the limit for rendering. This means we may over-render by a few rows, but\n            // better that than either render everything, or rendering too few rows.\n            let scrollTop = 0;\n            let clientHeight = window.innerHeight;\n            if (wrapper) {\n                scrollTop = wrapper.scrollTop;\n                clientHeight = wrapper.clientHeight;\n            }\n            const padding = ROW_HEIGHT_PIXELS * this.#paddingRowsCount;\n            let topVisibleRow = Math.floor((scrollTop - padding) / ROW_HEIGHT_PIXELS);\n            let bottomVisibleRow = Math.ceil((scrollTop + clientHeight + padding) / ROW_HEIGHT_PIXELS);\n            topVisibleRow = Math.max(0, topVisibleRow);\n            bottomVisibleRow = Math.min(this.#rows.filter(r => !r.hidden).length, bottomVisibleRow);\n            return {\n                topVisibleRow,\n                bottomVisibleRow,\n            };\n        });\n    }\n    #onFocusOut() {\n        /**\n         * When any element in the data-grid loses focus, we set this to false. If\n         * the user then focuses another cell, that code will set the focus to true.\n         * We need to know if the user is focused because if they are and they've\n         * scrolled their focused cell out of rendering view and back in, we want to\n         * refocus it. But if they aren't focused and that happens, we don't, else\n         * we can steal focus away from the user if they are typing into an input\n         * box to filter the data-grid, for example.\n         */\n        this.#userHasFocusInDataGrid = false;\n    }\n    #tabbableCell() {\n        /**\n         * If the user has selected a cell, this is the cell that should be\n         * \"tabbable\" if the user tabs out and into the data-grid. If the user\n         * hasn't selected a cell, we fallback to the default cell that we set as\n         * tabbable when we render.\n         */\n        return this.#cellUserHasFocused || this.#cellToFocusIfUserTabsIn;\n    }\n    /**\n     * Renders the data-grid table. Note that we do not render all rows; the\n     * performance cost are too high once you have a large enough table. Instead\n     * we calculate the size of the container we are rendering into, and then\n     * render only the rows required to fill that table (plus a bit extra for\n     * padding).\n     */\n    async #render() {\n        if (!this.isConnected) {\n            return;\n        }\n        if (this.#isRendering) {\n            // If we receive a request to render during a previous render call, we block\n            // the newly requested render (since we could receive a lot of them in quick\n            // succession), but we do ensure that at the end of the current render we\n            // go again with the latest data.\n            this.#scheduleRender = true;\n            return;\n        }\n        this.#isRendering = true;\n        const { topVisibleRow, bottomVisibleRow } = await this.#calculateTopAndBottomRowIndexes();\n        const nonHiddenRows = this.#rows.filter(row => !row.hidden);\n        const renderableRows = nonHiddenRows.filter((_, idx) => idx >= topVisibleRow && idx <= bottomVisibleRow);\n        const indexOfFirstVisibleColumn = this.#columns.findIndex(col => col.visible);\n        const anyColumnsSortable = this.#columns.some(col => col.sortable === true);\n        const containerClassMap = {\n            'wrapping-container': true,\n            'show-scrollbar': this.#showScrollbar === true,\n            striped: this.#striped === true,\n        };\n        await coordinator.write(() => {\n            // Disabled until https://crbug.com/1079231 is fixed.\n            // clang-format off\n            LitHtml.render(html `\n      ${this.#columns.map((col, columnIndex) => {\n                /**\n                 * We render the resizers outside of the table. One is rendered for each\n                 * column, and they are positioned absolutely at the right position. They\n                 * have 100% height so they sit over the entire table and can be grabbed\n                 * by the user.\n                 */\n                return this.#renderResizeForCell(col, [columnIndex, 0]);\n            })}\n      <div class=${classMap(containerClassMap)} @scroll=${this.#onScroll} @focusout=${this.#onFocusOut}>\n        <table\n          aria-label=${ifDefined(this.#label)}\n          aria-rowcount=${this.#rows.length}\n          aria-colcount=${this.#columns.length}\n          @keydown=${this.#onTableKeyDown}\n        >\n          <!-- @ts-ignore -->\n          <colgroup>\n            ${this.#columns.map((col, colIndex) => {\n                const width = calculateColumnWidthPercentageFromWeighting(this.#columns, col.id);\n                const style = `width: ${width}%`;\n                if (!col.visible) {\n                    return LitHtml.nothing;\n                }\n                return html `<col style=${style} data-col-column-index=${colIndex}>`;\n            })}\n          </colgroup>\n          <thead>\n            <tr @contextmenu=${this.#onHeaderContextMenu}>\n              ${this.#columns.map((col, columnIndex) => {\n                const thClasses = classMap({\n                    hidden: !col.visible,\n                    firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                    sortable: anyColumnsSortable,\n                });\n                const tabbableCell = this.#tabbableCell();\n                const cellIsFocusableCell = anyColumnsSortable && columnIndex === tabbableCell[0] && tabbableCell[1] === 0;\n                return html `<th class=${thClasses}\n                  jslog=${VisualLogging.tableHeader().track({ click: anyColumnsSortable, resize: true }).context(col.id)}\n                  style=${ifDefined(col.styles ? styleMap(col.styles) : undefined)}\n                  data-grid-header-cell=${col.id}\n                  @focus=${() => {\n                    this.#focusCellIfRequired([columnIndex, 0]);\n                }}\n                  @click=${() => {\n                    /**\n                     * We use click here rather than focus because if you've\n                     * clicked on the header to sort, you've also focused it. If\n                     * you then click it again to change the sorting, this\n                     * doesn't emit a focus event as the cell is already\n                     * focused.\n                     */\n                    this.#onColumnHeaderClick(col, columnIndex);\n                }}\n                  title=${col.title}\n                  aria-sort=${ifDefined(this.#ariaSortForHeader(col))}\n                  aria-colindex=${columnIndex + 1}\n                  data-row-index='0'\n                  data-col-index=${columnIndex}\n                  tabindex=${ifDefined(anyColumnsSortable ? (cellIsFocusableCell ? '0' : '-1') : undefined)}\n                >${col.titleElement || col.title}</th>`;\n            })}\n            </tr>\n          </thead>\n          <tbody>\n            <tr class=\"filler-row-top padding-row\" style=${styleMap({\n                height: `${topVisibleRow * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n            ${repeat(renderableRows, row => this.#rowIndexMap.get(row), row => {\n                const rowIndex = this.#rowIndexMap.get(row);\n                if (rowIndex === undefined) {\n                    throw new Error('Trying to render a row that has no index in the rowIndexMap');\n                }\n                const tabbableCell = this.#tabbableCell();\n                // Remember that row 0 is considered the header row, so the first tbody row is row 1.\n                const tableRowIndex = rowIndex + 1;\n                // Check for cellUserHasFocused instead of tabbableCell so that we\n                // don't highlight the active cell before they've even clicked it.\n                const rowIsSelected = this.#cellUserHasFocused ? tableRowIndex === this.#cellUserHasFocused[1] : false;\n                const rowClasses = LitHtml.Directives.classMap({\n                    selected: rowIsSelected,\n                    hidden: row.hidden === true,\n                });\n                return html `\n                <tr\n                  aria-rowindex=${rowIndex + 1}\n                  class=${rowClasses}\n                  style=${ifDefined(row.styles ? styleMap(row.styles) : undefined)}\n                  jslog=${VisualLogging.tableRow().track({ keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space' })}\n                  @contextmenu=${this.#onBodyRowContextMenu}\n                  @mouseenter=${() => {\n                    this.dispatchEvent(new RowMouseEnterEvent(row));\n                }}\n                  @mouseleave=${() => {\n                    this.dispatchEvent(new RowMouseLeaveEvent(row));\n                }}\n                >${this.#columns.map((col, columnIndex) => {\n                    const cell = getRowEntryForColumnId(row, col.id);\n                    const cellClasses = classMap({\n                        hidden: !col.visible,\n                        firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                    });\n                    const cellIsFocusableCell = columnIndex === tabbableCell[0] && tableRowIndex === tabbableCell[1];\n                    const cellOutput = col.visible ? renderCellValue(cell) : null;\n                    return html `<td\n                    class=${cellClasses}\n                    jslog=${VisualLogging.tableCell().track({ click: true })}).context(col.id)}\n                    style=${ifDefined(col.styles ? styleMap(col.styles) : undefined)}\n                    tabindex=${cellIsFocusableCell ? '0' : '-1'}\n                    aria-colindex=${columnIndex + 1}\n                    title=${cell.title || getCellTitleFromCellContent(String(cell.value))}\n                    data-row-index=${tableRowIndex}\n                    data-col-index=${columnIndex}\n                    data-grid-value-cell-for-column=${col.id}\n                    @focus=${() => {\n                        this.#focusCellIfRequired([columnIndex, tableRowIndex]);\n                        this.dispatchEvent(new BodyCellFocusedEvent(cell, row));\n                    }}\n                  >${cellOutput}</td>`;\n                })}\n              </tr>`;\n            })}\n            ${this.#renderEmptyFillerRow(renderableRows.length)}\n            <tr class=\"filler-row-bottom padding-row\" style=${styleMap({\n                height: `${Math.max(0, nonHiddenRows.length - bottomVisibleRow) * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n          </tbody>\n        </table>\n      </div>\n      `, this.#shadow, {\n                host: this,\n            });\n        });\n        // clang-format on\n        // This ensures if the user has a cell focused, but then scrolls so that\n        // the focused cell is now not rendered, that when it then gets scrolled\n        // back in, that it becomes rendered.\n        // However, if the cell is a column header, we don't do this, as that\n        // can never be not-rendered.\n        const tabbableCell = this.#tabbableCell();\n        const currentlyFocusedRowIndex = tabbableCell[1];\n        const tabbableCellElement = this.#getTableElementForCellUserHasFocused();\n        if (this.#userHasFocusInDataGrid && currentlyFocusedRowIndex > 0 && tabbableCellElement) {\n            this.#focusTableCellInDOM(tabbableCellElement);\n        }\n        this.#scrollToBottomIfRequired();\n        this.#engageResizeObserver();\n        if (this.#hasRenderedAtLeastOnce) {\n            // We may have had a cell's width change on a re-render, or it may have\n            // been hidden entirely, so we need to ensure that the resize handlers are\n            // re-positioned correctly if so.\n            // We don't have to do this on first render as it will fire when the resize observer is engaged.\n            void this.#alignScrollHandlers();\n        }\n        this.#isRendering = false;\n        this.#hasRenderedAtLeastOnce = true;\n        // If we've received more data mid-render we will do one extra render at\n        // the end with the most recent data.\n        if (this.#scheduleRender) {\n            this.#scheduleRender = false;\n            void this.#render();\n        }\n    }\n}\ncustomElements.define('devtools-data-grid', DataGrid);\n//# sourceMappingURL=DataGrid.js.map","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(\n`/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  display: block;\n  height: 100%;\n  overflow: hidden;\n}\n\n/*# sourceURL=dataGridController.css */\n`);\n\nexport default styles;\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport './DataGrid.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as UI from '../../legacy/legacy.js';\nimport dataGridControllerStyles from './dataGridController.css.js';\nimport { getRowEntryForColumnId, getStringifiedCellValues, } from './DataGridUtils.js';\nconst { html } = LitHtml;\nconst UIStrings = {\n    /**\n     *@description Text announced when the column is sorted in ascending order\n     *@example {title} PH1\n     */\n    sortInAscendingOrder: '{PH1} sorted in ascending order',\n    /**\n     *@description Text announced when the column is sorted in descending order\n     *@example {title} PH1\n     */\n    sortInDescendingOrder: '{PH1} sorted in descending order',\n    /**\n     *@description Text announced when the column sorting canceled\n     *@example {title} PH1\n     */\n    sortingCanceled: '{PH1} sorting canceled',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGridController.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class DataGridController extends HTMLElement {\n    #shadow = this.attachShadow({ mode: 'open' });\n    #hasRenderedAtLeastOnce = false;\n    #columns = [];\n    #rows = [];\n    #contextMenus = undefined;\n    #label = undefined;\n    #showScrollbar = false;\n    #striped = false;\n    /**\n     * Because the controller will sort data in place (e.g. mutate it) when we get\n     * new data in we store the original data separately. This is so we don't\n     * mutate the data we're given, but a copy of the data. If our `get data` is\n     * called, we'll return the original, not the sorted data.\n     */\n    #originalColumns = [];\n    #originalRows = [];\n    #sortState = null;\n    #filters = [];\n    #autoScrollToBottom = true;\n    #paddingRowsCount;\n    connectedCallback() {\n        this.#shadow.adoptedStyleSheets = [dataGridControllerStyles];\n    }\n    get data() {\n        return {\n            columns: this.#originalColumns,\n            rows: this.#originalRows,\n            filters: this.#filters,\n            autoScrollToBottom: this.#autoScrollToBottom,\n            contextMenus: this.#contextMenus,\n            label: this.#label,\n            paddingRowsCount: this.#paddingRowsCount,\n            showScrollbar: this.#showScrollbar,\n            striped: this.#striped,\n        };\n    }\n    set data(data) {\n        this.#originalColumns = data.columns;\n        this.#originalRows = data.rows;\n        this.#contextMenus = data.contextMenus;\n        this.#filters = data.filters || [];\n        this.#contextMenus = data.contextMenus;\n        this.#label = data.label;\n        this.#showScrollbar = data.showScrollbar;\n        this.#striped = data.striped;\n        if (typeof data.autoScrollToBottom === 'boolean') {\n            this.#autoScrollToBottom = data.autoScrollToBottom;\n        }\n        this.#columns = [...this.#originalColumns];\n        this.#rows = this.#cloneAndFilterRows(data.rows, this.#filters);\n        if (!this.#hasRenderedAtLeastOnce && data.initialSort) {\n            this.#sortState = data.initialSort;\n        }\n        if (this.#sortState) {\n            this.#sortRows(this.#sortState);\n        }\n        this.#paddingRowsCount = data.paddingRowsCount;\n        this.#render();\n    }\n    #testRowWithFilter(row, filter, visibleColumnIds) {\n        let rowMatchesFilter = false;\n        const { key, text, negative, regex } = filter;\n        let dataToTest;\n        if (key) {\n            dataToTest = getStringifiedCellValues([getRowEntryForColumnId(row, key)]);\n        }\n        else {\n            dataToTest = getStringifiedCellValues(row.cells.filter(cell => visibleColumnIds.has(cell.columnId)));\n        }\n        if (regex) {\n            rowMatchesFilter = regex.test(dataToTest);\n        }\n        else if (text) {\n            rowMatchesFilter = dataToTest.includes(text.toLowerCase());\n        }\n        // If `negative` is set to `true`, that means we have to flip the final\n        // result, because the filter is matching anything that doesn't match. e.g.\n        // {text: 'foo', negative: false} matches rows that contain the text `foo`\n        // but {text: 'foo', negative: true} matches rows that do NOT contain the\n        // text `foo` so if a filter is marked as negative, we first match against\n        // that filter, and then we flip it here.\n        return negative ? !rowMatchesFilter : rowMatchesFilter;\n    }\n    #cloneAndFilterRows(rows, filters) {\n        if (filters.length === 0) {\n            return [...rows];\n        }\n        const visibleColumnIds = new Set(this.#columns.filter(column => column.visible).map(column => column.id));\n        return rows.map(row => {\n            // We assume that the row should be visible by default.\n            let rowShouldBeVisible = true;\n            for (const filter of filters) {\n                const rowMatchesFilter = this.#testRowWithFilter(row, filter, visibleColumnIds);\n                // If there are multiple filters, if any return false we hide the row.\n                // So if we get a false from testRowWithFilter, we can break early and return false.\n                if (!rowMatchesFilter) {\n                    rowShouldBeVisible = false;\n                    break;\n                }\n            }\n            return {\n                ...row,\n                hidden: !rowShouldBeVisible,\n            };\n        });\n    }\n    #sortRows(state) {\n        const { columnId, direction } = state;\n        this.#rows.sort((row1, row2) => {\n            const cell1 = getRowEntryForColumnId(row1, columnId);\n            const cell2 = getRowEntryForColumnId(row2, columnId);\n            const value1 = typeof cell1.value === 'number' ? cell1.value : String(cell1.value).toUpperCase();\n            const value2 = typeof cell2.value === 'number' ? cell2.value : String(cell2.value).toUpperCase();\n            if (value1 < value2) {\n                return direction === \"ASC\" /* SortDirection.ASC */ ? -1 : 1;\n            }\n            if (value1 > value2) {\n                return direction === \"ASC\" /* SortDirection.ASC */ ? 1 : -1;\n            }\n            return 0;\n        });\n        this.#render();\n    }\n    #onColumnHeaderClick(event) {\n        const { column } = event.data;\n        if (column.sortable) {\n            this.#applySortOnColumn(column);\n        }\n    }\n    #applySortOnColumn(column) {\n        if (this.#sortState && this.#sortState.columnId === column.id) {\n            const { columnId, direction } = this.#sortState;\n            /* When users sort, we go No Sort => ASC => DESC => No sort\n             * So if the current direction is DESC, we clear the state.\n             */\n            if (direction === \"DESC\" /* SortDirection.DESC */) {\n                this.#sortState = null;\n            }\n            else {\n                /* The state is ASC, so toggle to DESC */\n                this.#sortState = {\n                    columnId,\n                    direction: \"DESC\" /* SortDirection.DESC */,\n                };\n            }\n        }\n        else {\n            /* The column wasn't previously sorted, so we sort it in ASC order. */\n            this.#sortState = {\n                columnId: column.id,\n                direction: \"ASC\" /* SortDirection.ASC */,\n            };\n        }\n        const headerName = column.title;\n        if (this.#sortState) {\n            this.#sortRows(this.#sortState);\n            UI.ARIAUtils.alert(this.#sortState.direction === \"ASC\" /* SortDirection.ASC */ ?\n                i18nString(UIStrings.sortInAscendingOrder, { PH1: headerName || '' }) :\n                i18nString(UIStrings.sortInDescendingOrder, { PH1: headerName || '' }));\n        }\n        else {\n            // No sortstate = render the original rows.\n            this.#rows = this.#cloneAndFilterRows(this.#originalRows, this.#filters);\n            this.#render();\n            UI.ARIAUtils.alert(i18nString(UIStrings.sortingCanceled, { PH1: headerName || '' }));\n        }\n    }\n    #onContextMenuColumnSortClick(event) {\n        this.#applySortOnColumn(event.data.column);\n    }\n    #onContextMenuHeaderResetClick() {\n        this.#sortState = null;\n        this.#rows = [...this.#originalRows];\n        this.#render();\n    }\n    #render() {\n        // Disabled until https://crbug.com/1079231 is fixed.\n        // clang-format off\n        LitHtml.render(html `\n      <devtools-data-grid .data=${{\n            columns: this.#columns,\n            rows: this.#rows,\n            activeSort: this.#sortState,\n            contextMenus: this.#contextMenus,\n            label: this.#label,\n            paddingRowsCount: this.#paddingRowsCount,\n            showScrollbar: this.#showScrollbar,\n            striped: this.#striped,\n            autoScrollToBottom: this.#autoScrollToBottom,\n        }}\n        @columnheaderclick=${this.#onColumnHeaderClick}\n        @contextmenucolumnsortclick=${this.#onContextMenuColumnSortClick}\n        @contextmenuheaderresetclick=${this.#onContextMenuHeaderResetClick}\n     ></devtools-data-grid>\n    `, this.#shadow, {\n            host: this,\n        });\n        // clang-format on\n        this.#hasRenderedAtLeastOnce = true;\n    }\n}\ncustomElements.define('devtools-data-grid-controller', DataGridController);\n//# sourceMappingURL=DataGridController.js.map"],"names":["styles","ColumnHeaderClickEvent","column","columnIndex","ContextMenuColumnSortClickEvent","ContextMenuHeaderResetClickEvent","BodyCellFocusedEvent","cell","row","RowMouseEnterEvent","RowMouseLeaveEvent","toggleColumnVisibility","dataGrid","newVisibility","newColumns","col","addColumnVisibilityCheckboxes","contextMenu","columns","addSortableColumnItems","sortableColumns","html","LitHtml","primitiveRenderer","value","codeBlockRenderer","LitHtml.nothing","stringValue","iconRenderer","icon","getStringifiedCellValues","cells","IconButton.Icon.Icon","getRowEntryForColumnId","id","rowEntry","r","renderCellValue","DataGridRenderers.primitiveRenderer","calculateColumnWidthPercentageFromWeighting","allColumns","columnId","totalWeights","c","sumOfWeights","matchingColumn","handleArrowKeyNavigation","options","key","currentFocusedCell","rows","selectedColIndex","selectedRowIndex","firstVisibleColumnIndex","nextColIndex","i","minRowIndex","rowIndexToMoveTo","firstVisibleBodyRowIndex","Platform.assertNever","calculateFirstFocusableCell","focusableRowIndex","getCellTitleFromCellContent","text","coordinator","Coordinator.RenderCoordinator.RenderCoordinator","ifDefined","classMap","styleMap","repeat","UIStrings","str_","i18n.i18n.registerUIStrings","i18nString","i18n.i18n.getLocalizedString","KEYS_TREATED_AS_CLICKS","ROW_HEIGHT_PIXELS","DataGrid","#shadow","#columns","#rows","#sortState","#isRendering","#userScrollState","#contextMenus","#label","#paddingRowsCount","#showScrollbar","#striped","#autoScrollToBottom","#currentResize","#rowIndexMap","#resizeObserver","#alignScrollHandlers","#boundOnResizePointerMove","#onResizePointerMove","#cellToFocusIfUserTabsIn","#cellUserHasFocused","#hasRenderedAtLeastOnce","#userHasFocusInDataGrid","#scheduleRender","dataGridStyles","#render","data","index","#userHasCellFocused","#tabbableCell","columnOutOfBounds","rowOutOfBounds","#shouldAutoScrollToBottom","#scrollToBottomIfRequired","wrapper","scrollHeight","#engageResizeObserver","#getTableElementForCellUserHasFocused","rowIndex","#focusTableCellInDOM","#focusCellIfRequired","newColumnIndex","newRowIndex","tableCell","localizedSortState","#getLocalizedSortState","UI.ARIAUtils.alert","#ariaSortForHeader","#onTableKeyDown","event","focusedColumnIndex","focusedRowIndex","activeColumn","#onColumnHeaderClick","Platform.KeyboardUtilities.keyIsArrowKey","nextFocusedCell","#renderEmptyFillerRow","numberOfVisibleRows","emptyCells","colIndex","emptyCellClasses","LitHtml.Directives.classMap","emptyRowClasses","#cleanUpAfterResizeColumnComplete","#onResizePointerDown","Host.Platform.isMac","resizerElement","leftColumnIndex","leftColumnIndexAsNumber","rightColumnIndexAsNumber","leftCell","rightCell","leftCellCol","rightCellCol","targetDocumentForCursorChange","MIN_CELL_WIDTH_PERCENTAGE","MAX_CELL_WIDTH_PERCENTAGE","deltaOfMouseMove","percentageDelta","newLeftColumnPercentage","newRightColumnPercentage","Platform.NumberUtilities.clamp","#onResizePointerUp","resizer","#renderResizeForCell","position","lastVisibleColumnIndex","#getIndexOfLastVisibleColumn","#onHeaderContextMenu","menu","UI.ContextMenu.ContextMenu","sortMenu","#onBodyRowContextMenu","rowIndexAttribute","rowThatWasClicked","headerOptionsMenu","#onScroll","userIsAtBottom","columnHeaders","handlers","header","columnWidth","columnLeftOffset","handlerWidth","#calculateTopAndBottomRowIndexes","scrollTop","clientHeight","padding","topVisibleRow","bottomVisibleRow","#onFocusOut","nonHiddenRows","renderableRows","_","idx","indexOfFirstVisibleColumn","anyColumnsSortable","containerClassMap","LitHtml.render","style","thClasses","tabbableCell","cellIsFocusableCell","VisualLogging.tableHeader","tableRowIndex","rowIsSelected","rowClasses","VisualLogging.tableRow","cellClasses","cellOutput","VisualLogging.tableCell","currentlyFocusedRowIndex","tabbableCellElement","DataGridController","#originalColumns","#originalRows","#filters","dataGridControllerStyles","#cloneAndFilterRows","#sortRows","#testRowWithFilter","filter","visibleColumnIds","rowMatchesFilter","negative","regex","dataToTest","filters","rowShouldBeVisible","state","direction","row1","row2","cell1","cell2","value1","value2","#applySortOnColumn","headerName","#onContextMenuColumnSortClick","#onContextMenuHeaderResetClick"],"mappings":"kLAKA,MAAMA,EAAS,IAAI,cACnBA,EAAO,YACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CA8LC,ECrMM,MAAMC,UAA+B,KAAM,CAC9C,OAAO,UAAY,oBACnB,KACA,YAAYC,EAAQC,EAAa,CAC7B,MAAMF,EAAuB,SAAS,EACtC,KAAK,KAAO,CACR,OAAAC,EACA,YAAAC,CACZ,CACK,CACL,CACO,MAAMC,UAAwC,KAAM,CACvD,OAAO,UAAY,6BACnB,KACA,YAAYF,EAAQ,CAChB,MAAME,EAAgC,SAAS,EAC/C,KAAK,KAAO,CACR,OAAAF,CACZ,CACK,CACL,CACO,MAAMG,UAAyC,KAAM,CACxD,OAAO,UAAY,8BACnB,aAAc,CACV,MAAMA,EAAiC,SAAS,CACnD,CACL,CAaO,MAAMC,UAA6B,KAAM,CAC5C,OAAO,UAAY,cAOnB,KACA,YAAYC,EAAMC,EAAK,CACnB,MAAMF,EAAqB,UAAW,CAClC,SAAU,EACtB,CAAS,EACD,KAAK,KAAO,CACR,KAAAC,EACA,IAAAC,CACZ,CACK,CACL,CACO,MAAMC,UAA2B,KAAM,CAC1C,OAAO,UAAY,gBACnB,KACA,YAAYD,EAAK,CACb,MAAMC,EAAmB,UAAW,CAChC,SAAU,EACtB,CAAS,EACD,KAAK,KAAO,CACR,IAAAD,CACZ,CACK,CACL,CACO,MAAME,UAA2B,KAAM,CAC1C,OAAO,UAAY,gBACnB,KACA,YAAYF,EAAK,CACb,MAAME,EAAmB,UAAW,CAChC,SAAU,EACtB,CAAS,EACD,KAAK,KAAO,CACR,IAAAF,CACZ,CACK,CACL,CChFA,SAASG,GAAuBC,EAAUV,EAAQ,CAC9C,MAAMW,EAAgB,CAACX,EAAO,QACxBY,EAAaF,EAAS,KAAK,QAAQ,IAAIG,IACrCA,IAAQb,IACRa,EAAI,QAAUF,GAEXE,EACV,EACDH,EAAS,KAAO,CACZ,GAAGA,EAAS,KACZ,QAASE,CACjB,CACA,CAOO,SAASE,EAA8BJ,EAAUK,EAAa,CACjE,KAAM,CAAE,QAAAC,CAAO,EAAKN,EAAS,KAC7B,UAAWV,KAAUgB,EACZhB,EAAO,UAQZe,EAAY,eAAgB,EAAC,mBAAmBf,EAAO,MAAO,IAAM,CAChES,GAAuBC,EAAUV,CAAM,CACnD,EAAW,CAAE,QAASA,EAAO,QAAS,aAAcA,EAAO,EAAE,CAAE,CAE/D,CASO,SAASiB,EAAuBP,EAAUK,EAAa,CAC1D,MAAMG,EAAkBR,EAAS,KAAK,QAAQ,OAAOG,GAAOA,EAAI,WAAa,EAAI,EACjF,GAAIK,EAAgB,OAAS,EACzB,UAAWlB,KAAUkB,EACjBH,EAAY,eAAgB,EAAC,WAAWf,EAAO,MAAO,IAAM,CACxDU,EAAS,cAAc,IAAIR,EAAgCF,CAAM,CAAC,CACrE,EAAE,CAAE,aAAcA,EAAO,EAAI,CAAA,CAG1C,CCjDA,KAAM,CAAEmB,KAAAA,CAAM,EAAGC,EACJC,GAAqBC,GACvBH,IAAQG,CAAK,GAEXC,GAAqBD,GAAU,CACxC,GAAI,CAACA,EACD,OAAOE,EAEX,MAAMC,EAAc,OAAOH,CAAK,EAChC,OAAOH,UAAcM,CAAW,SACpC,EACaC,GAAgBC,GACpBA,EAGER,yDAA6DQ,CAAI,SAF7DH,ECXR,SAASI,EAAyBC,EAAO,CAC5C,OAAO,KACF,UAAUA,EAAM,IAAIxB,GACjBA,EAAK,iBAAiByB,GACf,KAEJzB,EAAK,KACf,CAAC,EACG,aACT,CACO,SAAS0B,EAAuBzB,EAAK0B,EAAI,CAC5C,MAAMC,EAAW3B,EAAI,MAAM,KAAK4B,GAAKA,EAAE,WAAaF,CAAE,EACtD,GAAIC,IAAa,OACb,MAAM,IAAI,MAAM,oDAAoDD,CAAE,GAAG,EAE7E,OAAOC,CACX,CACO,SAASE,GAAgB9B,EAAM,CAClC,OAAIA,EAAK,SACEA,EAAK,SAASA,EAAK,KAAK,EAE5B+B,GAAoC/B,EAAK,KAAK,CACzD,CAuBO,SAASgC,GAA4CC,EAAYC,EAAU,CAC9E,MAAMC,EAAeF,EAAW,OAAOG,GAAKA,EAAE,OAAO,EAAE,OAAO,CAACC,EAAc7B,IAAQ6B,EAAe7B,EAAI,eAAgB,CAAC,EACnH8B,EAAiBL,EAAW,KAAKG,GAAKA,EAAE,KAAOF,CAAQ,EAC7D,GAAI,CAACI,EACD,MAAM,IAAI,MAAM,iCAAiCJ,CAAQ,EAAE,EAE/D,GAAII,EAAe,eAAiB,EAChC,MAAM,IAAI,MAAM,qBAAqBJ,CAAQ,kCAAkC,EAEnF,OAAKI,EAAe,QAGb,KAAK,MAAOA,EAAe,eAAiBH,EAAgB,GAAG,EAF3D,CAGf,CACO,SAASI,GAAyBC,EAAS,CAC9C,KAAM,CAAE,IAAAC,EAAK,mBAAAC,EAAoB,QAAA/B,EAAS,KAAAgC,CAAI,EAAKH,EAC7C,CAACI,EAAkBC,CAAgB,EAAIH,EAC7C,OAAQD,EAAG,CACP,IAAK,YAA4D,CAC7D,MAAMK,EAA0BnC,EAAQ,UAAUyB,GAAKA,EAAE,OAAO,EAChE,GAAIQ,IAAqBE,EAErB,MAAO,CAACF,EAAkBC,CAAgB,EAM9C,IAAIE,EAAeH,EACnB,QAASI,EAAID,EAAe,EAAGC,GAAK,EAAGA,IAEnC,GADYrC,EAAQqC,CAAC,EACb,QAAS,CACbD,EAAeC,EACf,KACH,CAEL,MAAO,CAACD,EAAcF,CAAgB,CACzC,CACD,IAAK,aAA8D,CAK/D,IAAIE,EAAeH,EACnB,QAASI,EAAID,EAAe,EAAGC,EAAIrC,EAAQ,OAAQqC,IAE/C,GADYrC,EAAQqC,CAAC,EACb,QAAS,CACbD,EAAeC,EACf,KACH,CAEL,MAAO,CAACD,EAAcF,CAAgB,CACzC,CACD,IAAK,UAAwD,CAEzD,MAAMI,EADkBtC,EAAQ,KAAKH,GAAOA,EAAI,WAAa,EAAI,EAC3B,EAAI,EAC1C,GAAIqC,IAAqBI,EAIrB,MAAO,CAACL,EAAkBC,CAAgB,EAE9C,IAAIK,EAAmBL,EACvB,QAASG,EAAIH,EAAmB,EAAGG,GAAKC,EAAaD,IAAK,CAGtD,GAAIA,IAAM,EAAG,CACTE,EAAmB,EACnB,KACH,CAED,GAAI,CADgBP,EAAKK,EAAI,CAAC,EACb,OAAQ,CACrBE,EAAmBF,EACnB,KACH,CACJ,CACD,MAAO,CAACJ,EAAkBM,CAAgB,CAC7C,CACD,IAAK,YAA4D,CAC7D,GAAIL,IAAqB,EAAG,CAExB,MAAMM,EAA2BR,EAAK,UAAU1C,GAAO,CAACA,EAAI,MAAM,EAClE,OAAIkD,EAA2B,GACpB,CAACP,EAAkBO,EAA2B,CAAC,EAGnD,CAACP,EAAkBC,CAAgB,CAC7C,CACD,IAAIK,EAAmBL,EAEvB,QAASG,EAAIE,EAAmB,EAAGF,EAAIL,EAAK,OAAS,EAAGK,IAEpD,GAAI,CADgBL,EAAKK,EAAI,CAAC,EACb,OAAQ,CACrBE,EAAmBF,EACnB,KACH,CAEL,MAAO,CAACJ,EAAkBM,CAAgB,CAC7C,CACD,QACI,OAAOE,GAAqBX,EAAK,sBAAsBA,CAAG,EAAE,CACnE,CACL,CACO,MAAMY,GAA+Bb,GAAY,CACpD,KAAM,CAAE,QAAA7B,EAAS,KAAAgC,CAAM,EAAGH,EAEpBc,EADsB3C,EAAQ,KAAKH,GAAOA,EAAI,WAAa,EAAI,EACrB,EAAImC,EAAK,UAAU1C,GAAO,CAACA,EAAI,MAAM,EAAI,EAEzF,MAAO,CADmBU,EAAQ,UAAUH,GAAOA,EAAI,OAAO,EACnC8C,CAAiB,CAChD,EACaC,GAA+BC,GAASA,EAAK,OAAS,GAAKA,EAAOA,EAAK,OAAO,EAAG,EAAE,EAAI,ICtJ9FC,EAAcC,GAAgD,WAI9D,MAAE5C,EAAM,WAAY,CAAE,UAAA6C,EAAW,SAAAC,EAAU,SAAAC,EAAU,OAAAC,GAAU,EAAG/C,EAClEgD,EAAY,CAId,OAAQ,UAIR,aAAc,gBAId,cAAe,iBAKf,YAAa,gEAIb,QAAS,YAIT,SAAU,aAIV,SAAU,MACd,EACMC,GAAOC,EAA4B,sCAAuCF,CAAS,EACnFG,EAAaC,EAA6B,KAAK,OAAWH,EAAI,EAC9DI,GAAyB,IAAI,IAAI,CAAC,IAAK,OAAO,CAAC,EAC/CC,EAAoB,GACnB,MAAMC,WAAiB,WAAY,CACtCC,GAAU,KAAK,aAAa,CAAE,KAAM,MAAQ,CAAA,EAC5CC,GAAW,CAAA,EACXC,GAAQ,CAAA,EACRC,GAAa,KACbC,GAAe,GACfC,GAAmB,eACnBC,GAAgB,OAChBC,GAAS,OACTC,GAAoB,GACpBC,GAAiB,GACjBC,GAAW,GACXC,GAAsB,GACtBC,GAAiB,KAKjBC,GAAe,IAAI,QACnBC,GAAkB,IAAI,eAAe,IAAM,CAClC,KAAKC,IAClB,CAAK,EAGDC,GAA4B,KAAKC,GAAqB,KAAK,IAAI,EAe/DC,GAA2B,CAAC,EAAG,CAAC,EAChCC,GAAsB,KACtBC,GAA0B,GAC1BC,GAA0B,GAC1BC,GAAkB,GAClB,mBAAoB,CAChB,KAAKtB,GAAQ,mBAAqB,CAACuB,CAAc,EACjD,KAAK,MAAM,YAAY,qBAAsB,GAAGzB,CAAiB,IAAI,EAChE,KAAK0B,IACb,CACD,IAAI,MAAO,CACP,MAAO,CACH,QAAS,KAAKvB,GACd,KAAM,KAAKC,GACX,WAAY,KAAKC,GACjB,aAAc,KAAKG,GACnB,mBAAoB,KAAKK,GACzB,MAAO,KAAKJ,GACZ,iBAAkB,KAAKC,GACvB,cAAe,KAAKC,GACpB,QAAS,KAAKC,EAC1B,CACK,CACD,IAAI,KAAKe,EAAM,CAmCX,GAlCA,KAAKxB,GAAWwB,EAAK,QACrB,KAAKvB,GAAQuB,EAAK,KAClB,KAAKvB,GAAM,QAAQ,CAACxE,EAAKgG,IAAU,CAC/B,KAAKb,GAAa,IAAInF,EAAKgG,CAAK,CAC5C,CAAS,EACD,KAAKvB,GAAasB,EAAK,WACvB,KAAKnB,GAAgBmB,EAAK,aAC1B,KAAKlB,GAASkB,EAAK,MACnB,KAAKhB,GAAiBgB,EAAK,cAC3B,KAAKf,GAAWe,EAAK,QACjB,OAAOA,EAAK,oBAAuB,YACnC,KAAKd,GAAsBc,EAAK,oBAiB/B,KAAKL,KACN,KAAKF,GAA2BpC,GAA4B,CAAE,QAAS,KAAKmB,GAAU,KAAM,KAAKC,EAAK,CAAE,GAExGuB,EAAK,mBAAqB,SAC1B,KAAKjB,GAAoBiB,EAAK,kBAE9B,KAAKL,IAA2B,KAAKO,GAAmB,EAAI,CAC5D,KAAM,CAACtD,EAAkBC,CAAgB,EAAI,KAAKsD,GAAa,EACzDC,EAAoBxD,EAAmB,KAAK4B,GAAS,OACrD6B,EAAiBxD,EAAmB,KAAK4B,GAAM,QAIjD2B,GAAqBC,KACrB,KAAKX,GAAsB,CACvBU,EAAoB,KAAK5B,GAAS,OAAS5B,EAC3CyD,EAAiB,KAAK5B,GAAM,OAAS5B,CACzD,EAES,CACI,KAAKkD,IACb,CACDO,IAA4B,CACxB,OAAK,KAAKpB,GAON,KAAKN,KAAqB,sBAQ1B,CAAC,KAAKgB,IAA2B,KAAKhB,KAAqB,2BAdpD,EAsBd,CACD2B,IAA4B,CACxB,GAAI,KAAKZ,KAA4B,IAAS,CAAC,KAAKW,GAAyB,EACzE,OAEJ,MAAME,EAAU,KAAKjC,GAAQ,cAAc,qBAAqB,EAC3DiC,GAGA/C,EAAY,OAAO,IAAM,CAC1B,MAAMgD,EAAeD,EAAQ,aAC7BA,EAAQ,SAAS,EAAGC,CAAY,CAC5C,CAAS,CACJ,CACDC,IAAwB,CACf,KAAKf,IACN,KAAKN,GAAgB,QAAQ,KAAKd,GAAQ,IAAI,CAErD,CACD2B,IAAsB,CAClB,OAAO,KAAKR,KAAwB,IACvC,CACDiB,IAAwC,CACpC,GAAI,CAAC,KAAKjB,GACN,OAAO,KAEX,KAAM,CAAC9F,EAAagH,CAAQ,EAAI,KAAKlB,GAErC,OADa,KAAKnB,GAAQ,cAAc,oBAAoBqC,CAAQ,sBAAsBhH,CAAW,IAAI,CAE5G,CACDiH,GAAqB7G,EAAM,CACvBA,EAAK,MAAK,CACb,CACD8G,GAAqB,CAACC,EAAgBC,CAAW,EAAG,CAEhD,GADA,KAAKpB,GAA0B,GAC3B,KAAKF,IAAuB,KAAKA,GAAoB,CAAC,IAAMqB,GAC5D,KAAKrB,GAAoB,CAAC,IAAMsB,EAEhC,OAEJ,KAAKtB,GAAsB,CAACqB,EAAgBC,CAAW,EAClD,KAAKjB,KACV,MAAMkB,EAAY,KAAKN,KACvB,GAAKM,IAQL,KAAKJ,GAAqBI,CAAS,EAE/BD,IAAgB,GAAK,KAAKxC,GAASuC,CAAc,EAAE,UAAU,CAC7D,MAAMG,EAAqB,KAAKC,GAAuB,KAAK3C,GAASuC,CAAc,CAAC,EACpFK,EAAmBlD,EAAWH,EAAU,YAAa,CAAE,IAAKmD,GAAsB,EAAI,CAAA,CAAC,CAC1F,CACJ,CACDC,GAAuB3G,EAAK,CAExB,OADyB,KAAK6G,GAAmB7G,CAAG,EAC5B,CACpB,IAAK,YACD,OAAOuD,EAAU,QACrB,IAAK,aACD,OAAOA,EAAU,SACrB,IAAK,OACD,OAAOA,EAAU,QACxB,CAEJ,CACDuD,GAAgBC,EAAO,CACnB,MAAM9E,EAAM8E,EAAM,IAClB,GAAI,CAAC,KAAK7B,GACN,OAEJ,GAAItB,GAAuB,IAAI3B,CAAG,EAAG,CACjC,KAAM,CAAC+E,EAAoBC,CAAe,EAAI,KAAK/B,GAC7CgC,EAAe,KAAKlD,GAASgD,CAAkB,EACjDC,IAAoB,GAAKC,GAAgBA,EAAa,UACtD,KAAKC,GAAqBD,EAAcF,CAAkB,CAEjE,CACD,GAAI,CAACI,GAAyCnF,CAAG,EAC7C,OAEJ,MAAMoF,EAAkBtF,GAAyB,CAC7C,IAAAE,EACA,mBAAoB,KAAKiD,GACzB,QAAS,KAAKlB,GACd,KAAM,KAAKC,EACvB,CAAS,EACD8C,EAAM,eAAc,EACpB,KAAKT,GAAqBe,CAAe,CAC5C,CACDF,GAAqBnH,EAAKyF,EAAO,CAC7B,KAAK,cAAc,IAAIvG,EAAuBc,EAAKyF,CAAK,CAAC,CAC5D,CAMDoB,GAAmB7G,EAAK,CACpB,GAAIA,EAAI,WAAa,CAAC,KAAKkE,IAAc,KAAKA,GAAW,WAAalE,EAAI,IAEtE,MAAO,OAEX,GAAI,KAAKkE,IAAc,KAAKA,GAAW,WAAalE,EAAI,GACpD,OAAO,KAAKkE,GAAW,YAAc,MAAgC,YAAc,YAI1F,CACDoD,GAAsBC,EAAqB,CACvC,MAAMC,EAAa,KAAKxD,GAAS,IAAI,CAAChE,EAAKyH,IAAa,CACpD,GAAI,CAACzH,EAAI,QACL,OAAOW,EAEX,MAAM+G,EAAmBC,EAA4B,CACjD,mBAAoBF,IAAa,CACjD,CAAa,EACD,OAAOnH,iCAAqCoH,CAAgB,iCAAiCD,CAAQ,QACjH,CAAS,EACKG,EAAkBD,EAA4B,CAChD,aAAc,GACd,cAAe,GACf,cAAeJ,IAAwB,CACnD,CAAS,EACD,OAAOjH,iCAAqCsH,CAAe,IAAIJ,CAAU,OAC5E,CACDK,IAAoC,CAC3B,KAAKlD,KAGV,KAAKA,GAAe,wBAAwB,KAAK,MAAM,OAAS,KAAKA,GAAe,gBACpF,KAAKA,GAAiB,KAEjB,KAAKG,KACb,CACDgD,GAAqBf,EAAO,CACxB,GAAIA,EAAM,UAAY,GAAMgB,GAAmB,GAAMhB,EAAM,QAGvD,OAEJA,EAAM,eAAc,EACpB,MAAMiB,EAAiBjB,EAAM,OAC7B,GAAI,CAACiB,EACD,OAEJ,MAAMC,EAAkBD,EAAe,QAAQ,YAC/C,GAAI,CAACC,EACD,OAEJ,MAAMC,EAA0B,WAAW,SAASD,EAAiB,EAAE,EAIjEE,EAA2B,KAAKnE,GAAS,UAAU,CAAC7E,EAAQsG,IACvDA,EAAQyC,GAA2B/I,EAAO,UAAY,EAChE,EACKiJ,EAAW,KAAKrE,GAAQ,cAAc,oCAAoCmE,CAAuB,IAAI,EACrGG,EAAY,KAAKtE,GAAQ,cAAc,oCAAoCoE,CAAwB,IAAI,EAC7G,GAAI,CAACC,GAAY,CAACC,EACd,OAGJ,MAAMC,EAAc,KAAKvE,GAAQ,cAAc,8BAA8BmE,CAAuB,IAAI,EAClGK,EAAe,KAAKxE,GAAQ,cAAc,8BAA8BoE,CAAwB,IAAI,EAC1G,GAAI,CAACG,GAAe,CAACC,EACjB,OAEJ,MAAMC,EAAgCzB,EAAM,OAAO,cAC9CyB,IAIL,KAAK7D,GAAiB,CAClB,YAAA2D,EACA,aAAAC,EACA,kCAAmC,WAAW,SAASD,EAAY,MAAM,MAAO,EAAE,EAClF,mCAAoC,WAAW,SAASC,EAAa,MAAM,MAAO,EAAE,EACpF,qBAAsBH,EAAS,YAC/B,sBAAuBC,EAAU,YACjC,cAAetB,EAAM,EACrB,wBAAyByB,EACzB,gBAAiBR,EAAe,MAAM,MAClD,EACQQ,EAA8B,KAAK,MAAM,OAAS,aAClDR,EAAe,kBAAkBjB,EAAM,SAAS,EAChDiB,EAAe,iBAAiB,cAAe,KAAKjD,EAAyB,EAChF,CACDC,GAAqB+B,EAAO,CAExB,GADAA,EAAM,eAAc,EAChB,CAAC,KAAKpC,GACN,OAEJ,MAAM8D,EAA4B,GAC5BC,EAA6B,KAAK/D,GAAe,kCACnD,KAAKA,GAAe,mCACpB8D,EACEE,EAAmB5B,EAAM,EAAI,KAAKpC,GAAe,cAEjDiE,EADgB,KAAK,IAAID,CAAgB,GACL,KAAKhE,GAAe,qBAAuB,KAAKA,GAAe,uBAA0B,IACnI,IAAIkE,EACAC,EACAH,EAAmB,GAKnBE,EAA0BE,EAA+B,KAAKpE,GAAe,kCAAoCiE,EAAiBH,EAA2BC,CAAyB,EACtLI,EAA2BC,EAA+B,KAAKpE,GAAe,mCAAqCiE,EAAiBH,EAA2BC,CAAyB,GAEnLC,EAAmB,IAMxBE,EAA0BE,EAA+B,KAAKpE,GAAe,kCAAoCiE,EAAiBH,EAA2BC,CAAyB,EACtLI,EAA2BC,EAA+B,KAAKpE,GAAe,mCAAqCiE,EAAiBH,EAA2BC,CAAyB,GAExL,GAACG,GAA2B,CAACC,KAOjC,KAAKnE,GAAe,YAAY,MAAM,MAAQkE,EAAwB,QAAQ,CAAC,EAAI,IACnF,KAAKlE,GAAe,aAAa,MAAM,MAAQmE,EAAyB,QAAQ,CAAC,EAAI,IACxF,CACDE,GAAmBjC,EAAO,CACtBA,EAAM,eAAc,EACpB,MAAMkC,EAAUlC,EAAM,OACjBkC,IAGLA,EAAQ,sBAAsBlC,EAAM,SAAS,EAC7CkC,EAAQ,oBAAoB,cAAe,KAAKlE,EAAyB,EACzE,KAAK8C,GAAiC,EACzC,CACDqB,GAAqB/J,EAAQgK,EAAU,CAQnC,KAAM,CAAC/J,CAAW,EAAI+J,EAChBC,EAAyB,KAAKC,KAEpC,OAAIjK,IAAgBgK,GAA0B,CAACjK,EAAO,QAC3CwB,EAEJL;AAAAA,oBACK,KAAKwH,EAAoB;AAAA,kBAC3B,KAAKkB,EAAkB;AAAA,yBAChB5J,CAAW;AAAA,aAE/B,CACDiK,IAA+B,CAC3B,IAAI5D,EAAQ,KAAKzB,GAAS,OAAS,EACnC,KAAOyB,EAAQ,IAEP,CADQ,KAAKzB,GAASyB,CAAK,EACvB,QAFOA,IAEf,CAIJ,OAAOA,CACV,CAKD6D,GAAqBvC,EAAO,CACxB,GAAIA,EAAM,SAAW,GAAKA,EAAM,SAAW,GAIvC,OAEJ,MAAMwC,EAAO,IAAIC,EAA2BzC,CAAK,EACjD9G,EAA8B,KAAMsJ,CAAI,EACxC,MAAME,EAAWF,EAAK,eAAc,EAAG,kBAAkB7F,EAAWH,EAAU,MAAM,EAAG,GAAO,SAAS,EACvGnD,EAAuB,KAAMqJ,CAAQ,EACrCF,EAAK,eAAc,EAAG,WAAW7F,EAAWH,EAAU,YAAY,EAAG,IAAM,CACvE,KAAK,cAAc,IAAIjE,CAAkC,CACrE,EAAW,CAAE,aAAc,eAAe,CAAE,EAChC,KAAK+E,IAAiB,KAAKA,GAAc,WAEzC,KAAKA,GAAc,UAAUkF,EAAM,KAAKvF,EAAQ,EAE/CuF,EAAK,MACb,CACDG,GAAsB3C,EAAO,CAWzB,GAVIA,EAAM,SAAW,GAAKA,EAAM,SAAW,IAUvC,CAACA,EAAM,QAAU,EAAEA,EAAM,kBAAkB,aAC3C,OAEJ,MAAM4C,EAAoB5C,EAAM,OAAO,QAAQ,SAC/C,GAAI,CAAC4C,EACD,OAEJ,MAAMvD,EAAW,SAASuD,EAAmB,EAAE,EAEzCC,EAAoB,KAAK3F,GAAMmC,EAAW,CAAC,EAC3CmD,EAAO,IAAIC,EAA2BzC,CAAK,EAC3C0C,EAAWF,EAAK,eAAc,EAAG,kBAAkB7F,EAAWH,EAAU,MAAM,EAAG,GAAO,SAAS,EACvGnD,EAAuB,KAAMqJ,CAAQ,EACrC,MAAMI,EAAoBN,EAAK,eAAc,EAAG,kBAAkB7F,EAAWH,EAAU,aAAa,EAAG,GAAO,gBAAgB,EAC9HtD,EAA8B,KAAM4J,CAAiB,EACrDA,EAAkB,eAAc,EAAG,WAAWnG,EAAWH,EAAU,YAAY,EAAG,IAAM,CACpF,KAAK,cAAc,IAAIjE,CAAkC,CACrE,EAAW,CAAE,aAAc,eAAe,CAAE,EAChC,KAAK+E,IAAiB,KAAKA,GAAc,SACzC,KAAKA,GAAc,QAAQkF,EAAM,KAAKvF,GAAU4F,EAAmB,KAAK3F,EAAK,EAE5EsF,EAAK,MACb,CACDO,GAAU/C,EAAO,CACb,MAAMf,EAAUe,EAAM,OACtB,GAAI,CAACf,EACD,OAIJ,MAAM+D,EAAiB,KAAK,MAAM/D,EAAQ,UAAYA,EAAQ,YAAY,IAAM,KAAK,MAAMA,EAAQ,YAAY,EAC/G,KAAK5B,GACD2F,EAAiB,qBAAgE,2BAChF,KAAKxE,IACb,CACDT,IAAuB,CACnB,OAAO7B,EAAY,KAAK,IAAM,CAC1B,MAAM+G,EAAgB,KAAKjG,GAAQ,iBAAiB,iBAAiB,EAC/DkG,EAAW,KAAKlG,GAAQ,iBAAiB,qBAAqB,EACtD,KAAKA,GAAQ,cAAc,OAAO,GAIhDiG,EAAc,QAAQ,MAAOE,EAAQzE,IAAU,CAC3C,MAAM0E,EAAcD,EAAO,YACrBE,EAAmBF,EAAO,WAChC,GAAID,EAASxE,CAAK,EAAG,CACjB,MAAM4E,EAAeJ,EAASxE,CAAK,EAAE,YAChCxC,EAAY,MAAM,IAAM,CAKzBgH,EAASxE,CAAK,EAAE,MAAM,KAAO,GAAG2E,EAAmBD,EAAcE,CAAY,IACrG,CAAqB,CACJ,CACjB,CAAa,CACb,CAAS,CACJ,CAKDC,IAAmC,CAC/B,OAAOrH,EAAY,KAAK,IAAM,CAC1B,MAAM+C,EAAU,KAAKjC,GAAQ,cAAc,qBAAqB,EAKhE,IAAIwG,EAAY,EACZC,EAAe,OAAO,YACtBxE,IACAuE,EAAYvE,EAAQ,UACpBwE,EAAexE,EAAQ,cAE3B,MAAMyE,EAAU5G,EAAoB,KAAKU,GACzC,IAAImG,EAAgB,KAAK,OAAOH,EAAYE,GAAW5G,CAAiB,EACpE8G,EAAmB,KAAK,MAAMJ,EAAYC,EAAeC,GAAW5G,CAAiB,EACzF,OAAA6G,EAAgB,KAAK,IAAI,EAAGA,CAAa,EACzCC,EAAmB,KAAK,IAAI,KAAK1G,GAAM,OAAO5C,GAAK,CAACA,EAAE,MAAM,EAAE,OAAQsJ,CAAgB,EAC/E,CACH,cAAAD,EACA,iBAAAC,CAChB,CACA,CAAS,CACJ,CACDC,IAAc,CAUV,KAAKxF,GAA0B,EAClC,CACDO,IAAgB,CAOZ,OAAO,KAAKT,IAAuB,KAAKD,EAC3C,CAQD,KAAMM,IAAU,CACZ,GAAI,CAAC,KAAK,YACN,OAEJ,GAAI,KAAKpB,GAAc,CAKnB,KAAKkB,GAAkB,GACvB,MACH,CACD,KAAKlB,GAAe,GACpB,KAAM,CAAE,cAAAuG,EAAe,iBAAAC,CAAgB,EAAK,MAAM,KAAKL,GAAgC,EACjFO,EAAgB,KAAK5G,GAAM,OAAOxE,GAAO,CAACA,EAAI,MAAM,EACpDqL,EAAiBD,EAAc,OAAO,CAACE,EAAGC,IAAQA,GAAON,GAAiBM,GAAOL,CAAgB,EACjGM,EAA4B,KAAKjH,GAAS,UAAUhE,GAAOA,EAAI,OAAO,EACtEkL,EAAqB,KAAKlH,GAAS,KAAKhE,GAAOA,EAAI,WAAa,EAAI,EACpEmL,EAAoB,CACtB,qBAAsB,GACtB,iBAAkB,KAAK3G,KAAmB,GAC1C,QAAS,KAAKC,KAAa,EACvC,EACQ,MAAMxB,EAAY,MAAM,IAAM,CAG1BmI,EAAe9K;AAAAA,QACnB,KAAK0D,GAAS,IAAI,CAAChE,EAAKZ,IAOT,KAAK8J,GAAqBlJ,EAAK,CAACZ,EAAa,CAAC,CAAC,CACzD,CAAC;AAAA,mBACKgE,EAAS+H,CAAiB,CAAC,YAAY,KAAKrB,EAAS,cAAc,KAAKc,EAAW;AAAA;AAAA,uBAE/EzH,EAAU,KAAKmB,EAAM,CAAC;AAAA,0BACnB,KAAKL,GAAM,MAAM;AAAA,0BACjB,KAAKD,GAAS,MAAM;AAAA,qBACzB,KAAK8C,EAAe;AAAA;AAAA;AAAA;AAAA,cAI3B,KAAK9C,GAAS,IAAI,CAAChE,EAAKyH,IAAa,CAEnC,MAAM4D,EAAQ,UADA7J,GAA4C,KAAKwC,GAAUhE,EAAI,EAAE,CAClD,IAC7B,OAAKA,EAAI,QAGFM,eAAmB+K,CAAK,0BAA0B5D,CAAQ,IAFtD9G,CAG3B,CAAa,CAAC;AAAA;AAAA;AAAA,+BAGiB,KAAK2I,EAAoB;AAAA,gBACxC,KAAKtF,GAAS,IAAI,CAAChE,EAAKZ,IAAgB,CACxC,MAAMkM,EAAYlI,EAAS,CACvB,OAAQ,CAACpD,EAAI,QACb,mBAAoBZ,IAAgB6L,EACpC,SAAUC,CAC9B,CAAiB,EACKK,EAAe,KAAK5F,KACpB6F,EAAsBN,GAAsB9L,IAAgBmM,EAAa,CAAC,GAAKA,EAAa,CAAC,IAAM,EACzG,OAAOjL,cAAkBgL,CAAS;AAAA,0BACxBG,GAA2B,EAAC,MAAM,CAAE,MAAOP,EAAoB,OAAQ,EAAM,CAAA,EAAE,QAAQlL,EAAI,EAAE,CAAC;AAAA,0BAC9FmD,EAAUnD,EAAI,OAASqD,EAASrD,EAAI,MAAM,EAAI,MAAS,CAAC;AAAA,0CACxCA,EAAI,EAAE;AAAA,2BACrB,IAAM,CACb,KAAKsG,GAAqB,CAAClH,EAAa,CAAC,CAAC,CAC9D,CAAiB;AAAA,2BACU,IAAM,CAQb,KAAK+H,GAAqBnH,EAAKZ,CAAW,CAC9D,CAAiB;AAAA,0BACSY,EAAI,KAAK;AAAA,8BACLmD,EAAU,KAAK0D,GAAmB7G,CAAG,CAAC,CAAC;AAAA,kCACnCZ,EAAc,CAAC;AAAA;AAAA,mCAEdA,CAAW;AAAA,6BACjB+D,EAAU+H,EAAsBM,EAAsB,IAAM,KAAQ,MAAS,CAAC;AAAA,mBACxFxL,EAAI,cAAgBA,EAAI,KAAK,OAChD,CAAa,CAAC;AAAA;AAAA;AAAA;AAAA,2DAI6CqD,EAAS,CACpD,OAAQ,GAAGqH,EAAgB7G,CAAiB,IAC5D,CAAa,CAAC;AAAA,cACAP,GAAOwH,EAAgBrL,GAAO,KAAKmF,GAAa,IAAInF,CAAG,EAAGA,GAAO,CAC/D,MAAM2G,EAAW,KAAKxB,GAAa,IAAInF,CAAG,EAC1C,GAAI2G,IAAa,OACb,MAAM,IAAI,MAAM,6DAA6D,EAEjF,MAAMmF,EAAe,KAAK5F,KAEpB+F,EAAgBtF,EAAW,EAG3BuF,EAAgB,KAAKzG,GAAsBwG,IAAkB,KAAKxG,GAAoB,CAAC,EAAI,GAC3F0G,EAAajE,EAA4B,CAC3C,SAAUgE,EACV,OAAQlM,EAAI,SAAW,EAC3C,CAAiB,EACD,OAAOa;AAAAA;AAAAA,kCAEW8F,EAAW,CAAC;AAAA,0BACpBwF,CAAU;AAAA,0BACVzI,EAAU1D,EAAI,OAAS4D,EAAS5D,EAAI,MAAM,EAAI,MAAS,CAAC;AAAA,0BACxDoM,GAAwB,EAAC,MAAM,CAAE,QAAS,oDAAsD,CAAA,CAAC;AAAA,iCAC1F,KAAKnC,EAAqB;AAAA,gCAC3B,IAAM,CAClB,KAAK,cAAc,IAAIhK,EAAmBD,CAAG,CAAC,CAClE,CAAiB;AAAA,gCACe,IAAM,CAClB,KAAK,cAAc,IAAIE,EAAmBF,CAAG,CAAC,CAClE,CAAiB;AAAA,mBACE,KAAKuE,GAAS,IAAI,CAAChE,EAAKZ,IAAgB,CACvC,MAAMI,EAAO0B,EAAuBzB,EAAKO,EAAI,EAAE,EACzC8L,EAAc1I,EAAS,CACzB,OAAQ,CAACpD,EAAI,QACb,mBAAoBZ,IAAgB6L,CAC5D,CAAqB,EACKO,EAAsBpM,IAAgBmM,EAAa,CAAC,GAAKG,IAAkBH,EAAa,CAAC,EACzFQ,GAAa/L,EAAI,QAAUsB,GAAgB9B,CAAI,EAAI,KACzD,OAAOc;AAAAA,4BACCwL,CAAW;AAAA,4BACXE,GAAyB,EAAC,MAAM,CAAE,MAAO,EAAM,CAAA,CAAC;AAAA,4BAChD7I,EAAUnD,EAAI,OAASqD,EAASrD,EAAI,MAAM,EAAI,MAAS,CAAC;AAAA,+BACrDwL,EAAsB,IAAM,IAAI;AAAA,oCAC3BpM,EAAc,CAAC;AAAA,4BACvBI,EAAK,OAASuD,GAA4B,OAAOvD,EAAK,KAAK,CAAC,CAAC;AAAA,qCACpDkM,CAAa;AAAA,qCACbtM,CAAW;AAAA,sDACMY,EAAI,EAAE;AAAA,6BAC/B,IAAM,CACX,KAAKsG,GAAqB,CAAClH,EAAasM,CAAa,CAAC,EACtD,KAAK,cAAc,IAAInM,EAAqBC,EAAMC,CAAG,CAAC,CAC9E,CAAqB;AAAA,qBACAsM,EAAU,OAC/B,CAAiB,CAAC;AAAA,oBAElB,CAAa,CAAC;AAAA,cACA,KAAKzE,GAAsBwD,EAAe,MAAM,CAAC;AAAA,8DACDzH,EAAS,CACvD,OAAQ,GAAG,KAAK,IAAI,EAAGwH,EAAc,OAASF,CAAgB,EAAI9G,CAAiB,IACnG,CAAa,CAAC;AAAA;AAAA;AAAA;AAAA,QAIL,KAAKE,GAAS,CACP,KAAM,IACtB,CAAa,CACb,CAAS,EAQD,MAAMkI,EADe,KAAKtG,KACoB,CAAC,EACzCuG,EAAsB,KAAK/F,KAC7B,KAAKf,IAA2B6G,EAA2B,GAAKC,GAChE,KAAK7F,GAAqB6F,CAAmB,EAEjD,KAAKnG,GAAyB,EAC9B,KAAKG,GAAqB,EACtB,KAAKf,IAKA,KAAKL,KAEd,KAAKX,GAAe,GACpB,KAAKgB,GAA0B,GAG3B,KAAKE,KACL,KAAKA,GAAkB,GAClB,KAAKE,KAEjB,CACL,CACA,eAAe,OAAO,qBAAsBzB,EAAQ,EC7xBpD,MAAM7E,EAAS,IAAI,cACnBA,EAAO,YACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAaC,ECXD,KAAM,CAAE,KAAAqB,EAAM,EAAGC,EACXgD,EAAY,CAKd,qBAAsB,kCAKtB,sBAAuB,mCAKvB,gBAAiB,wBACrB,EACMC,GAAOC,EAA4B,gDAAiDF,CAAS,EAC7FG,EAAaC,EAA6B,KAAK,OAAWH,EAAI,EAC7D,MAAM2I,WAA2B,WAAY,CAChDpI,GAAU,KAAK,aAAa,CAAE,KAAM,MAAQ,CAAA,EAC5CoB,GAA0B,GAC1BnB,GAAW,CAAA,EACXC,GAAQ,CAAA,EACRI,GAAgB,OAChBC,GAAS,OACTE,GAAiB,GACjBC,GAAW,GAOX2H,GAAmB,CAAA,EACnBC,GAAgB,CAAA,EAChBnI,GAAa,KACboI,GAAW,CAAA,EACX5H,GAAsB,GACtBH,GACA,mBAAoB,CAChB,KAAKR,GAAQ,mBAAqB,CAACwI,CAAwB,CAC9D,CACD,IAAI,MAAO,CACP,MAAO,CACH,QAAS,KAAKH,GACd,KAAM,KAAKC,GACX,QAAS,KAAKC,GACd,mBAAoB,KAAK5H,GACzB,aAAc,KAAKL,GACnB,MAAO,KAAKC,GACZ,iBAAkB,KAAKC,GACvB,cAAe,KAAKC,GACpB,QAAS,KAAKC,EAC1B,CACK,CACD,IAAI,KAAKe,EAAM,CACX,KAAK4G,GAAmB5G,EAAK,QAC7B,KAAK6G,GAAgB7G,EAAK,KAC1B,KAAKnB,GAAgBmB,EAAK,aAC1B,KAAK8G,GAAW9G,EAAK,SAAW,CAAA,EAChC,KAAKnB,GAAgBmB,EAAK,aAC1B,KAAKlB,GAASkB,EAAK,MACnB,KAAKhB,GAAiBgB,EAAK,cAC3B,KAAKf,GAAWe,EAAK,QACjB,OAAOA,EAAK,oBAAuB,YACnC,KAAKd,GAAsBc,EAAK,oBAEpC,KAAKxB,GAAW,CAAC,GAAG,KAAKoI,EAAgB,EACzC,KAAKnI,GAAQ,KAAKuI,GAAoBhH,EAAK,KAAM,KAAK8G,EAAQ,EAC1D,CAAC,KAAKnH,IAA2BK,EAAK,cACtC,KAAKtB,GAAasB,EAAK,aAEvB,KAAKtB,IACL,KAAKuI,GAAU,KAAKvI,EAAU,EAElC,KAAKK,GAAoBiB,EAAK,iBAC9B,KAAKD,GAAO,CACf,CACDmH,GAAmBjN,EAAKkN,EAAQC,EAAkB,CAC9C,IAAIC,EAAmB,GACvB,KAAM,CAAE,IAAA5K,EAAK,KAAAe,EAAM,SAAA8J,EAAU,MAAAC,CAAK,EAAKJ,EACvC,IAAIK,EACJ,OAAI/K,EACA+K,EAAajM,EAAyB,CAACG,EAAuBzB,EAAKwC,CAAG,CAAC,CAAC,EAGxE+K,EAAajM,EAAyBtB,EAAI,MAAM,OAAOD,GAAQoN,EAAiB,IAAIpN,EAAK,QAAQ,CAAC,CAAC,EAEnGuN,EACAF,EAAmBE,EAAM,KAAKC,CAAU,EAEnChK,IACL6J,EAAmBG,EAAW,SAAShK,EAAK,YAAa,CAAA,GAQtD8J,EAAW,CAACD,EAAmBA,CACzC,CACDL,GAAoBrK,EAAM8K,EAAS,CAC/B,GAAIA,EAAQ,SAAW,EACnB,MAAO,CAAC,GAAG9K,CAAI,EAEnB,MAAMyK,EAAmB,IAAI,IAAI,KAAK5I,GAAS,OAAO7E,GAAUA,EAAO,OAAO,EAAE,IAAIA,GAAUA,EAAO,EAAE,CAAC,EACxG,OAAOgD,EAAK,IAAI1C,GAAO,CAEnB,IAAIyN,EAAqB,GACzB,UAAWP,KAAUM,EAIjB,GAAI,CAHqB,KAAKP,GAAmBjN,EAAKkN,EAAQC,CAAgB,EAGvD,CACnBM,EAAqB,GACrB,KACH,CAEL,MAAO,CACH,GAAGzN,EACH,OAAQ,CAACyN,CACzB,CACA,CAAS,CACJ,CACDT,GAAUU,EAAO,CACb,KAAM,CAAE,SAAAzL,EAAU,UAAA0L,CAAW,EAAGD,EAChC,KAAKlJ,GAAM,KAAK,CAACoJ,EAAMC,IAAS,CAC5B,MAAMC,EAAQrM,EAAuBmM,EAAM3L,CAAQ,EAC7C8L,EAAQtM,EAAuBoM,EAAM5L,CAAQ,EAC7C+L,EAAS,OAAOF,EAAM,OAAU,SAAWA,EAAM,MAAQ,OAAOA,EAAM,KAAK,EAAE,YAAW,EACxFG,EAAS,OAAOF,EAAM,OAAU,SAAWA,EAAM,MAAQ,OAAOA,EAAM,KAAK,EAAE,YAAW,EAC9F,OAAIC,EAASC,EACFN,IAAc,MAAgC,GAAK,EAE1DK,EAASC,EACFN,IAAc,MAAgC,EAAI,GAEtD,CACnB,CAAS,EACD,KAAK7H,GAAO,CACf,CACD4B,GAAqBJ,EAAO,CACxB,KAAM,CAAE,OAAA5H,CAAM,EAAK4H,EAAM,KACrB5H,EAAO,UACP,KAAKwO,GAAmBxO,CAAM,CAErC,CACDwO,GAAmBxO,EAAQ,CACvB,GAAI,KAAK+E,IAAc,KAAKA,GAAW,WAAa/E,EAAO,GAAI,CAC3D,KAAM,CAAE,SAAAuC,EAAU,UAAA0L,GAAc,KAAKlJ,GAIjCkJ,IAAc,OACd,KAAKlJ,GAAa,KAIlB,KAAKA,GAAa,CACd,SAAAxC,EACA,UAAW,MAC/B,CAES,MAGG,KAAKwC,GAAa,CACd,SAAU/E,EAAO,GACjB,UAAW,KAC3B,EAEQ,MAAMyO,EAAazO,EAAO,MACtB,KAAK+E,IACL,KAAKuI,GAAU,KAAKvI,EAAU,EAC9B0C,EAAmB,KAAK1C,GAAW,YAAc,MAC7CR,EAAWH,EAAU,qBAAsB,CAAE,IAAKqK,GAAc,GAAI,EACpElK,EAAWH,EAAU,sBAAuB,CAAE,IAAKqK,GAAc,EAAI,CAAA,CAAC,IAI1E,KAAK3J,GAAQ,KAAKuI,GAAoB,KAAKH,GAAe,KAAKC,EAAQ,EACvE,KAAK/G,GAAO,EACZqB,EAAmBlD,EAAWH,EAAU,gBAAiB,CAAE,IAAKqK,GAAc,EAAI,CAAA,CAAC,EAE1F,CACDC,GAA8B9G,EAAO,CACjC,KAAK4G,GAAmB5G,EAAM,KAAK,MAAM,CAC5C,CACD+G,IAAiC,CAC7B,KAAK5J,GAAa,KAClB,KAAKD,GAAQ,CAAC,GAAG,KAAKoI,EAAa,EACnC,KAAK9G,GAAO,CACf,CACDA,IAAU,CAGN6F,EAAe9K;AAAA,kCACW,CACtB,QAAS,KAAK0D,GACd,KAAM,KAAKC,GACX,WAAY,KAAKC,GACjB,aAAc,KAAKG,GACnB,MAAO,KAAKC,GACZ,iBAAkB,KAAKC,GACvB,cAAe,KAAKC,GACpB,QAAS,KAAKC,GACd,mBAAoB,KAAKC,EACrC,CAAS;AAAA,6BACoB,KAAKyC,EAAoB;AAAA,sCAChB,KAAK0G,EAA6B;AAAA,uCACjC,KAAKC,EAA8B;AAAA;AAAA,MAEnE,KAAK/J,GAAS,CACT,KAAM,IAClB,CAAS,EAED,KAAKoB,GAA0B,EAClC,CACL,CACA,eAAe,OAAO,gCAAiCgH,EAAkB"}