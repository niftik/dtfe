{"version":3,"file":"TreeOutline-CeMGdnsP.js","sources":["../../ui/components/tree_outline/treeOutline.css.js","../../ui/components/tree_outline/TreeOutlineUtils.js","../../ui/components/tree_outline/TreeOutline.js"],"sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n// IMPORTANT: this file is auto generated. Please do not edit this file.\n/* istanbul ignore file */\nconst styles = new CSSStyleSheet();\nstyles.replaceSync(\n`/*\n * Copyright 2021 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  --list-group-padding: 16px;\n}\n\nli {\n  border: 2px solid transparent;\n  list-style: none;\n  text-overflow: ellipsis;\n  min-height: 12px;\n}\n\n.compact {\n  border: 0;\n}\n\n.tree-item:hover {\n  background-color: var(--sys-color-state-hover-on-subtle);\n}\n\n.tree-node-key {\n  white-space: var(--override-key-whitespace-wrapping);\n  /* Override the default |min-width: auto| to avoid overflows of flex items */\n  min-width: 0;\n  flex-grow: 1;\n}\n\n.arrow-icon {\n  display: block;\n  user-select: none;\n  mask-image: var(--image-file-triangle-right);\n  background-color: var(--icon-default);\n  content: \"\";\n  text-shadow: none;\n  height: 14px;\n  width: 14px;\n  overflow: hidden;\n  flex: none;\n  transition: transform 200ms;\n}\n\nul {\n  margin: 0;\n  padding: 0;\n}\n\nul[role=\"group\"] {\n  padding-left: var(--list-group-padding);\n}\n\nli:not(.parent) > .arrow-and-key-wrapper > .arrow-icon {\n  mask-size: 0;\n}\n\nli.parent.expanded > .arrow-and-key-wrapper > .arrow-icon {\n  transform: rotate(90deg);\n}\n\nli.is-top-level {\n  border-top: var(--override-top-node-border);\n}\n\nli.is-top-level:last-child {\n  border-bottom: var(--override-top-node-border);\n}\n\n:host([animated]) li:not(.is-top-level) {\n  animation-name: slideIn;\n  animation-duration: 150ms;\n  animation-timing-function: cubic-bezier(0, 0, 0.3, 1);\n  animation-fill-mode: forwards;\n}\n\n@keyframes slideIn {\n  from {\n    transform: translateY(-5px);\n    opacity: 0%;\n  }\n\n  to {\n    transform: none;\n    opacity: 100%;\n  }\n}\n\n.arrow-and-key-wrapper {\n  display: flex;\n  align-content: center;\n  align-items: center;\n\n  & ::selection {\n    background-color: var(--sys-color-state-focus-select);\n  }\n}\n\n[role=\"treeitem\"]:focus {\n  outline: 0;\n}\n\nul[role=\"tree\"]:focus-within [role=\"treeitem\"].selected > .arrow-and-key-wrapper {\n  /* stylelint-disable-next-line color-named */\n  background-color: var(--sys-color-tonal-container);\n}\n\n.text-ellipsis {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.inline-icon {\n  vertical-align: sub;\n}\n\n@media (forced-colors: active) {\n  .arrow-icon {\n    background-color: ButtonText;\n  }\n\n  ul[role=\"tree\"]:focus-within [role=\"treeitem\"].selected {\n    outline: solid 1px ButtonText;\n  }\n}\n\n/*# sourceURL=treeOutline.css */\n`);\n\nexport default styles;\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nexport function isExpandableNode(node) {\n    return 'children' in node;\n}\n/**\n * This is a custom lit-html directive that lets us track the DOM nodes that Lit\n * creates and maps them to the tree node that was given to us. This means we\n * can navigate between real DOM node and structural tree node easily in code.\n */\nclass TrackDOMNodeToTreeNode extends LitHtml.Directive.Directive {\n    constructor(partInfo) {\n        super(partInfo);\n        if (partInfo.type !== LitHtml.Directive.PartType.ATTRIBUTE) {\n            throw new Error('TrackDOMNodeToTreeNode directive must be used as an attribute.');\n        }\n    }\n    update(part, [weakMap, treeNode]) {\n        const elem = part.element;\n        if (!(elem instanceof HTMLLIElement)) {\n            throw new Error('trackTreeNodeToDOMNode must be used on <li> elements.');\n        }\n        weakMap.set(elem, treeNode);\n    }\n    /*\n     * Because this directive doesn't render anything, there's no implementation\n     * here for the render method. But we need it to state the params the\n     * directive takes so the update() method's types are correct. Unfortunately\n     * we have to pass any as the generic type because we can't define this class\n     * using a generic - the generic gets lost when wrapped in the directive call\n     * below.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    render(_weakmap, _treeNode) {\n    }\n}\nexport const trackDOMNodeToTreeNode = LitHtml.Directive.directive(TrackDOMNodeToTreeNode);\n/**\n * Finds the next sibling of the node's parent, recursing up the tree if\n * required.\n * Given:\n * A\n *   * B\n *     * C\n * D\n * If called on B, this will return D. If called on C, this will also return D.\n */\nconst findNextParentSibling = (currentDOMNode) => {\n    // We go up two parents here because the structure is:\n    // <li treeitem> => <ul group> => <li treeitem>\n    // So if we are on the last treeitem (furthest to the right), we need to find its parent tree item, which is two parents up.\n    const currentDOMNodeParentListItem = currentDOMNode.parentElement?.parentElement;\n    if (currentDOMNodeParentListItem && currentDOMNodeParentListItem instanceof HTMLLIElement) {\n        const parentNodeSibling = currentDOMNodeParentListItem.nextElementSibling;\n        // If this parent doesn't have a sibling, recurse up the tree to look for\n        // the nearest parent that does have a sibling.\n        if (parentNodeSibling && parentNodeSibling instanceof HTMLLIElement) {\n            return parentNodeSibling;\n        }\n        return findNextParentSibling(currentDOMNodeParentListItem);\n    }\n    return null;\n};\nconst getFirstChildOfExpandedTreeNode = (currentDOMNode) => {\n    const firstChild = currentDOMNode.querySelector(':scope > [role=\"group\"] > [role=\"treeitem\"]:first-child');\n    if (!firstChild) {\n        throw new Error('Could not find child of expanded node.');\n    }\n    return firstChild;\n};\nconst domNodeIsExpandable = (domNode) => {\n    // Nodes with no children are not given the aria-expanded attributes.\n    // Nodes with children are given aria-expanded = true/false.\n    return domNode.getAttribute('aria-expanded') !== null;\n};\nconst domNodeIsLeafNode = (domNode) => {\n    return !domNodeIsExpandable(domNode);\n};\nconst domNodeIsExpanded = (domNode) => {\n    // Nodes with no children are not given the aria-expanded attributes.\n    // Nodes with children are given aria-expanded = true/false.\n    return domNodeIsExpandable(domNode) && domNode.getAttribute('aria-expanded') === 'true';\n};\nconst getDeepLastChildOfExpandedTreeNode = (currentDOMNode) => {\n    const lastChild = currentDOMNode.querySelector(':scope > [role=\"group\"] > [role=\"treeitem\"]:last-child');\n    if (!lastChild) {\n        throw new Error('Could not find child of expanded node.');\n    }\n    if (domNodeIsExpanded(lastChild)) {\n        return getDeepLastChildOfExpandedTreeNode(lastChild);\n    }\n    return lastChild;\n};\nconst getNextSiblingOfCurrentDOMNode = (currentDOMNode) => {\n    const currentNodeSibling = currentDOMNode.nextElementSibling;\n    if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n        return currentNodeSibling;\n    }\n    return null;\n};\nconst getPreviousSiblingOfCurrentDOMNode = (currentDOMNode) => {\n    const currentNodeSibling = currentDOMNode.previousElementSibling;\n    if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n        return currentNodeSibling;\n    }\n    return null;\n};\nconst getParentListItemForDOMNode = (currentDOMNode) => {\n    let parentNode = currentDOMNode.parentElement;\n    if (!parentNode) {\n        return null;\n    }\n    while (parentNode && parentNode.getAttribute('role') !== 'treeitem' &&\n        (parentNode instanceof HTMLLIElement) === false) {\n        parentNode = parentNode.parentElement;\n    }\n    return parentNode;\n};\n/**\n * We cache a tree node's children; they are lazily evaluated and if two code\n * paths get the children, we need to make sure they get the same objects.\n *\n * We're OK to use <unknown> here as the weakmap doesn't care and a TreeOutline that\n * adds nodes of type X to the map will always then get children of that type\n * back as that's enforced by the TreeOutline types elsewhere. We can't make\n * this WeakMap easily generic as it's a top level variable.\n */\nconst treeNodeChildrenWeakMap = new WeakMap();\nexport const getNodeChildren = async (node) => {\n    if (!node.children) {\n        throw new Error('Asked for children of node that does not have any children.');\n    }\n    const cachedChildren = treeNodeChildrenWeakMap.get(node);\n    if (cachedChildren) {\n        return cachedChildren;\n    }\n    const children = await node.children();\n    treeNodeChildrenWeakMap.set(node, children);\n    return children;\n};\n/**\n * Searches the tree and returns a path to the given node.\n * e.g. if the tree is:\n * A\n * - B\n *   - C\n * - D\n *   - E\n *   - F\n *\n * And you look for F, you'll get back [A, D, F]\n */\nexport const getPathToTreeNode = async (tree, nodeIdToFind) => {\n    for (const rootNode of tree) {\n        const foundPathOrNull = await getPathToTreeNodeRecursively(rootNode, nodeIdToFind, [rootNode]);\n        if (foundPathOrNull !== null) {\n            return foundPathOrNull;\n        }\n    }\n    return null;\n};\nconst getPathToTreeNodeRecursively = async (currentNode, nodeIdToFind, pathToNode) => {\n    if (currentNode.id === nodeIdToFind) {\n        return pathToNode;\n    }\n    if (currentNode.children) {\n        const children = await getNodeChildren(currentNode);\n        for (const child of children) {\n            const foundPathOrNull = await getPathToTreeNodeRecursively(child, nodeIdToFind, [...pathToNode, child]);\n            if (foundPathOrNull !== null) {\n                return foundPathOrNull;\n            }\n        }\n    }\n    return null;\n};\nexport const findNextNodeForTreeOutlineKeyboardNavigation = (options) => {\n    const { currentDOMNode, currentTreeNode, direction, setNodeExpandedState, } = options;\n    if (!currentTreeNode) {\n        return currentDOMNode;\n    }\n    if (direction === \"ArrowDown\" /* Platform.KeyboardUtilities.ArrowKey.DOWN */) {\n        // If the node has expanded children, down takes you into that list.\n        if (domNodeIsExpanded(currentDOMNode)) {\n            return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // If the node has a sibling, we go to that.\n        const currentNodeSibling = getNextSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodeSibling) {\n            return currentNodeSibling;\n        }\n        // If the Node's parent has a sibling then we go to that.\n        const parentSibling = findNextParentSibling(currentDOMNode);\n        if (parentSibling) {\n            return parentSibling;\n        }\n    }\n    else if (direction === \"ArrowRight\" /* Platform.KeyboardUtilities.ArrowKey.RIGHT */) {\n        if (domNodeIsLeafNode(currentDOMNode)) {\n            // If the node cannot be expanded, we have nothing to do and we leave everything as is.\n            return currentDOMNode;\n        }\n        // If the current node is expanded, move and focus into the first child\n        if (domNodeIsExpanded(currentDOMNode)) {\n            return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // Else, we expand the Node (but leave focus where it is)\n        setNodeExpandedState(currentTreeNode, true);\n        return currentDOMNode;\n    }\n    else if (direction === \"ArrowUp\" /* Platform.KeyboardUtilities.ArrowKey.UP */) {\n        // First see if there is a previous sibling\n        const currentNodePreviousSibling = getPreviousSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodePreviousSibling) {\n            // We now find the nested node within our previous sibling; if it has\n            // children that are expanded, we want to find the last child and\n            // highlight that, else we'll highlight our sibling directly.\n            if (domNodeIsExpanded(currentNodePreviousSibling)) {\n                return getDeepLastChildOfExpandedTreeNode(currentNodePreviousSibling);\n            }\n            // Otherwise, if we have a previous sibling with no children, focus it.\n            return currentNodePreviousSibling;\n        }\n        // Otherwise, let's go to the direct parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n            return parentNode;\n        }\n    }\n    else if (direction === \"ArrowLeft\" /* Platform.KeyboardUtilities.ArrowKey.LEFT */) {\n        // If the node is expanded, we close it.\n        if (domNodeIsExpanded(currentDOMNode)) {\n            setNodeExpandedState(currentTreeNode, false);\n            return currentDOMNode;\n        }\n        // Otherwise, let's go to the parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n            return parentNode;\n        }\n    }\n    // If we got here, there's no other option than to stay put.\n    return currentDOMNode;\n};\n//# sourceMappingURL=TreeOutlineUtils.js.map","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as VisualLogging from '../../visual_logging/visual_logging.js';\nimport * as CodeHighlighter from '../code_highlighter/code_highlighter.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\nimport treeOutlineStyles from './treeOutline.css.js';\nimport { findNextNodeForTreeOutlineKeyboardNavigation, getNodeChildren, getPathToTreeNode, isExpandableNode, trackDOMNodeToTreeNode, } from './TreeOutlineUtils.js';\nconst { html, Directives: { ifDefined } } = LitHtml;\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\nexport function defaultRenderer(node) {\n    return html `${node.treeNodeData}`;\n}\nexport class ItemSelectedEvent extends Event {\n    static eventName = 'itemselected';\n    data;\n    constructor(node) {\n        super(ItemSelectedEvent.eventName, { bubbles: true, composed: true });\n        this.data = { node };\n    }\n}\nexport class ItemMouseOverEvent extends Event {\n    static eventName = 'itemmouseover';\n    data;\n    constructor(node) {\n        super(ItemMouseOverEvent.eventName, { bubbles: true, composed: true });\n        this.data = { node };\n    }\n}\nexport class ItemMouseOutEvent extends Event {\n    static eventName = 'itemmouseout';\n    data;\n    constructor(node) {\n        super(ItemMouseOutEvent.eventName, { bubbles: true, composed: true });\n        this.data = { node };\n    }\n}\nexport class TreeOutline extends HTMLElement {\n    #shadow = this.attachShadow({ mode: 'open' });\n    #treeData = [];\n    #nodeExpandedMap = new Map();\n    #domNodeToTreeNodeMap = new WeakMap();\n    #hasRenderedAtLeastOnce = false;\n    /**\n     * If we have expanded to a certain node, we want to focus it once we've\n     * rendered. But we render lazily and wrapped in LitHtml.until, so we can't\n     * know for sure when that node will be rendered. This variable tracks the\n     * node that we want focused but may not yet have been rendered.\n     */\n    #nodeIdPendingFocus = null;\n    #selectedTreeNode = null;\n    #defaultRenderer = (node, _state) => {\n        if (typeof node.treeNodeData !== 'string') {\n            console.warn(`The default TreeOutline renderer simply stringifies its given value. You passed in ${JSON.stringify(node.treeNodeData, null, 2)}. Consider providing a different defaultRenderer that can handle nodes of this type.`);\n        }\n        return html `${String(node.treeNodeData)}`;\n    };\n    #nodeFilter;\n    #compact = false;\n    /**\n     * scheduledRender = render() has been called and scheduled a render.\n     */\n    #scheduledRender = false;\n    /**\n     * enqueuedRender = render() was called mid-way through an existing render.\n     */\n    #enqueuedRender = false;\n    static get observedAttributes() {\n        return ['nowrap', 'toplevelbordercolor'];\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        switch (name) {\n            case 'nowrap': {\n                this.#setNodeKeyNoWrapCSSVariable(newValue);\n                break;\n            }\n            case 'toplevelbordercolor': {\n                this.#setTopLevelNodeBorderColorCSSVariable(newValue);\n                break;\n            }\n        }\n    }\n    connectedCallback() {\n        this.#setTopLevelNodeBorderColorCSSVariable(this.getAttribute('toplevelbordercolor'));\n        this.#setNodeKeyNoWrapCSSVariable(this.getAttribute('nowrap'));\n        this.#shadow.adoptedStyleSheets = [treeOutlineStyles, CodeHighlighter.Style.default];\n    }\n    get data() {\n        return {\n            tree: this.#treeData,\n            defaultRenderer: this.#defaultRenderer,\n        };\n    }\n    set data(data) {\n        this.#defaultRenderer = data.defaultRenderer;\n        this.#treeData = data.tree;\n        this.#nodeFilter = data.filter;\n        this.#compact = data.compact || false;\n        if (!this.#hasRenderedAtLeastOnce) {\n            this.#selectedTreeNode = this.#treeData[0];\n        }\n        void this.#render();\n    }\n    /**\n     * Recursively expands the tree from the root nodes, to a max depth. The max\n     * depth is 0 indexed - so a maxDepth of 2 (default) will expand 3 levels: 0,\n     * 1 and 2.\n     */\n    async expandRecursively(maxDepth = 2) {\n        await Promise.all(this.#treeData.map(rootNode => this.#expandAndRecurse(rootNode, 0, maxDepth)));\n        await this.#render();\n    }\n    /**\n     * Collapses all nodes in the tree.\n     */\n    async collapseAllNodes() {\n        this.#nodeExpandedMap.clear();\n        await this.#render();\n    }\n    /**\n     * Takes a TreeNode, expands the outline to reveal it, and focuses it.\n     */\n    async expandToAndSelectTreeNode(targetTreeNode) {\n        return this.expandToAndSelectTreeNodeId(targetTreeNode.id);\n    }\n    /**\n     * Takes a TreeNode ID, expands the outline to reveal it, and focuses it.\n     */\n    async expandToAndSelectTreeNodeId(targetTreeNodeId) {\n        const pathToTreeNode = await getPathToTreeNode(this.#treeData, targetTreeNodeId);\n        if (pathToTreeNode === null) {\n            throw new Error(`Could not find node with id ${targetTreeNodeId} in the tree.`);\n        }\n        pathToTreeNode.forEach((node, index) => {\n            // We don't expand the very last node, which was the target node.\n            if (index < pathToTreeNode.length - 1) {\n                this.#setNodeExpandedState(node, true);\n            }\n        });\n        // Mark the node as pending focus so when it is rendered into the DOM we can focus it\n        this.#nodeIdPendingFocus = targetTreeNodeId;\n        await this.#render();\n    }\n    /**\n     * Takes a list of TreeNode IDs and expands the corresponding nodes.\n     */\n    expandNodeIds(nodeIds) {\n        nodeIds.forEach(id => this.#nodeExpandedMap.set(id, true));\n        return this.#render();\n    }\n    /**\n     * Takes a TreeNode ID and focuses the corresponding node.\n     */\n    focusNodeId(nodeId) {\n        this.#nodeIdPendingFocus = nodeId;\n        return this.#render();\n    }\n    async collapseChildrenOfNode(domNode) {\n        const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n        if (!treeNode) {\n            return;\n        }\n        await this.#recursivelyCollapseTreeNodeChildren(treeNode);\n        await this.#render();\n    }\n    #setNodeKeyNoWrapCSSVariable(attributeValue) {\n        this.style.setProperty('--override-key-whitespace-wrapping', attributeValue !== null ? 'nowrap' : 'initial');\n    }\n    #setTopLevelNodeBorderColorCSSVariable(attributeValue) {\n        this.style.setProperty('--override-top-node-border', attributeValue ? `1px solid ${attributeValue}` : '');\n    }\n    async #recursivelyCollapseTreeNodeChildren(treeNode) {\n        if (!isExpandableNode(treeNode) || !this.#nodeIsExpanded(treeNode)) {\n            return;\n        }\n        const children = await this.#fetchNodeChildren(treeNode);\n        const childRecursions = Promise.all(children.map(child => this.#recursivelyCollapseTreeNodeChildren(child)));\n        await childRecursions;\n        this.#setNodeExpandedState(treeNode, false);\n    }\n    async #flattenSubtree(node, filter) {\n        const children = await getNodeChildren(node);\n        const filteredChildren = [];\n        for (const child of children) {\n            const filtering = filter(child.treeNodeData);\n            // We always include the selected node in the tree, regardless of its filtering status.\n            const toBeSelected = this.#isSelectedNode(child) || child.id === this.#nodeIdPendingFocus;\n            // If a node is already expanded we should not flatten it away.\n            const expanded = this.#nodeExpandedMap.get(child.id);\n            if (filtering === \"SHOW\" /* FilterOption.SHOW */ || toBeSelected || expanded) {\n                filteredChildren.push(child);\n            }\n            else if (filtering === \"FLATTEN\" /* FilterOption.FLATTEN */ && isExpandableNode(child)) {\n                const grandChildren = await this.#flattenSubtree(child, filter);\n                filteredChildren.push(...grandChildren);\n            }\n        }\n        return filteredChildren;\n    }\n    async #fetchNodeChildren(node) {\n        const children = await getNodeChildren(node);\n        const filter = this.#nodeFilter;\n        if (!filter) {\n            return children;\n        }\n        const filteredDescendants = await this.#flattenSubtree(node, filter);\n        return filteredDescendants.length ? filteredDescendants : children;\n    }\n    #setNodeExpandedState(node, newExpandedState) {\n        this.#nodeExpandedMap.set(node.id, newExpandedState);\n    }\n    #nodeIsExpanded(node) {\n        return this.#nodeExpandedMap.get(node.id) || false;\n    }\n    async #expandAndRecurse(node, currentDepth, maxDepth) {\n        if (!isExpandableNode(node)) {\n            return;\n        }\n        this.#setNodeExpandedState(node, true);\n        if (currentDepth === maxDepth || !isExpandableNode(node)) {\n            return;\n        }\n        const children = await this.#fetchNodeChildren(node);\n        await Promise.all(children.map(child => this.#expandAndRecurse(child, currentDepth + 1, maxDepth)));\n    }\n    #onArrowClick(node) {\n        return (event) => {\n            event.stopPropagation();\n            if (isExpandableNode(node)) {\n                this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n                void this.#render();\n            }\n        };\n    }\n    #onNodeClick(event) {\n        // Avoid it bubbling up to parent tree elements, else clicking a node deep in the tree will toggle it + all its ancestor's visibility.\n        event.stopPropagation();\n        const nodeClickExpandsOrContracts = this.getAttribute('clickabletitle') !== null;\n        const domNode = event.currentTarget;\n        const node = this.#domNodeToTreeNodeMap.get(domNode);\n        if (nodeClickExpandsOrContracts && node && isExpandableNode(node)) {\n            this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n        }\n        void this.#focusTreeNode(domNode);\n    }\n    async #focusTreeNode(domNode) {\n        const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n        if (!treeNode) {\n            return;\n        }\n        this.#selectedTreeNode = treeNode;\n        await this.#render();\n        this.dispatchEvent(new ItemSelectedEvent(treeNode));\n        void coordinator.write('DOMNode focus', () => {\n            domNode.focus();\n        });\n    }\n    #processHomeAndEndKeysNavigation(key) {\n        if (key === 'Home') {\n            const firstRootNode = this.#shadow.querySelector('ul[role=\"tree\"] > li[role=\"treeitem\"]');\n            if (firstRootNode) {\n                void this.#focusTreeNode(firstRootNode);\n            }\n        }\n        else if (key === 'End') {\n            /**\n             * The End key takes the user to the last visible node in the tree - you\n             * can think of this as the one that's rendered closest to the bottom of\n             * the page.\n             *\n             * We could walk our tree and compute this - but it will also be the last\n             * li[role=\"treeitem\"] in the DOM because we only render visible nodes.\n             * Therefore we can select all the nodes and pick the last one.\n             */\n            const allTreeItems = this.#shadow.querySelectorAll('li[role=\"treeitem\"]');\n            const lastTreeItem = allTreeItems[allTreeItems.length - 1];\n            if (lastTreeItem) {\n                void this.#focusTreeNode(lastTreeItem);\n            }\n        }\n    }\n    async #processArrowKeyNavigation(key, currentDOMNode) {\n        const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n        if (!currentTreeNode) {\n            return;\n        }\n        const domNode = findNextNodeForTreeOutlineKeyboardNavigation({\n            currentDOMNode,\n            currentTreeNode,\n            direction: key,\n            setNodeExpandedState: (node, expanded) => this.#setNodeExpandedState(node, expanded),\n        });\n        await this.#focusTreeNode(domNode);\n    }\n    #processEnterOrSpaceNavigation(currentDOMNode) {\n        const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n        if (!currentTreeNode) {\n            return;\n        }\n        if (isExpandableNode(currentTreeNode)) {\n            const currentExpandedState = this.#nodeIsExpanded(currentTreeNode);\n            this.#setNodeExpandedState(currentTreeNode, !currentExpandedState);\n            void this.#render();\n        }\n    }\n    async #onTreeKeyDown(event) {\n        if (!(event.target instanceof HTMLLIElement)) {\n            throw new Error('event.target was not an <li> element');\n        }\n        if (event.key === 'Home' || event.key === 'End') {\n            event.preventDefault();\n            this.#processHomeAndEndKeysNavigation(event.key);\n        }\n        else if (Platform.KeyboardUtilities.keyIsArrowKey(event.key)) {\n            event.preventDefault();\n            await this.#processArrowKeyNavigation(event.key, event.target);\n        }\n        else if (event.key === 'Enter' || event.key === ' ') {\n            event.preventDefault();\n            this.#processEnterOrSpaceNavigation(event.target);\n        }\n    }\n    #focusPendingNode(domNode) {\n        this.#nodeIdPendingFocus = null;\n        void this.#focusTreeNode(domNode);\n    }\n    #isSelectedNode(node) {\n        if (this.#selectedTreeNode) {\n            return node.id === this.#selectedTreeNode.id;\n        }\n        return false;\n    }\n    #renderNode(node, { depth, setSize, positionInSet }) {\n        let childrenToRender;\n        const nodeIsExpanded = this.#nodeIsExpanded(node);\n        if (!isExpandableNode(node) || !nodeIsExpanded) {\n            childrenToRender = LitHtml.nothing;\n        }\n        else {\n            const childNodes = this.#fetchNodeChildren(node).then(children => {\n                return children.map((childNode, index) => {\n                    return this.#renderNode(childNode, { depth: depth + 1, setSize: children.length, positionInSet: index });\n                });\n            });\n            // Disabled until https://crbug.com/1079231 is fixed.\n            // clang-format off\n            childrenToRender = html `<ul role=\"group\">${LitHtml.Directives.until(childNodes)}</ul>`;\n            // clang-format on\n        }\n        const nodeIsFocusable = this.#isSelectedNode(node);\n        const tabIndex = nodeIsFocusable ? 0 : -1;\n        const listItemClasses = LitHtml.Directives.classMap({\n            expanded: isExpandableNode(node) && nodeIsExpanded,\n            parent: isExpandableNode(node),\n            selected: this.#isSelectedNode(node),\n            'is-top-level': depth === 0,\n            compact: this.#compact,\n        });\n        const ariaExpandedAttribute = !isExpandableNode(node) ? undefined : nodeIsExpanded ? 'true' : 'false';\n        let renderedNodeKey;\n        if (node.renderer) {\n            renderedNodeKey = node.renderer(node, { isExpanded: nodeIsExpanded });\n        }\n        else {\n            renderedNodeKey = this.#defaultRenderer(node, { isExpanded: nodeIsExpanded });\n        }\n        // Disabled until https://crbug.com/1079231 is fixed.\n        // clang-format off\n        return html `\n      <li role=\"treeitem\"\n        tabindex=${tabIndex}\n        aria-setsize=${setSize}\n        aria-expanded=${ifDefined(ariaExpandedAttribute)}\n        aria-level=${depth + 1}\n        aria-posinset=${positionInSet + 1}\n        class=${listItemClasses}\n        jslog=${VisualLogging.treeItem(node.jslogContext).track({ click: true, keydown: 'ArrowUp|ArrowDown|ArrowLeft|ArrowRight|Enter|Space|Home|End' })}\n        @click=${this.#onNodeClick}\n        track-dom-node-to-tree-node=${trackDOMNodeToTreeNode(this.#domNodeToTreeNodeMap, node)}\n        on-render=${ComponentHelpers.Directives.nodeRenderedCallback(domNode => {\n            /**\n             * Because TreeNodes are lazily rendered, you can call\n             * `outline.expandToAndSelect(NodeX)`, but `NodeX` will be rendered at some\n             * later point, once it's been fully resolved, within a LitHtml.until\n             * directive. That means we don't have a direct hook into when it's\n             * rendered, which we need because we want to focus the element, so we use this directive to receive a callback when the node is rendered.\n             */\n            if (!(domNode instanceof HTMLLIElement)) {\n                return;\n            }\n            if (this.#nodeIdPendingFocus && node.id === this.#nodeIdPendingFocus) {\n                this.#focusPendingNode(domNode);\n            }\n        })}\n      >\n        <span class=\"arrow-and-key-wrapper\"\n          @mouseover=${() => {\n            this.dispatchEvent(new ItemMouseOverEvent(node));\n        }}\n          @mouseout=${() => {\n            this.dispatchEvent(new ItemMouseOutEvent(node));\n        }}\n        >\n          <span class=\"arrow-icon\" @click=${this.#onArrowClick(node)} jslog=${VisualLogging.expand().track({ click: true })}>\n          </span>\n          <span class=\"tree-node-key\" data-node-key=${node.treeNodeData}>${renderedNodeKey}</span>\n        </span>\n        ${childrenToRender}\n      </li>\n    `;\n        // clang-format on\n    }\n    async #render() {\n        if (this.#scheduledRender) {\n            // If we are already rendering, don't render again immediately, but\n            // enqueue it to be run after we're done on our current render.\n            this.#enqueuedRender = true;\n            return;\n        }\n        this.#scheduledRender = true;\n        await coordinator.write('TreeOutline render', () => {\n            // Disabled until https://crbug.com/1079231 is fixed.\n            // clang-format off\n            LitHtml.render(html `\n      <div class=\"wrapping-container\">\n        <ul role=\"tree\" @keydown=${this.#onTreeKeyDown}>\n          ${this.#treeData.map((topLevelNode, index) => {\n                return this.#renderNode(topLevelNode, {\n                    depth: 0,\n                    setSize: this.#treeData.length,\n                    positionInSet: index,\n                });\n            })}\n        </ul>\n      </div>\n      `, this.#shadow, {\n                host: this,\n            });\n        });\n        // clang-format on\n        this.#hasRenderedAtLeastOnce = true;\n        this.#scheduledRender = false;\n        // If render() was called when we were already mid-render, let's re-render\n        // to ensure we're not rendering any stale UI.\n        if (this.#enqueuedRender) {\n            this.#enqueuedRender = false;\n            return this.#render();\n        }\n    }\n}\ncustomElements.define('devtools-tree-outline', TreeOutline);\n//# sourceMappingURL=TreeOutline.js.map"],"names":["styles","isExpandableNode","node","TrackDOMNodeToTreeNode","LitHtml.Directive.Directive","partInfo","LitHtml.Directive.PartType","part","weakMap","treeNode","elem","_weakmap","_treeNode","trackDOMNodeToTreeNode","LitHtml.Directive.directive","findNextParentSibling","currentDOMNode","currentDOMNodeParentListItem","parentNodeSibling","getFirstChildOfExpandedTreeNode","firstChild","domNodeIsExpandable","domNode","domNodeIsLeafNode","domNodeIsExpanded","getDeepLastChildOfExpandedTreeNode","lastChild","getNextSiblingOfCurrentDOMNode","currentNodeSibling","getPreviousSiblingOfCurrentDOMNode","getParentListItemForDOMNode","parentNode","treeNodeChildrenWeakMap","getNodeChildren","cachedChildren","children","getPathToTreeNode","tree","nodeIdToFind","rootNode","foundPathOrNull","getPathToTreeNodeRecursively","currentNode","pathToNode","child","findNextNodeForTreeOutlineKeyboardNavigation","options","currentTreeNode","direction","setNodeExpandedState","parentSibling","currentNodePreviousSibling","html","ifDefined","LitHtml","coordinator","Coordinator.RenderCoordinator.RenderCoordinator","defaultRenderer","ItemSelectedEvent","ItemMouseOverEvent","ItemMouseOutEvent","TreeOutline","#shadow","#treeData","#nodeExpandedMap","#domNodeToTreeNodeMap","#hasRenderedAtLeastOnce","#nodeIdPendingFocus","#selectedTreeNode","#defaultRenderer","_state","#nodeFilter","#compact","#scheduledRender","#enqueuedRender","name","oldValue","newValue","#setNodeKeyNoWrapCSSVariable","#setTopLevelNodeBorderColorCSSVariable","treeOutlineStyles","CodeHighlighter.Style.default","data","#render","maxDepth","#expandAndRecurse","targetTreeNode","targetTreeNodeId","pathToTreeNode","index","#setNodeExpandedState","nodeIds","id","nodeId","#recursivelyCollapseTreeNodeChildren","attributeValue","#nodeIsExpanded","#fetchNodeChildren","#flattenSubtree","filter","filteredChildren","filtering","toBeSelected","#isSelectedNode","expanded","grandChildren","filteredDescendants","newExpandedState","currentDepth","#onArrowClick","event","#onNodeClick","nodeClickExpandsOrContracts","#focusTreeNode","#processHomeAndEndKeysNavigation","key","firstRootNode","allTreeItems","lastTreeItem","#processArrowKeyNavigation","#processEnterOrSpaceNavigation","currentExpandedState","#onTreeKeyDown","Platform.KeyboardUtilities.keyIsArrowKey","#focusPendingNode","#renderNode","depth","setSize","positionInSet","childrenToRender","nodeIsExpanded","LitHtml.nothing","childNodes","childNode","LitHtml.Directives.until","tabIndex","listItemClasses","LitHtml.Directives.classMap","ariaExpandedAttribute","renderedNodeKey","VisualLogging.treeItem","ComponentHelpers.Directives.nodeRenderedCallback","VisualLogging.expand","LitHtml.render","topLevelNode"],"mappings":"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"}